{
  "file_map": {
    "100": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "104": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "109": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "113": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "115": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "116": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "118": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "119": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "121": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "122": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "123": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "124": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "125": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "142": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "147": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{\n        compute_note_hash_for_nullification_from_read_request, compute_note_hash_for_read_request,\n    },\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter, context)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        note_hash_for_read_request,\n    );\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullification\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "151": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { view_note::<Note>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N = M>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PreprocessorArgs>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PreprocessorArgs) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PreprocessorArgs,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N = M>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; M];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\npub unconstrained fn view_note<Note>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\")\n}\n\nunconstrained fn get_notes_internal<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N = M>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, M>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N = M> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "154": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "157": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "161": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "162": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "163": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "164": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "165": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "172": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "174": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "176": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "178": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(utilityGetRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "179": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "181": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "185": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "187": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::HasStorageSlot;\n\n/// PrivateImmutable\n///\n/// PrivateImmutable is a private state variable type for values that are set once\n/// and remain permanently unchanged.\n///\n/// You can declare a state variable of type PrivateImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PrivateImmutable<YourNote, Context>`\n///\n/// The value is represented as a single note that persists for the lifetime of\n/// the state variable. Once initialized, this note is never nullified or replaced\n/// through the state variable interface - it can only be read.\n///\n/// The PrivateImmutable type facilitates: inserting the permanent note during\n/// initialization, and reading that note.\n///\n/// The methods of PrivateImmutable are:\n/// - `initialize`\n/// - `get_note`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A contract's configuration parameters can be represented as a PrivateImmutable.\n/// Once set during contract deployment or initial setup, these parameters remain\n/// constant for the lifetime of the contract.\n///\n/// ## Privacy\n///\n/// PrivateImmutable has the same privacy properties as PrivateMutable (see\n/// PrivateMutable documentation), including the same privacy considerations\n/// regarding the initialization nullifier potentially leaking information about\n/// which storage slot was initialized.\n///\n/// # Generic Parameters:\n///\n/// * `Note` - A single note of this type will represent the PrivateImmutable's\n///            value at the given storage_slot.\n/// * `Context` - The execution context (PrivateContext or UtilityContext).\n///\n/// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> HasStorageSlot<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    /// Initializes a new PrivateImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. The permanent note for this PrivateImmutable\n    ///                    state variable will have this `storage_slot`.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    /// Computes the nullifier that will be created when this PrivateImmutable is\n    /// initialized.\n    ///\n    /// This function is primarily used internally by the `initialize` method, but\n    /// may also be useful for contracts that need to check if a PrivateImmutable\n    /// has been initialized.\n    ///\n    /// **IMPORTANT PRIVACY CONSIDERATION:**\n    /// This computation has the same privacy implications as PrivateMutable's\n    /// initialization nullifier (see PrivateMutable documentation for detailed\n    /// explanation). The initialization nullifier can leak information about which\n    /// storage slot was initialized.\n    ///\n    /// See https://github.com/AztecProtocol/aztec-packages/issues/15568 for ideas to\n    /// improve this privacy footgun in future.\n    ///\n    /// # Returns\n    ///\n    /// * `Field` - The nullifier that will be emitted when this PrivateImmutable is\n    ///             initialized.\n    ///\n    /// # Advanced\n    ///\n    /// The computation uses the Poseidon2 hash function with a specific generator\n    /// index to hash the storage slot, creating a deterministic nullifier based on\n    /// the storage location.\n    ///\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    /// Initializes a PrivateImmutable state variable instance with a permanent note.\n    ///\n    /// This function inserts the single, permanent note for this state variable. It can\n    /// only be called once per PrivateImmutable. Subsequent calls will fail because\n    /// the initialization nullifier will already exist.\n    ///\n    /// Unlike PrivateMutable, this note will never be nullified or replaced through\n    /// the state variable interface - it persists for the lifetime of the state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `note` - The permanent note to store in this PrivateImmutable. This note\n    ///            contains the unchanging value of the state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper that requires you to decide\n    ///                          whether to encrypt and send the note to someone.\n    ///                          You can call `.emit()` on it to encrypt and log\n    ///                          the note, or `.discard()` to skip emission.\n    ///                          See NoteEmission for more details.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Inserts the provided note into the protocol's Note Hash Tree.\n    /// - Returns a NoteEmission type that allows the caller to decide how to encrypt\n    ///   and deliver the note to its intended recipient.\n    ///\n    /// The initialization nullifier is deterministically computed from the storage\n    /// slot and can leak privacy information (see `compute_initialization_nullifier`\n    /// documentation).\n    ///\n    /// docs:start:initialize\n    pub fn initialize(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n\n    /// Reads the permanent note of a PrivateImmutable state variable instance.\n    ///\n    /// If this PrivateImmutable state variable has not yet been initialized,\n    /// no note will exist: the call will fail and the transaction will not\n    /// be provable.\n    ///\n    /// # Returns\n    ///\n    /// * `Note` - The permanent note stored in this PrivateImmutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Retrieves the note from the PXE via an oracle call\n    /// - Validates that the note exists and belongs to this contract address and\n    ///   storage slot by pushing a read request to the context\n    /// - Returns the note content directly without nullification\n    ///\n    /// Since the note is immutable, there's no risk of reading stale data or\n    /// race conditions - the note never changes after initialization.\n    ///\n    /// docs:start:get_note\n    pub fn get_note(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Checks whether this PrivateImmutable has been initialized.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if the PrivateImmutable has been initialized (the initialization\n    ///            nullifier exists), `false` otherwise.\n    ///\n    /// docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    /// Returns the permanent note in this PrivateImmutable without consuming it.\n    ///\n    /// This function is only available in a UtilityContext (unconstrained environment)\n    /// and is typically used for offchain queries, view functions, or testing.\n    ///\n    /// Unlike the constrained `get_note()`, this function does not push read requests\n    /// or perform validation. It simply reads the note from the PXE's database.\n    ///\n    /// # Returns\n    ///\n    /// * `Note` - The permanent note stored in this PrivateImmutable.\n    ///\n    /// docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note\n    where\n        Note: Packable,\n    {\n        let mut options = NoteViewerOptions::<Note, <Note as Packable>::N>::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "195": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "215": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "216": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "218": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "219": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "221": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "222": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "225": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "236": {
      "path": "/Users/mapache/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "299": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "314": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "324": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "337": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "338": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "339": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "340": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "347": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "352": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "368": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "370": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "371": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "389": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "393": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "453": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/Users/mapache/personal/zk-invoice/packages/contracts/src/main.nr",
      "source": "use aztec::macros::aztec;\n\npub mod types;\npub mod test;\n\n#[aztec]\npub contract InvoiceRegistry {\n    // imports\n    use aztec::{\n        macros::{\n            functions::{external, initializer, internal},\n            storage::storage\n        },\n        context::PrivateContext,\n        protocol_types::{\n            address::AztecAddress,\n            traits::ToField\n        },\n        state_vars::{PrivateImmutable, PublicMutable, Map}\n    };\n    use token_contract::Token;\n    use crate::types::invoice_note::{InvoiceNote, PaymentInfo};\n    use poseidon::poseidon2::Poseidon2;\n\n    #[storage]\n    struct Storage<Context> {\n        // PRIVATE: Only sender can read invoice details (encrypted on-chain)\n        private_invoices: Map<Field, PrivateImmutable<InvoiceNote, Context>, Context>,\n        \n        // PUBLIC: Payment info stored as individual fields for simpler storage\n        // Map from invoice_id to each field of payment info\n        partial_notes: Map<Field, PublicMutable<Field, Context>, Context>,\n        token_addresses: Map<Field, PublicMutable<AztecAddress, Context>, Context>,\n        amounts: Map<Field, PublicMutable<u128, Context>, Context>,\n        title_hashes: Map<Field, PublicMutable<Field, Context>, Context>,\n        \n        // PUBLIC: Track payment status (0 = unpaid, 1 = paid)\n        payment_status: Map<Field, PublicMutable<bool, Context>, Context>,\n    }\n    \n    /**\n     * Create a new invoice\n     * \n     * @param invoice_id - Unique identifier for the invoice\n     * @param title_hash - Hash of the invoice title (public)\n     * @param token_address - Token to be paid\n     * @param amount - Amount to be paid\n     * @param metadata - Optional private metadata\n     */\n    #[external(\"private\")]\n    fn create_invoice(\n        invoice_id: Field,\n        title_hash: Field,\n        token_address: AztecAddress,\n        amount: u128,\n        metadata: Field\n    ) {\n        let sender = context.msg_sender().unwrap();\n\n        // Create partial note (sender will receive payment privately)\n        let partial_note = Token::at(token_address)\n            .initialize_transfer_commitment(\n                sender,\n                context.this_address()\n            ).call(&mut context);\n\n        // Store PRIVATE invoice data (encrypted)\n        let invoice_note = InvoiceNote::new(\n            sender,  // owner is the user (proper per-user encryption)\n            sender,\n            metadata,\n            invoice_id\n        );\n        storage.private_invoices.at(invoice_id)\n            .initialize(invoice_note);\n\n        // Store PUBLIC payment info as separate fields for easier storage\n        // Enqueue public function calls to store payment info\n        InvoiceRegistry::at(context.this_address())\n            ._store_payment_info(\n                invoice_id,\n                partial_note,\n                token_address,\n                amount,\n                title_hash\n            ).enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to store payment info in public storage\n     * Called from create_invoice via enqueue\n     */\n    #[external(\"public\")]\n    fn _store_payment_info(\n        invoice_id: Field,\n        partial_note: Field,\n        token_address: AztecAddress,\n        amount: u128,\n        title_hash: Field\n    ) {\n        storage.partial_notes.at(invoice_id).write(partial_note);\n        storage.token_addresses.at(invoice_id).write(token_address);\n        storage.amounts.at(invoice_id).write(amount);\n        storage.title_hashes.at(invoice_id).write(title_hash);\n    }\n    \n    /**\n     * Pay an invoice by completing the partial note\n     *\n     * @param invoice_id - The invoice to pay\n     * @param partial_note - The partial note commitment from the invoice\n     * @param token_address - The token to pay with\n     * @param amount - The amount to pay\n     * @param _nonce - Authwit nonce for token transfer\n     */\n    #[external(\"private\")]\n    fn pay_invoice(\n        invoice_id: Field,\n        partial_note: Field,\n        token_address: AztecAddress,\n        amount: u128,\n        _nonce: Field\n    ) {\n        let caller = context.msg_sender().unwrap();\n        \n        // Complete partial note (transfer tokens from payer to sender)\n        Token::at(token_address)\n            .transfer_private_to_commitment(\n                caller,\n                partial_note,\n                amount,\n                _nonce\n            )\n            .call(&mut context);\n        \n        // PREVENT DOUBLE-PAYMENT: Emit nullifier (using contract address as salt)\n        let payment_nullifier = compute_payment_nullifier(invoice_id, context.this_address());\n        context.push_nullifier(payment_nullifier);\n        \n        // Mark invoice as paid in public storage\n        InvoiceRegistry::at(context.this_address())\n            ._mark_paid(invoice_id)\n            .enqueue(&mut context);\n        \n        // TODO: Emit event for API tracking\n        // Events in private functions are not yet fully supported, so we skip this for now\n    }\n\n    /**\n     * Internal function to mark an invoice as paid in public storage\n     * Called from pay_invoice via enqueue\n     */\n    #[external(\"public\")]\n    fn _mark_paid(invoice_id: Field) {\n        storage.payment_status.at(invoice_id).write(true);\n    }\n\n    /**\n     * Check if an invoice has been paid\n     *\n     * @param invoice_id - The invoice to check\n     * @return true if paid, false otherwise\n     */\n    #[external(\"utility\")]\n    unconstrained fn is_paid(invoice_id: Field) -> pub bool {\n        storage.payment_status.at(invoice_id).read()\n    }\n\n    /**\n     * Get private invoice data (only sender with correct viewing keys can read)\n     * \n     * @param invoice_id - The invoice to retrieve\n     * @return The private invoice note\n     */\n    #[external(\"utility\")]\n    unconstrained fn get_invoice(invoice_id: Field) -> pub InvoiceNote {\n        storage.private_invoices.at(invoice_id).view_note()\n    }\n\n    /**\n     * Get public payment info (anyone can read)\n     * \n     * @param invoice_id - The invoice to retrieve\n     * @return The public payment information as a struct\n     */\n    #[external(\"utility\")]\n    unconstrained fn get_payment_info(invoice_id: Field) -> pub PaymentInfo {\n        let partial_note = storage.partial_notes.at(invoice_id).read();\n        let token_address = storage.token_addresses.at(invoice_id).read();\n        let amount = storage.amounts.at(invoice_id).read();\n        let title_hash = storage.title_hashes.at(invoice_id).read();\n        \n        PaymentInfo {\n            partial_note,\n            token_address,\n            amount,\n            title_hash\n        }\n    }\n\n    /**\n     * Helper function to compute payment nullifier consistently\n     * Uses contract address as salt for automatic uniqueness per deployment\n     * \n     * @param invoice_id - The invoice ID\n     * @param contract_address - The registry contract address\n     * @return The payment nullifier\n     */\n    #[contract_library_method]\n    fn compute_payment_nullifier(invoice_id: Field, contract_address: AztecAddress) -> Field {\n        Poseidon2::hash([invoice_id, contract_address.to_field()], 2)\n    }\n}\n"
    },
    "57": {
      "path": "/Users/mapache/personal/zk-invoice/packages/contracts/src/types/invoice_note.nr",
      "source": "use aztec::{\n    macros::notes::note,\n    oracle::random::random,\n    protocol_types::{\n        traits::{Deserialize, Serialize, Packable},\n        address::AztecAddress,\n    },  \n};\n\n// Private invoice data (encrypted on-chain, only sender can read with viewing keys)\n#[derive(Eq, Serialize, Deserialize, Packable)]\n#[note]\npub struct InvoiceNote {\n    pub owner: AztecAddress,        // Note owner (registry contract)\n    pub sender: AztecAddress,       // Who receives payment (kept private)\n    pub metadata: Field,             // Optional private notes\n    pub invoice_id: Field,           // Links to public payment info\n    pub randomness: Field,\n}\n\nimpl InvoiceNote {\n    pub fn new(\n        owner: AztecAddress,\n        sender: AztecAddress,\n        metadata: Field,\n        invoice_id: Field,\n    ) -> Self {\n        Self {\n            owner,\n            sender,\n            metadata,\n            invoice_id,\n            randomness: unsafe { random() }\n        }\n    }\n}\n\n// Public payment info (visible to all, needed for payer to complete payment)\n#[derive(Eq, Serialize, Deserialize, Packable)]\npub struct PaymentInfo {\n    pub partial_note: Field,        // Incomplete note commitment for payment\n    pub token_address: AztecAddress,\n    pub amount: u128,\n    pub title_hash: Field,          // Hash of invoice title\n}\n\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "67": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "68": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "75": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "76": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "77": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "78": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "81": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "83": {
      "path": "/Users/mapache/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAARycCAQRFJwICBAA7DgACAAEnAEMEAyYlAAAFNCcCAgAALQgBAycCBAQEAAgBBAEnAwMEAQAiAwIELQoEBS0OAgUAIgUCBS0OAgUAIgUCBS0OAgUrAgAEAAAAAAAAAAACAAAAAAAAAAAtCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4CBwAiBwIHLQ4EBy0IAQQAAAECAS0OAwQtCAEDAAABAgEtDgUDLQgBBgAAAQIBJwIHBAAtDgcGLQgBCAAAAQIBJwIJAQAtDgkIJwIKAAYnAgsEASQCAAkAAAFvIwAAASgtCAEMJwINBAQACAENAScDDAQBACIMAg0tCg0OLQ4KDgAiDgIOLQ4CDgAiDgIOLQ4CDi0ODAQtDgUDLQ4LBi0OCQgjAAAB+y0KBwUjAAABeAwiBUMMJAIADAAABK4jAAABii0LBAUtCwMMLQsIDS0LDA4AIg4CDi0ODgwtCAEOJwIPBAUACAEPAScDDgQBACIMAg8nAhAEBAAiDgIRPw8ADwARLQIFAycABAQEJQAABVotCAUMACoMCw8tDgoPLQ4MBC0ODgMtDgsGLQ4NCCMAAAH7LQsEBS0LAwotCwgMCioMCQ0kAgANAAACHScCDgQAPAYOASQCAAkAAAJfIwAAAionAgwEAi0CBQMnAAQEBCUAAAVaLQgFDQAqDQwOLQ4BDi0ODQQtDgoDLQ4MBi0OCQgjAAAC6y0KBwUjAAACaAwiBUMKJAIACgAABCgjAAACei0LBAUtCwMKLQsIDC0LCg0AIg0CDS0ODQotCAENJwIOBAUACAEOAScDDQQBACIKAg4nAg8EBAAiDQIQPw8ADgAQLQIFAycABAQEJQAABVotCAUKACoKCw4tDgEOLQ4KBC0ODQMtDgsGLQ4MCCMAAALrLQsIBQoqBQkKJAIACgAAAwUnAgwEADwGDAEtCgcBIwAAAw4MIgFDBSQCAAUAAAOiIwAAAyAtCwQBLQsDBS0LBgctCwUKACIKAgotDgoFLQgBCicCDAQFAAgBDAEnAwoEAQAiBQIMJwINBAQAIgoCDj8PAAwADi0OAQQtDgoDLQ4HBicCAQEBLQ4BCAAqCgsDLQsDAQoqAQIDCioDCQIkAgACAAADliUAAAW+JwICAAEwCgACAAEmLQsEBS0LAwctCwYKLQsIDAwqAQoNJAIADQAAA8QjAAAEGgAiBwIOACoOAQ8tCw8NACIFAg8AKg8BEC0LEA4AKg0ODy0CBwMnAAQEBSUAAAVaLQgFDQAiDQIOACoOARAtDg8QLQ4FBC0ODQMtDgoGLQ4MCCMAAAQaACoBCwUtCgUBIwAAAw4tCwQKLQsDDC0LBg0tCwgODCoFDQ8kAgAPAAAESiMAAASgACIMAhAAKhAFES0LEQ8AIgoCEQAqEQUSLQsSEAAqDxARLQIMAycABAQFJQAABVotCAUPACIPAhAAKhAFEi0OERItDgoELQ4PAy0ODQYtDg4IIwAABKAAKgULCi0KCgUjAAACaC0LBAwtCwMNLQsGDi0LCA8MKgUOECQCABAAAATQIwAABSYAIg0CEQAqEQUSLQsSEAAiDAISACoSBRMtCxMRACoQERItAg0DJwAEBAUlAAAFWi0IBRAAIhACEQAqEQUTLQ4SEy0ODAQtDhADLQ4OBi0ODwgjAAAFJgAqBQsMLQoMBSMAAAF4KAAABAR4RQwAAAQDJAAAAwAABVkqAQABBdrF9da0SjJtPAQCASYtAQMGCgAGAgckAAAHAAAFcCMAAAV5LQADBSMAAAW9LQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAABbMtAQoILQQICwAACgIKAAALAgsjAAAFjycBBQQBAgAGAgYmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "tZjRbio5DIbfhWsuEtuJk75KVVW0pUdIiFYcWGlV8e5rJ3YoR5oRmu65qb+Yzo9jx0mYr9Xb9uX863l3eP/4vXp4/Fq9HHf7/e7X8/7jdXPafRzE+7UK+ofz6oHXqxK7Sc3U0E0fxRDM+rh2G9Fs6RbALHeLIlrEJjCbu83mzzZmG7ONSzBLZmu3Fc2WZiGAWe42ik5Wm7qFYJbMlm4RzXK3ZM9R7jbZOJlOqt1m08k2rvL/MaxXqAnqkAyie6J7wD0aTYdioPF0YAMCB/2KKJCCAzkUA01bRIGqH5FC6UCaoQ7ZoAXWIDnIbKJMhwAdigG6B91D7iH3JPdolqKUnTI6FAN2D7NBAQcNTIpHuuY6kEPpkLS+sQpogTskB/lSkEQlzWoDBAc2SJbw1CJUyOhgJUjsHrYSpAIOVoJUgwM5WAlytBJktBJktBJkAgcrQU7BITlYCXJGB0tvZvewe4p7inuqe6qVgAM6WAk4uidaCRjAwUrAGBzIwUrApMkEAe0NQIVsoF3RoRpo6iDJbqJ9AVmBHIpBBIdsANFB0gJFoRpoPB3cQ+4h9yT3JPdk1SGFaqDJ7MAGLdQGGoasqFKjgzyOoJthcHCPJrODTAd1p9TeaaA51LnXFnODYkDgIN+FEmHNlpbaIlRg92i5UcKoWu4O7qmiQ0GB+z/LBh0HZac4fNotnSAMuvqqk7a70VCmoZLGsxq2rnah4sQwKDvpPk6xHRjWDTG2ldlp+HQtEDRiJxg+XZ6E7biJ/gQmJwqDrr7qlGjQ8OURQWYnHso8VMp4tvos24lj5LOEtqN2IpsvoDV9bGdMJxo+rX+bWztpjIYvB5svZI+lnTidmAYNX8FBnlOow1c9AgxxUBrkKhjbs5fLeuW3hOfTcbvVS8K3a4NcJj43x+3htHo4nPf79eqfzf7c/un35+bQ7GlzlE9lgW4Pb2JF8H233ypd1tenw/SjCdCfTnIID4F0qxCnFTIym4JswDwUYkk3EjAtIbcVU5CqDwFMcCOA0wKyZxZTYJnGVQLoRoKmJeTbTIFiHgKA+UYgTQtArNFnAaFOSuS5YlSvBYZFAnWUIqZFk4DiIcjCgEmJOldM8BUlewIvk8h1SJS6SEK6zSXk9jcpEWFuVfmSYMqLFColU6hpWQxyZngQcgRM1zTOFJUo+8okueldO7Ten02ikc20rKY41qZgWSLxP8wjjt1Ojq6yqEM4js2KZ7oU4t/VkF90YypyYV2mwYyuwXW624F+2iRzCvc1yZzCvU0C/OPFNZvOet1zKkync+4wTcFnIj9Z6uRhijNHuvyO8TBkccWrRrwNA+dWaInjHCiYv2UjLbpZME7dLHDmWMdSXAJrmI4C5851eQXhi1z42xWH/0jHTNOj3FpHJPLuJE6K5LkbBkdfYsIJpkRmmyX4LlphYbtlX2GV008bdkZh9ly8axazCnfN4s6z+U+FJxluXnfHm3d4F5U67jYv+60N38+H12+fnv799E/8HeDn8eN1+3Y+blXp+iJQ/jxC4TUGftKfbG0Y11CyDuWXwyOGspYXW08XDeY/",
      "is_unconstrained": true,
      "name": "_mark_paid"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "title_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABEknAgYEBScCBwQAHwoABgAHAEQcAEdHBi0IRAEtCEUCLQhGAy0IRwQtCEgFJQAAAFYlAAAAXCcCAQRJJwICBAA7DgACAAEnAEMEAyYlAAATVicCBgAALQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICS0OBgkAIgkCCS0OBgkAIgkCCS0OBgkrAgAIAAAAAAAAAAACAAAAAAAAAAAtCAEJJwIKBAUACAEKAScDCQQBACIJAgotCgoLLQ4GCwAiCwILLQ4GCwAiCwILLQ4GCwAiCwILLQ4ICy0IAQoAAAECAS0OBwotCAEHAAABAgEtDgkHLQgBCwAAAQIBJwIMBAAtDgwLLQgBDQAAAQIBJwIOAQAtDg4NJwIPAAInAhAEASQCAA4AAAGEIwAAAT0tCAERJwISBAQACAESAScDEQQBACIRAhItChITLQ4PEwAiEwITLQ4GEwAiEwITLQ4GEy0OEQotDgkHLQ4QCy0ODg0jAAACEC0KDAkjAAABjQwiCUMRJAIAEQAAEtAjAAABny0LCgktCwcRLQsNEi0LERMAIhMCEy0OExEtCAETJwIUBAUACAEUAScDEwQBACIRAhQnAhUEBAAiEwIWPw8AFAAWLQIJAycABAQEJQAAE3wtCAURACoREBQtDg8ULQ4RCi0OEwctDhALLQ4SDSMAAAIQLQsKCS0LBw8tCw0RCioRDhIkAgASAAACMicCEwQAPAYTAScCEQQCJAIADgAAAnQjAAACRC0CCQMnAAQEBCUAABN8LQgFEgAqEhETLQ4BEy0OEgotDg8HLQ4RCy0ODg0jAAADAC0KDAkjAAACfQwiCUMPJAIADwAAEkojAAACjy0LCgktCwcPLQsNEi0LDxMAIhMCEy0OEw8tCAETJwIUBAUACAEUAScDEwQBACIPAhQnAhUEBAAiEwIWPw8AFAAWLQIJAycABAQEJQAAE3wtCAUPACoPEBQtDgEULQ4PCi0OEwctDhALLQ4SDSMAAAMALQsNDwoqDw4SJAIAEgAAAxonAhMEADwGEwEtCgwJIwAAAyMMIglDDyQCAA8AABHEIwAAAzUtCwoJLQsHDy0LCxItCw8TACITAhMtDhMPLQgBEycCFAQFAAgBFAEnAxMEAQAiDwIUJwIVBAQAIhMCFj8PABQAFi0OCQotDhMHLQ4SCycCBwEBLQ4HDQAqExAKLQsKCQoqCQYKCioKDgskAgALAAADqyUAABPgMAoAAgAJLQgBAicCCQQEAAgBCQEnAwIEAQAiAgIJLQoJCi0OBgoAIgoCCi0OBgoAIgoCCi0OBgotCAEJJwIKBAUACAEKAScDCQQBACIJAgotCgoLLQ4GCwAiCwILLQ4GCwAiCwILLQ4GCwAiCwILLQ4ICy0IAQoAAAECAS0OAgotCAECAAABAgEtDgkCLQgBCwAAAQIBLQ4MCy0IAQ0AAAECAS0ODg0nAg8AAyQCAA4AAASrIwAABGQtCAESJwITBAQACAETAScDEgQBACISAhMtChMULQ4PFAAiFAIULQ4GFAAiFAIULQ4GFC0OEgotDgkCLQ4QCy0ODg0jAAAFNy0KDAkjAAAEtAwiCUMSJAIAEgAAET4jAAAExi0LCgktCwISLQsNEy0LEhQAIhQCFC0OFBItCAEUJwIVBAUACAEVAScDFAQBACISAhUnAhYEBAAiFAIXPw8AFQAXLQIJAycABAQEJQAAE3wtCAUSACoSEBUtDg8VLQ4SCi0OFAItDhALLQ4TDSMAAAU3LQsKCS0LAg8tCw0SCioSDhMkAgATAAAFWScCFAQAPAYUASQCAA4AAAWWIwAABWYtAgkDJwAEBAQlAAATfC0IBRIAKhIREy0OARMtDhIKLQ4PAi0OEQstDg4NIwAABiItCgwJIwAABZ8MIglDDyQCAA8AABC4IwAABbEtCwoJLQsCDy0LDRItCw8TACITAhMtDhMPLQgBEycCFAQFAAgBFAEnAxMEAQAiDwIUJwIVBAQAIhMCFj8PABQAFi0CCQMnAAQEBCUAABN8LQgFDwAqDxAULQ4BFC0ODwotDhMCLQ4QCy0OEg0jAAAGIi0LDQ8KKg8OEiQCABIAAAY8JwITBAA8BhMBLQoMCSMAAAZFDCIJQw8kAgAPAAAQMiMAAAZXLQsKCS0LAg8tCwsSLQsPEwAiEwITLQ4TDy0IARMnAhQEBQAIARQBJwMTBAEAIg8CFCcCFQQEACITAhY/DwAUABYtDgkKLQ4TAi0OEgstDgcNACoTEAktCwkCCioCBgkKKgkOCiQCAAoAAAbIJQAAE+AwCgADAAItCAECJwIDBAQACAEDAScDAgQBACICAgMtCgMJLQ4GCQAiCQIJLQ4GCQAiCQIJLQ4GCS0IAQMnAgkEBQAIAQkBJwMDBAEAIgMCCS0KCQotDgYKACIKAgotDgYKACIKAgotDgYKACIKAgotDggKLQgBCQAAAQIBLQ4CCS0IAQIAAAECAS0OAwItCAEKAAABAgEtDgwKLQgBCwAAAQIBLQ4OCycCDQAEJAIADgAAB8gjAAAHgS0IAQ8nAhIEBAAIARIBJwMPBAEAIg8CEi0KEhMtDg0TACITAhMtDgYTACITAhMtDgYTLQ4PCS0OAwItDhAKLQ4OCyMAAAhULQoMAyMAAAfRDCIDQw8kAgAPAAAPrCMAAAfjLQsJAy0LAg8tCwsSLQsPEwAiEwITLQ4TDy0IARMnAhQEBQAIARQBJwMTBAEAIg8CFCcCFQQEACITAhY/DwAUABYtAgMDJwAEBAQlAAATfC0IBQ8AKg8QFC0ODRQtDg8JLQ4TAi0OEAotDhILIwAACFQtCwkDLQsCDS0LCw8KKg8OEiQCABIAAAh2JwITBAA8BhMBJAIADgAACLMjAAAIgy0CAwMnAAQEBCUAABN8LQgFDwAqDxESLQ4BEi0ODwktDg0CLQ4RCi0ODgsjAAAJPy0KDAMjAAAIvAwiA0MNJAIADQAADyYjAAAIzi0LCQMtCwINLQsLDy0LDRIAIhICEi0OEg0tCAESJwITBAUACAETAScDEgQBACINAhMnAhQEBAAiEgIVPw8AEwAVLQIDAycABAQEJQAAE3wtCAUNACoNEBMtDgETLQ4NCS0OEgItDhAKLQ4PCyMAAAk/LQsLDQoqDQ4PJAIADwAACVknAhIEADwGEgEtCgwDIwAACWIMIgNDDSQCAA0AAA6gIwAACXQtCwkDLQsCDS0LCg8tCw0SACISAhItDhINLQgBEicCEwQFAAgBEwEnAxIEAQAiDQITJwIUBAQAIhICFT8PABMAFS0OAwktDhICLQ4PCi0OBwsAKhIQAy0LAwIKKgIGAwoqAw4JJAIACQAACeUlAAAT4BwKBAMAMAoAAwACLQgBAicCAwQEAAgBAwEnAwIEAQAiAgIDLQoDBC0OBgQAIgQCBC0OBgQAIgQCBC0OBgQtCAEDJwIEBAUACAEEAScDAwQBACIDAgQtCgQJLQ4GCQAiCQIJLQ4GCQAiCQIJLQ4GCQAiCQIJLQ4ICS0IAQQAAAECAS0OAgQtCAECAAABAgEtDgMCLQgBCAAAAQIBLQ4MCC0IAQkAAAECAS0ODgknAgoABSQCAA4AAArqIwAACqMtCAELJwINBAQACAENAScDCwQBACILAg0tCg0PLQ4KDwAiDwIPLQ4GDwAiDwIPLQ4GDy0OCwQtDgMCLQ4QCC0ODgkjAAALdi0KDAMjAAAK8wwiA0MLJAIACwAADhojAAALBS0LBAMtCwILLQsJDS0LCw8AIg8CDy0ODwstCAEPJwISBAUACAESAScDDwQBACILAhInAhMEBAAiDwIUPw8AEgAULQIDAycABAQEJQAAE3wtCAULACoLEBItDgoSLQ4LBC0ODwItDhAILQ4NCSMAAAt2LQsEAy0LAgotCwkLCioLDg0kAgANAAALmCcCDwQAPAYPASQCAA4AAAvVIwAAC6UtAgMDJwAEBAQlAAATfC0IBQsAKgsRDS0OAQ0tDgsELQ4KAi0OEQgtDg4JIwAADGEtCgwDIwAAC94MIgNDCiQCAAoAAA2UIwAAC/AtCwQDLQsCCi0LCQstCwoNACINAg0tDg0KLQgBDScCDwQFAAgBDwEnAw0EAQAiCgIPJwIRBAQAIg0CEj8PAA8AEi0CAwMnAAQEBCUAABN8LQgFCgAqChAPLQ4BDy0OCgQtDg0CLQ4QCC0OCwkjAAAMYS0LCQMKKgMOCiQCAAoAAAx7JwILBAA8BgsBLQoMASMAAAyEDCIBQwMkAgADAAANDiMAAAyWLQsEAS0LAgMtCwgKLQsDCwAiCwILLQ4LAy0IAQsnAgwEBQAIAQwBJwMLBAEAIgMCDCcCDQQEACILAg8/DwAMAA8tDgEELQ4LAi0OCggtDgcJACoLEAItCwIBCioBBgIKKgIOAyQCAAMAAA0HJQAAE+AwCgAFAAEmLQsEAy0LAgotCwgLLQsJDAwqAQsNJAIADQAADTAjAAANhgAiCgIPACoPAREtCxENACIDAhEAKhEBEi0LEg8AKg0PES0CCgMnAAQEBSUAABN8LQgFDQAiDQIPACoPARItDhESLQ4DBC0ODQItDgsILQ4MCSMAAA2GACoBEAMtCgMBIwAADIQtCwQKLQsCCy0LCA0tCwkPDCoDDREkAgARAAANtiMAAA4MACILAhIAKhIDEy0LExEAIgoCEwAqEwMULQsUEgAqERITLQILAycABAQFJQAAE3wtCAURACIRAhIAKhIDFC0OExQtDgoELQ4RAi0ODQgtDg8JIwAADgwAKgMQCi0KCgMjAAAL3i0LBAstCwINLQsIDy0LCRIMKgMPEyQCABMAAA48IwAADpIAIg0CFAAqFAMVLQsVEwAiCwIVACoVAxYtCxYUACoTFBUtAg0DJwAEBAUlAAATfC0IBRMAIhMCFAAqFAMWLQ4VFi0OCwQtDhMCLQ4PCC0OEgkjAAAOkgAqAxALLQoLAyMAAArzLQsJDS0LAg8tCwoSLQsLEwwqAxIUJAIAFAAADsIjAAAPGAAiDwIVACoVAxYtCxYUACINAhYAKhYDFy0LFxUAKhQVFi0CDwMnAAQEBSUAABN8LQgFFAAiFAIVACoVAxctDhYXLQ4NCS0OFAItDhIKLQ4TCyMAAA8YACoDEA0tCg0DIwAACWItCwkNLQsCDy0LChItCwsTDCoDEhQkAgAUAAAPSCMAAA+eACIPAhUAKhUDFi0LFhQAIg0CFgAqFgMXLQsXFQAqFBUWLQIPAycABAQFJQAAE3wtCAUUACIUAhUAKhUDFy0OFhctDg0JLQ4UAi0OEgotDhMLIwAAD54AKgMQDS0KDQMjAAAIvC0LCQ8tCwISLQsKEy0LCxQMKgMTFSQCABUAAA/OIwAAECQAIhICFgAqFgMXLQsXFQAiDwIXACoXAxgtCxgWACoVFhctAhIDJwAEBAUlAAATfC0IBRUAIhUCFgAqFgMYLQ4XGC0ODwktDhUCLQ4TCi0OFAsjAAAQJAAqAxAPLQoPAyMAAAfRLQsKDy0LAhItCwsTLQsNFAwqCRMVJAIAFQAAEFQjAAAQqgAiEgIWACoWCRctCxcVACIPAhcAKhcJGC0LGBYAKhUWFy0CEgMnAAQEBSUAABN8LQgFFQAiFQIWACoWCRgtDhcYLQ4PCi0OFQItDhMLLQ4UDSMAABCqACoJEA8tCg8JIwAABkUtCwoPLQsCEi0LCxMtCw0UDCoJExUkAgAVAAAQ2iMAABEwACISAhYAKhYJFy0LFxUAIg8CFwAqFwkYLQsYFgAqFRYXLQISAycABAQFJQAAE3wtCAUVACIVAhYAKhYJGC0OFxgtDg8KLQ4VAi0OEwstDhQNIwAAETAAKgkQDy0KDwkjAAAFny0LChItCwITLQsLFC0LDRUMKgkUFiQCABYAABFgIwAAEbYAIhMCFwAqFwkYLQsYFgAiEgIYACoYCRktCxkXACoWFxgtAhMDJwAEBAUlAAATfC0IBRYAIhYCFwAqFwkZLQ4YGS0OEgotDhYCLQ4UCy0OFQ0jAAARtgAqCRASLQoSCSMAAAS0LQsKDy0LBxItCwsTLQsNFAwqCRMVJAIAFQAAEeYjAAASPAAiEgIWACoWCRctCxcVACIPAhcAKhcJGC0LGBYAKhUWFy0CEgMnAAQEBSUAABN8LQgFFQAiFQIWACoWCRgtDhcYLQ4PCi0OFQctDhMLLQ4UDSMAABI8ACoJEA8tCg8JIwAAAyMtCwoPLQsHEi0LCxMtCw0UDCoJExUkAgAVAAASbCMAABLCACISAhYAKhYJFy0LFxUAIg8CFwAqFwkYLQsYFgAqFRYXLQISAycABAQFJQAAE3wtCAUVACIVAhYAKhYJGC0OFxgtDg8KLQ4VBy0OEwstDhQNIwAAEsIAKgkQDy0KDwkjAAACfS0LChEtCwcSLQsLEy0LDRQMKgkTFSQCABUAABLyIwAAE0gAIhICFgAqFgkXLQsXFQAiEQIXACoXCRgtCxgWACoVFhctAhIDJwAEBAUlAAATfC0IBRUAIhUCFgAqFgkYLQ4XGC0OEQotDhUHLQ4TCy0OFA0jAAATSAAqCRARLQoRCSMAAAGNKAAABAR4SQwAAAQDJAAAAwAAE3sqAQABBdrF9da0SjJtPAQCASYtAQMGCgAGAgckAAAHAAATkiMAABObLQADBSMAABPfLQABBQAAAQQBAAADBAktAAMKLQAFCwoACgkMJAAADAAAE9UtAQoILQQICwAACgIKAAALAgsjAAATsScBBQQBAgAGAgYmKgEAAQW6uyHXgjMYZDwEAgEm",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "_store_payment_info"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "title_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "metadata",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "create_invoice",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "10835759466430049078": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13049348927268151465": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "18160147074902047180": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "18195344559583857168": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "5955197699778714817": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8754864405609694316": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "owner",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "sender",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "metadata",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "invoice_id",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "randomness",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "types::invoice_note::InvoiceNote"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3JkkQ5b2b5LrnuhXMCCb1KL8q6ugaTmaxkVsNKL19xAYLn2yjPpz+Th3cA4oY7wv0//vkv//U//5///p/+9X/8t3//X//8y//7H//85//5r//2b//63//Tv/37/////e9//ff/8ff//Y9/ft//meuffxn/zz/T/vkX+/vH/udfzt8/Tv7D4x/rl/9o+Y+e/xj5j5n/WPkPy3/kKitXWbmK5SqWq1iuYrmK5SqWq1iuYrmK5SqWq+xcZecqO1fZucrOVXausnOVnavsXGXnKidXObnKyVVOrnJylZOrnFzl5ConVzm5iucqnqt4ruK5iucqnqt4ruK5iucqnqu03+/+s91/9vvPcf857z/X/afdf+77z3P/eddrd71212t3vXbXa3e9dtdrd71212t3vXbX63e9ftfrd71+1+t/67XfB6vACnbB35ptfOAXxq+gFfyt2+yDv4X791+NWbAKrGAXnIK/lfv8g/kraAW94Ft5fTALVsG35+9wvhJIOAV/K4/2B18hJLSCXjAKZsEqsIJdcApqZauVrVb+CmR8p+UrkYRZsAqsYBecAr/wFUxCK6iVd628a+VdK+9aedfKu1betfKplU+tfGrlUyufWvnUyqdWPrXyV1TjuwRfWQV8hZXQCnrBKJgFq8AKdkGt7Hfl/vsVtIJeMApmwSqwgl1wCmrlViu3WrnVyq1WbrVyq5Vbrdxq5VYrt1q518q9Vu61cq+Ve63ca+VeK/daudfKvVYetfKolUetPGrlUSuPWnnUyqNWHrXyqJVnrTxr5Vkrz1p51sqzVp618qyVZ608a+VVK69aedXKq1aOGjwfrAIr2AWnwC9EDQa0gl4wCmplq5WtVv5qcLYPToFf+Gpw2getoBeMglmwCqxgF5wCv3Bq5VMrn1r53I7UzyxYBVawC07B7UjdfwWtoBfUyl4re6381eD0D3bBKfCE8dVgQivoBaNgFqwCK9gFp6BW/mpw/T5oBb1gFMyCVWAFu+AU+IVeK/daudfKXw2u/cEsWAVWsAtOgV/4ajChFfSCWnnUyqNWHrXyqJVHrTxq5Vkrz1p51sqzVp618qyVZ608a+VZK89aedXKq1ZetfKqlVetvGrlVSuvWnnVyqtWtlrZamWrla1WtlrZamWrla1WtlrZauVdK+9aedfKu1betfKulXetvGvlXSvvWvnUyqdWPrXyqZVPrXxq5VMrn1r51MqnVvZa2Wtlr5W9VvZa2Wtlr5W9VvZa2e/K8/craAW9YBTMglVgBbvgFNTKrVZutXKrlVut3GrlViu3WrnVyq1WbrVyr5V7rdxr5arBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGpxVg7NqcFYNzqrBWTU4qwZn1eCsGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqrBVTW4qgZX1eCqGlxVg6tqcFUNrqpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqQasatKpBqxq0qkGrGrSqwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9XgrhrcVYO7anBXDe6qwV01uKsGd9Xgrho8VYOnavBUDZ6qwVM1eKoGT9XgqRo8VYOnavBUDZ6qwVM1eKoGT9XgqRo8VYOnavBUDZ6qwVM1eKoGT9XgqRo8VYOnavBUDZ6qwVM1eKoGT9XgqRo8VYOnavBUDZ6qwVM1eKoGz1eD9vvAL3w1mPC3ss0PesEomAWrwAp2wSnwC18NJtTKq1ZetfKqlVetvGrlVSuvWnnVylYrW61stbLVylYrW61stbLVylYrW628a+VdK+9aedfKu1betfKulXetvGvlXSufWvnUyqdWPrXyqZVPrXxq5VMrn1r51MpeK3ut7LWy18peK3ut7LWy18peK/td2X+/glbQC0bBLFgFVrALTkGt3GrlViu3WrnVyq1WbrVyq5Vbrdxq5VYr91q518q9Vu61cq+Ve63ca+VeK/daudfKo1YetfKolUetPGrlUSuPWnnUyqNWHrXyrJWrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwa9atCrBr1q0KsGvWrQqwb/3ov/PWqP+qPxaD5aj+zRfnQePUd7jvYc7Tnac7TnaM/RnqM9R3uO9hz9Ofpz9Ofoz9Gfoz9Hf47+HP05+nOM5xjPMZ5jPMd4jvEc4znGc4znGM8xn2M+x3yO+RzzOeZzzOeYzzGfYz7Heo71HOs51nOs51jPsZ5jPcd6jvUc9hz2HPYc9hz2HPYc9hz2HPYc9hz7OfZz7OfYz7GfYz/Hfo79HPs59nOc5zjPcZ7jPMd5jvMc5znOc5znOM/hz+HP4c/hz+HP4c/hz+HP4c/x6ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL06b6/O26vz9uq8vTpvr87bq/P26ry9Om+vztur8/bqvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/uq8vzrvr877q/P+6ry/Ou+vzvur8/7qvL8676/O+6vz/up8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzmMUyU7QemSP/hw7h4zPIy/66vxSe9QfjUfz0Xpkj57DnsOeYz/Hfo79HPs59nPs59jPsZ9jP8d+jvMc5znOc5znOM9xnuM8x3mO8xznOfw5/Dn8Ofw5/Dn8Ofw5/Dn8ObwcMbh0qT3qj8aj+Wg9skf70Xn0HO052nO052jP0Z6jPUd7jvYc7Tnac/Tn6M/Rn6M/R3+O/hz9Ofpz9OfozzGeYzzHeI7xHOM5xnOM5xjPMZ5jPMd8jvkc8znmc8znmM8xn2M+x3yO+RzrOdZzrOdYz7GeYz3Heo5X5/PV+Xx1Pl+dz1fnMfa0e9B4NB+tR/ZoPzqPvCjqPKk9eo79HPs59nPs59jPsZ9jP8d5jvMc5znOc5znOM9xnuM8x3mO8xz+HP4c/hz+HP4c/hz+HP4c/hxejhiOutQe9Ufj0Xy0Htmj/eg8eo72HO052nO052jP0Z6jPUd7jvYc7Tn6c/Tn6M/Rn6M/R3+O/hz9Ofpz9OcYzzGeYzzHeI7xHOM5xnOM5xjPMZ5jPsd8jvkc8znmc8znmM8xn2M+x3yO9RzrOdZzrOdYz7GeYz3Heo71HOs57DnsOV6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enUeY1d7BbVH/dF4NB+tR/ZoPzqP/FIMYF1qj/qj8Wg+Wo/s0X50Hj1He472HO052nO054g/jcs/x7JH+9F55EXxR3JJ7VF/NB7NR8/x1fnpQfvReeRFX51fao/6o/FoPlqPnmM8x3iO8RxfnZ8Z1B71R+PRfLQe2aP96DzyovUc6znWc6znWM+xnmM9x3qO9RzrOew57DnsOew57DnsOew57DnsOew59nPs59jPsZ9jP0f8aWrcYfHXqUn70eewIC+Kv1RN+hwnqD8aj/4cHnfTV+eX7NGfw3fQeeRFX517rPLV+aX+aHx/w/kLnOACDdzgAb0wZr0KG9jBAU5wgWFrgRs8YNi+0x3zX4UN7OAAJ7hAAzd4QGwdW8fWw7YCBzjBBRq4wQP6w/j72YsNxDawDWwD28A2sA1sA9vENrFNbBPbxDaxTWwT28Q2sS1sC9vCtrAtbAvbwrawLWwLm2EzbIbNsBk2w2bYDJthM2wb28a2sW1sG9vGtrFtbBvbxnawHWwH28F2sB1sB9vBdrAdbI7NsTk2x+bYHJtjc2yOzZ/t/H5gAzs4wAku0MANHhBbw9awNWwNW8PWsDVsDVvD1rBlLzmBDezgACe4QAM3eEB/OLANbAPbwDawDWwD28A2sA1sE9vENrFNbBPbxDaxTWwT28S2sC1sC9vCtrAtbAvbwrawLWyGzbAZNsNm2AybYTNshs2wbWwb28a2sW1sG9vGtrFtbBvbwXawHWwH28F2sB1sB9vBdrA5Nsfm2BybY3Nsjs2xOTZ/Nv/9wAZ2cIATXKCBGzwgtoatYWvYGraGrWFr2Bq2hq1ho5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklMSnYWgs8oD+MXnKxgR0c4AQXaCA2x+Zl6zFC2FoPbGAHBzjBBRq4wQP6w4atYWvYGraGrWFr2Bq2hq1h69g6to6tY+vYOraOrWPr2Dq2gW1gG9gGtoFtYBvYBraBbWCb2Ca2iW1im9gmtoltYpvYJraFbWFb2Ba2hW1hW9gWtoUtekmbH0YvudjAsO3AAU5wgQZu8ID+MHrJxQZi29g2to1tY9vYNraN7WA72A62g+1gO9gOtoPtYDvYHJtjc2yOzbE5Nsfm2BybP1v7/cAGdnCAE1yggRs8ILaGrWFr2Bq2hq1ha9gatoatYevYOraOrWPr2Dq2jq1j69g6toFtYBvYBraBbWAb2Aa2gW1gm9gmtoltYpvYJraJbWKb2Ca2hW1hW9gWtoVtYVvYFraFbWEzbIaNXtLoJY1e0ugljV7S6CWNXtLoJY1e0ugljV7S6CWNXtLoJY1e0ugljV7S6CWNXtLoJY1e0ugljV7S6CWNXtLoJY1e0ugljV7S6CWNXtLoJY1e0ugljV7S6CWNXtLoJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWdXtLpJZ1e0uklnV7S6SWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeEpOY7ft80h6jmIX+MHrJxQZ2cIATXKCB2Aa2gS16SW+BDezgACe4QAM3eEB/uLAtbAvbwrawLWwL28K2sC1shs2wGTbDZtgMm2EzbIbNsG1sG9vGtrFtbBvbxraxbWwb28F2sB1sB9vBdrAdbAfbwXawOTbH5tgcm2NzbI7NsTk2f7YY6SxsYAcHOMEFGrjBA2Jr2Bq2hq1ha9iil/QRaOAGw2aB/jB6ycUGdnCAE1yggRvE1rENbAPbwDawDWwD28A2sA1sA9vENrFNbBPbxDaxTWwT28Q2sS1sC9vCtrAtbAvbwrawLWwLm2EzbIbNsBk2w2bYDJthM2wb28a2sW1sG9vGtrFtbBvbxnawHWwH28F2sB1sB9vBdrAdbI7NsTk2x+bYHJtjc2yOzZ9t/X5gAzs4wAku0MANHhBbw9awNWwNW8PWsDVsDRu9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UsWvWTRSxa9ZNFLFr1k0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL1k00s2vWTTSza9ZNNLNr1k00s2vWTTSza9ZNNLcu61e2AHBzjBBRq4wQP6w+wlidg6to4tesn3rR89514vGrjBA/rD/N6YxAZ2cIDYBraBbWAb2Aa2iW1im9iil4weOMEFGrjBA/rD6CUXG9hBbAvbwrawLWwL28Jm2AybYTNshs2wGTbDZtgM28a2sW1sG9vGtrFtbBvbxraxHWwH28F2sB1sB9vBdrAdbAebY3Nsjs2xOTbH5tgcm2PzZ8u514sN7OAAJ7hAAzd4QGwNW8PWsDVsDVvD1rA1bA1bw9axdWwdW8fWsXVsHVvH1rF1bAPbwDawDWwD28A2sA1sA9vANrFNbBMbveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EsOveTQSw69xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF6Sc69jBnZwgBNcoIEbPKA/zF6SiG1gG9gGtoFtYBvYBraBbWKb2Ca2iW1im9gmtoltYpvYFraFbWFb2Ba2hW1hW9gWtoXNsBk2w2bYDJthM2yGzbAZto1tY9vYNraNbWPb2Da2jW1jO9gOtuwlFjjACYbtBBq4wQP6w+wliQ3s4AAniM2xOTbH5mUbOfd6sYEdHOAEF2jgBg+IrWFr2Bq2hq1ha9gatoatYWvYOraOrWPr2Dq2jq1j69g6to5tYBvYBraBbWAb2Aa2gW1gG9gmtoltYpvYJraJbWKb2Ca2iW1hW9gWtoVtYVvYFraFbWFb2AybYTNshs2wGTbDZtgMm2Hb2Da2jW1j29g2to1tY9vYNraD7WA72A62g+1gO9gOtoPtYHNsjs2xOTbH5tgcm2NzbPSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kk4v6fSSTi/p9JJOL+n0kpx7/b7Zd+Tc60UDP9scgQf0h9FLLjawgwOc4AINxGbYspfsD7OXJDawgwOc4AIN3OABsR1sB9vBdrAdbAfbwXawHWwHm2NzbI7NsTk2x+bYHJtj82fLudeLDezgACe4QAM3eEBsDVvD1rA1bA1bw9awNWwNW8PWsXVs0UtWDxzgBD/bGoEGbjDuyRnoD6OXXGxgBwc4wQUauEFsA9vENrFNbBPbxDaxTWwT28Q2sS1sC9vCtrAtbAvbwrawLWwLm2EzbIbNsBk2w2bYDJthM2wb28a2sW1sG9vGtrFtbBvbxnawHWwH28F2sB1sB9vBdrAdbI7NsTk2x+bYHJtjc2yOzZ8t514vNrCDA5zgAg3c4AGxNWwNW8PWsDVsDVvD1rA1bNlLvh+AOfd6sYEdHOAEF2jgBg+IbWAb2Aa2gW1gG9gGtoFtYBvYJraJbWKb2Ca2iW1im9gmtoltYVvYFraFbWFb2Ba2hW1hW9gMm2EzbIbNsBk2w2bYDJth29g2to1tY9vYNraNbWPb2Da2g+1gO9gOtoPtYDvYDraD7WBzbI7NsTk2x+bYHJtjc2z+bDn3erGBHRzgBBdo4AYPiC16yTqBDezgZ7P8dye4wM9mI3CDB/SH0UsuNrCDA5zgArF1bB1bxzawDWwD28A2sA1sA9vANrANbBPbxDaxTWwT28Q2sU1sE9vEtrAtbAvbwrawLWwL28K2sC1shs2wGTbDZtgMm2EzbIbNsG1sG9vGtrFtbBvbxraxbWwb28F2sB1sB9vBdrAdbAfbwXawOTbH5tgcm2NzbI7NsTk2f7ace73YwA4OcIILNHCDB8TWsDVsDVvD1rA1bPQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CVGLzF6idFLjF5i9BKjlxi9xOglRi8xeonRS4xeYvQSo5cYvcToJUYvMXqJ0UuMXmL0EqOXGL3E6CWbXrLpJZtesuklm16y6SWbXrLpJZtesuklm16y6SWbXrLpJZtesuklm16y6SU59/p9W8jIudfE7CWJDezgACe4QAM3iK1jG9gGtugl2wIHOEGOjV6y6SU597pzMX8YveRiAzs4wAku0MANYpvYFraFbWGLXnJiv9FLLi7ws32fsTxy7vXiAf1h9JKLDezgACe4QGyGzbAZtuglJ65F9JKLHRzgBBdo4AYP6A8PtoPtYDvYDraD7WDLXtIDD+gPs5ckNrCDA5zgAg3E5tj82XLu9WIDOzjACS7QwA0eEFvD1rA1bA1bw9awNWwNW8PWsHVsHVvH1rF1bB1bx9axdWwd28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1sE9vENrFNbBPbwrawLWwL28K2sC1sC9vCtrAZNsNm2AybYTNshs2wGTbDtrFtbBvbxraxbWwb28a2sW1sB9vBdrAdbAfbwXaw0UsOveTQSw695NBLDr3k0EsOveTQSw695NBLDr3k0EucXuL0EqeXOL3E6SVOL3F6idNLcu7VR6A/jF5y8bP5DOzgAP9s/fuo+xFzr4UG7g9zsQP6w6+XFDawgwOc4AINxNaxdWwD28A2sA1sA9vA9vWSv7fNAzd4wM/2fbbmiLnXwgZ+tmaBA5zgZ/s+kGXE3GvhBg/oD9cPbGAHBzhBbAvbwrawfb3k7535D79eUtjAz9ZX4AAn+Nm+v64aMfdauMED+sP9AxvYwQFOENvGtrFtbBvbwXawHWwH28F2sB1sB9vBdrA5Nsfm2BybY3Nsjs2xOTYv24y518IGdnCAE1yggRs8ILaGrWFr2Bq2hq1ha9gatoatYevYOraOrWPr2Dq2jq1j69g6toFtYBvYBraBbWAb2Aa2gW1gm9gmtoltYpvYJraJbWKb2Ca2hW1hW9gWtoVtYVvYFraFbWEzbIbNsBk2w2bYDJthM2yGbWPb2Da2jW1j29g2to1tY9vYDraD7WA72A62g+1gO9gOtoPNsTk2x+bYHJtjc2yOzbHRSxq9pNFLGr2k0UsavaTRSxq9pNFLGr2k0UsavaTRSxq9pNFLGr2k0UsavaTRSxq9pNFLGr2k0UsavaTRSxq9JOZe+/dnEDPmXgs3+Nm+wawZc68Xo5dc/GzfUNSMudfCAX627z3sGXOvhQZ+trkDD+gPo5d88zAz5l4LO/jZVtiil1xc4GezX+AGD/jZvnfPZsy9Fjbws1kccfSSixP8bBYnNXrJxQ1+th0HFL0kMXrJxc+2Y7HoJRcHiC16yUUDsUUvuegPo5ecOOvRSy52cLztRC+5uEB724lecvGAn83jnEUvudjAz+Zx3aKXXJzgZ/OwRS+5uME/2/jFfr9ecvHrJYXtwxXYwQHOt53oJRcN3G870UsuemHMvaYt5l4LO/hsMfdauED78ARu8ID+sP3ABnZwgBNcILaGrWFr2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoHt6yWjjUB/+PWSws/W4mJ9vaRwgBNcoIEbPKA/XD8Q28K2sC1sK2w70MANfrYeN+LXSy5+vaTws/U4zK+XFA7ws8XPgJh7LTTws41f4AH94ddLRvyQiLnXwg5+thH7/XpJ4QI/2wjb3uAB/eH5gQ3s4AAnuEBsB1v0khn7jV6SGL3k4meLn0Mx91o4wM82Y7GvlxQa+NlWLnZAL4y51783wAMb2MHP9r2jMGPutXCBn+37PvYZc6+FB/xs3xcvz5h7LWzgZ9stcIDzYb4JEPQZvi8xnTEd+fdmQ2ADOzjACS7QwA0e0B9ubBvbxraxbWwb28a2sW1sG9vBdrAdbAfbwXawHWwH28F2sDk2x+bYHJtjc2yOzbE5Nn+2mI4sbGAHBzjBBRq4wQNia9gatoYt77gdOMEFGrjBA3627wtfZ0xHFjawg5/t+0LWGdORhZ/te79rxnRk4QYP6A/jp9fFBobNAgc4wbCdQAM3+NniWSSmIy/GT6+LDezgAD+br8AFGrjBsMXO4qdXYvz0uvhn+7s/Ajs4wPlhLPb99Co0MM7Z1xBjDvLvBgqMFeKIv/4wW2z96w+FBm7wgP7w6w9/d01gAzs4wLDFHvYCwxab3Bs8oD88P7CBny1+xMbEY+EEF/jZelTA1x8KP1uPTX794eLXHwobGLYQ+wAnuEADN/jZRmzn6w+JMfFY2MDP9v1R/YyJx8IJhm0HGrgftg7GCivw+3fjt8mYV/y7VwIP6A+/6p7xkznmFQs7OMAJLtDADR7QHw5sA9vANrCNsMV5GAs0cIMH9IfzBzawgwPENrHNWDfO5PSH6wc2sIMDnOACDdwgthW2746KycTCBnbwW2y1wO8/i9/hY8SwsIEdHOAEv02uOPgo3osbPKA/jOK92MAOhi1uuSjeiws0cIMHDFvcGlG8FxvYwVBEXUTFXjQwFHGqo2IvemHMFRa+qxkThIULNHCDB3xXMyYICxvYwXc1YxQwL0uMAhY2sIMDnOC7mjEKWLjBA76rGaOAhQ3s4LuaMQpYuEADN3jAdzVjFLCwgR38FPG6Usz/zXgFKeb/Cjd4HkZtxvN8zPTNeHKPmb5CAzd4QH8YVWixnajCix0c4AQXaOAGwxYXK4o3MYr3YgPDtgMH+Nnil46Y6Ss0cIOfLZ4RY6bvYhTvxQZ2cIATXKCBG8R2sDk2x+bY4ifvjrsk6vjiAsMWpy/q+OIBw/adnZjpK2xg2E7gACcYNg80cIOf7fwC/WFU98XPFg/IMdNXOMDPFs/KMdNXaGDYRuAB/WE0hYsN7OAAJ7hAA7F1bB3bwDawDWwD28A2sA1sA9vANrBNbNEU4uXUmOkrHOAEF2jgBg/oD+Mn+kVsC9vCtrAtbAvbwrawLWyGzbAZNsNm2AybYTNshs2wbWwb28a2sW1sG9vGtrFtbBvbwXawHWwH28F2sB1sB9vBdrA5Nsfm2BybY3Nsjs2xOTZ/tpjpK2xgBwc4wQUauMEDYmvYGraGrWFr2Bq2hq1ha9gato6tY+vYOraOrWOLXhK/jcdMX+EB/WH0kosN7OAAJ7hAbAPbwDawTWwT28Q2sU1sE9vENrFNbBPbwrawLWwL28K2sC1sC9vCtrAZNsNm2AybYTNshs2wGTbDtrFtbBvbxraxbWwb28a2sW1sB9vBdrAdbAfbwXawHWwH28Hm2BybY3Nsjs2xOTbH5tj82fz3AxvYwQFOcIEGbvCA2Bq2hq1ha9gatoatYWvYGraGrWPr2Dq2jq1j69joJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklnr1kBXZwgBNcoIFh24EH9Ivrl73EAxvYwcW/+63gv0B/GP3hYgM7OMAJLtDADWJr2Dq2jq1j69g6to6tY+vYOraObWAb2Aa2gW1gG9gGtoFtYBvYJraJbWKb2Ca2iW1im9gmtoltYVvYFraFbWFb2Ba2hW1hW9gMm2EzbIbNsBk2w2bYDJth29g2to1tY9vYNraNbWPb2Da2g+1gO9gOtoPtYDvYDraD7WBzbI7NsTk2x+bYHJtjc2z+bDGnV9jADg5wggs0cIMHxEYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSRi9p9JJGL2n0kkYvafSSlr2kBW7wgF7Ys5ckDjBW6IGxwgw8oD/M/rADG9jBAU5wgQZu8ID+sGPr2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGtoFtYpvYJraJbWKb2Ca2iW1im9gWtoVtYVvYFraFbWFb2Ba2hc2wGTbDZtgMm2EzbIbNsBm2jW1j29g2to1tY9vYNraNbWM72A62g+1gO9gOtoPtYDvYDjbH5tgcm2NzbI7NsTk2x+bPNn4/sIEdHOAEF2jgBg+IjV4y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMuglg14y6CWDXjLoJYNeMrKXWKCBGzygP8xekhg2D+zgACe4QAM3eEB/mL0kEZtjc2yOzbE5Nsfm2PzZ5u8HNrCDA5zgAsN2Ajd4QH+YvSSxgX/rru9vmVdMSv69jhF4QH/49YfCWGEFdnCAE1yggWEbgQf0h18nWN/fRqyYfly/+M++mi/c4AFjhe+GienHwgZ2cIATDNsONHCDYYvTN/3h+oFhiyu0OjjACS7QwG/dFpflq+PV4pR8dVw4wQUauMED+sOvjgsbiG1j29g2to1tY9vYNraD7WA72A62g+1gO9gOtoPtYHNsjs2xOTbH5tgcm2NzbP5sMf1Y2MAODnCCCzRwgwfE1rA1bA1bw9awNWwNW8PWsDVsHVvH1rF1bB1bx9axdWwdW8c2sA1sA9vANrANbAPbwDawDWwT28Q2sU1sE9vENrFNbBPbxLawLWwL28K2sC1sC9vCtrAtbIbNsNFLFr1k0UsWvWTRS1b2kh54QH+YvSSxgR0cYNhm4ALDtgI3eB5m10iMFSxwgbHCCdzgAb/99q+nxoBlYQM7OMAJLtDADZ5Cy+pegQZuMP7dHugPo7ovxs5GYAcHOMEFGrjBA/rDqO6L2Dq2jq1j69g6to6tY+vYBrao7m9+fcXYZeGoq2ljggs0cIMH9IdZ3YkN7CC2iW1im9gmtoltYlvYFraFbWFb2Ba2hW1hW9gWNsNm2AybYTNshs2wGTbDZtg2to1tY9vYNraNLes46mK/JxvLZ4LEuB+iLuKZ4Jv5XzGXWTjBBRq4wQP6w6zuEzjACX7rjthOVPfFDR7QC2MCs7CBHRzgBBdo4AYPiK1ha9gatoatYWvYGraGrWGL/vB9tvSKCczCBnZwgBNcoIEbPCC2gW1gG9gGtoFtYBvYBraBbWCb2Ca2iS2aQtyTMXZZaGAoRuAB/WE0he9PXVaMXRZ2cIATXOC7wWPssvCA7waPscvCBnZwgBNcIDbDZtgM28a2sW1sG9vGtrFtbBvbxraxRasYcdajVVzs4AAnuEADN3hAf+jYHJtjc2yOzbE5Nsfm2PzZzu8HNrCDA5zgAg3c4AGxNWwNW8PWsDVsDVs2kB24wQOG7eupJxtIYgM7OMAJLtDADR4Q28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1s2TU88ID+MFpF/EiKqcrC1/BiaPLvl5fAA/rD6AQXvz3M+M+i5uNFkhiPLDRwg+8FlZiJLIzFeuAEF2hgbOdrgzHnWNjADg5wggs0cIMHxObYHJtjc2yOzbE5Nsfm2PzZYs6xsIEdHOAEF2jgBg+IrWGL4v3+xnHFnGNh2CxwggsM2w7c4AH9YRTvxQZ2cIATXCC2jq1j69gGtoFtYBvYBraBbWAb2Aa2gW1im9gmtoltYpvYJraJbWKb2Ba2hW1hW9gWtoVtYVvYFraFzbAZNsNm2AybYTNshs2wGbaNbWPb2Da2jW1j29g2to1tY8teEvf6oQIOFZC9JHGCCwzbCdxg2DzQH2YvSfxs6xfYwQFOcIEGbvCzfX8EuWLOMdBizrGwgR0cYHTwxBpksDvyGNh+YAM7GIv1QAM3eMDY5PwwmsLFBsYmV+AAJ7hAAzd4QH8YTeFiA7ENbAPbwDawDWwD28A2sU1sE9vENrFNbBPbxDaxTWwL28K2sC1s0RS+vxa1O9wYl2UZuMED+sN8kzCxgR0c4ASxGTbDZtgM28a2sW1sG9vGtrFtbBvbxraxHWwH28F2sB1sB9vBdrAdbAebY3Nsjs2xOTbH5tgcm2PzZ7vDjYkN7OAAJ7hAAzd4QGwNW8PWsDVsDVvD1rA1bA1bw9axdWwdW8fWsXVsHVvH1lHk30nswAFOMIr3BBr4Fe/3J9kWs4uF/jBaxfd32Bazi4UdHOAEF/jZLDYZreLiAWMC3j9cP7CBHRzgBGPd8WE8E3x/6m0xj7i+v862mEcsHOAEF2jgBg/oD+OZ4GLYVmDY4qzHM8HFCS4wbHEt4png4gHDFocZzwQXG4jtYDvYDraD7WA72A42x+bY4pkg/914Jrg4wQVic2yOzZ8t5hELG/jZvs/ZsphSLJzgO7aYXSzc4AH9Yfx+8f1VssXsYmHYZuAAJ/jZvr9dt5hdLNzgAf1hPEpcbGAHBzhBbB1bx9axdWwD28A2sA1sA9vANrANbAPbwDaxTWwT28Q2sU1sE9vENrFNbAvbwrawLWwL28K2sC1sC9vCZtgMm2EzbIbNsBk2w2bYDNvGtrFtbBvbxraxbWwb28YWvSTv9UMFHCogesnFAU4wbD0wKiv/v14l3bNrJDawgwOc4ALtlX92jcQDvq4xfq/bj+waiR0c4AQXaOAGz8N4PIjDzHnEiwOcYJwdC/weBO4K/jAeBC7GWd+BHRxgnPUTuPjPDNwgto5tYIvJw4sdHOAEsQ0U+ekuLbCBHRxgbD2uUIwQxi9XOUJ40R9GSX8ftWExQljYwe+UnFg3fuTf/2yBBmJb2Ba2+O3gYgM7OEBshiI/mim2szklm1OyOSVZsXEeNitsNrnZZNRmHvHhlBxOSdRmnofDJg+bPJySg+1gO9gOp8Q5Jc4pcU6JY3MUUZAn0Qtj1K+wgR2Mq2mBE1yggRs84Gf7/uDBYtSvsIEd/GzxMkAOAF5c4GeLJ+gcC7x4wLB9FZBjgd9Qn8VY4PrmPS3GAgsHOMEFGvi3rv1ik1+ZFjawgwOcD2fgCFygfRj7naGIc7Z+YAM7OMD50OL/G/u1CS7QwA0e0B/uH9jADmLb2Da2jW1j29hOrHsCYwUP/FZocbm/uijc4LdCi8v91cXFry4KG9jBAca6cQE8VvguQMzL2ffBxBbzcoUdjBUscIILNHCDBwzbd8QxL1cYNg/s4AC/db/5HYsZuL+n1Q+/G7wwVliB3wrfpI7FDFzhBBcY647ADR4wbHF24ra/2EBsA9vANrANA3ddi5iBK3xXM2bgChvYwVWXMOba7iWMGsqLtbiai6sZNZTXYnE1F1dzcTUXV3NxNdd5121xNe33LpZxNY2rGVWYlzDqLa+bcTWj3vISRr3lidqc38353ZzfqLe8WJurubmaUW95sTZX83A1D7aD7WA72M67mvHxfH8PxIETXGBs5wRu8ID+MIrhYgM7OMAJfrYR24kSubjBA/rDKJyLn23EfqNwLg5wgmHbgQZuMGyxsyicxCici2HzwA4OcIKf7Xuz1GKQzL43Sy0GyS5GiVxs4Lfu91acxSCZfR+oaTFIZt/7DBaDZIUGbjBsccRRTolRThcbGLY4tqihFfuNGopHqpgesxXbiRpa+Z8d0B9GDV1sYAcHGLY461FZFz9bvIwV02OFB/SHUW8XG/jZ4mWhmB4rnOACwxbbiXq7eMCwxc6i3i42MGxxuaPe4kWSmCkrXKCBGzwP46devPARM2WFozBmvyx+WYnZr8KwncAFGrjBA/rDKN54bI7ZL4vn35j9KhzgBBdo4LduPDbHPJfFY2jMc9n3sRwW81yFC4wV4jCjIC8e0B9GQV5sYNgscIBhixMVBXnRwFg3zkOUXrzCGZ+SVxgrjMD1TlSU3sUNHvBbN56KY1yrsIH9XYD4SXaRq7mwLWwL28IWVZgY1RIP0zFWdTGq5WLUZiiiWi4OcIILNPDbg8cpiWq56A+jWi42sIMD/NaNJ/4YoCo8oD+MZ8SLDezgACe4QGyOzbH5s8UAVWEDOzjACS7QwA0eEFvD1rA1bA1bw9awNWwNW8PWsHVsHVvH1rF1bB1bx9axdWwd28A2sA1sA9vANrANbAPbwDawTWwT28Q2sU1sE9vENrFNbBPbwrawLWwL28K2sC1sC9vCtrAZNsNm2AybYTNshs2wGTbDtrFtbBvbxraxbWwb28a2sW1sB9vBdrAdbAfbwUYvOfSSQy859JJDLzn0kkMvOfSSQy859JJDLzn0kkMvOfQSz15igQ3s4KyO6NlAEg3c4AFf0/X2AxvYwQFia9gatoatYWvYOraOrWPr2Dq2jq1j69g6to5tYBvYBraBbWAb2Aa2gW1gG9gmtoltYpvYJraJbWKb2Ca2iW1hW9gWtoVtYVvYFraFbWFb2AybYTNshs2wGTbDZtgMm2Hb2Da2jW1j29g2to2Nxw7nscN57HAeO5zHDuexw3ns8IPtYDvYDraD7WBzbI7NsTk2x+bYHJtjc2xetv37/cAGdnCAE1yggRs8ILbsJR7YwA7+2fY3J7bjg+0KF2gf/gI3eEB/+PWSwgb2D2fgACe4QAM3eEB/OH5gA7ENbAPbCFucnWHgBg/oD+cPDJsFdnCAYduBCzRwP1yx7gmMFeKyrAku8FuhxWX5+kPhAb/9fq/L7ZjnKmxgBz9biwP6+kPhAg2MdeP07VhhBQ5wgrHfUGwDN3hAf3h+YAPDFmfnDHCCsd84k8fADR7QH/oPbGAHBzhBbI7NwxZX6Kv53eO2/2o+MWa0ChvYwQFOcIEGbvCAYfsuVsxoFTYwbC1wgBMM2wo0cIOfbeRi/jBq/mIDOzjACS7QwA1ii5r//t5pxwfQFTYwbBY4wAl+thmHGTV/cYOHf9cfRs1f/GwzthM1f3GAE1yggRs8oD+MTnAR28K2sC1sC1v0h+9VwB2jXYUHDNt3p8bAV2EDP9uKUxL94eIE47rF/RD94eIGP9sKW3SNxO/5ofCzrbBFL7k4wM/2jbjtGPgqNPCzWf67B/SH0Ut21EX0kosd/Gw79hu95OICP9uOKx+95OIBP9uJsx695GIDP9uJ2zN6ycUJfrYTpyR6ycUNHtALY+Cr8LN9b6zuGPgqHOBn+9433THwVWjgn+1Ep42Br0J/+PWSEz/1YuCrsIPjQwuc4AL/bCd+OsXAV+EBP1v8SIqBr8IGfrZorzHwVTjBzxZtMAa+Cjf42Xoc8ddLLn69pPCz9TipXy8pHOBni04QA1+FBn62kYsd0B9ObLOBHcT29ZLCBX62KPQY+Co8oD/8eklhAzs4wAkuENvCtrAtfwf/9ZLCBvZ38F8vKZzgZ1txhb5eUrjBzxZ9Jwa+Ln69pPCzrbB9vaRwgJ/NYr9fLyk08LN9kzo7Br4K/eH5ve2cBnZwvO18vaRwgdjOBg+I7eslhQ38bBbn7OslhRP8bDuq5eslhRv8bDtsXy9JjDGwws8WrS3GwAoH+Nm+9wN2jIEVGvjZvncJdoyBFfrD6CXRuWI4rLCDn+17sX7HcFjhAj9btLb4sLrCA342j/1GL7nYwM/mYYtecnGCfzb/xWJfLync4PkwF/OHXy8pbB/GYl8vKRzgn83jWTlGxgoN/GwtFzugP/x6ifc4qV8vKezgZ4vnvpgpK1zgZ+txUr9eUnjAz/b9vf+OSbPCBs56MIzpsf29h71jeqzQH8azxsUGdnCAE/z2O+Lm+vpD4QYP6A/3D2xgB7+zE0+O8QF0hQsMW5zJvcEDxm8ScS3iWeNiA8MWZ+fEuvn/NXCDB/SH/gMb2MEBThCbY3Nsjs2fLebPChvYwQFOcIEGbvCA2Bq2hq1ha9gatoatYWvYGraGrWPr2Dq2jq1j69g6to6tY+vYBraBbWAb2Aa2gW1gG9gGtoFtYpvYJraJbWKb2Ca2iW1im9gWtoVtYVvYFraFbWFb2Ba2hc2wGTbDZtgMm2EzbIbNsBm2jW1j29g2to1tY9vYNraNbWM72A62g+1gO9joJZNeMuklk14y6SWTXjLpJZNeMrOX7MAJLtDADR7QC1f2ksQGfrZvjGbH+F7hBMN2Ag3c4AH9YfaSxAZ2cIATxNawNWzRS76PKtgx6ncxesnFzxa/NceoX+EAP1s8I8ZQ3/3Poj/Eiw4xvlf4rfD9qeyO8b3CCS7QwA1++43fsGN872L0h4sNDFtsMvrDxQl+NoutR3+4uMHPZrH16A+J0R8uNvCzxW/uMern8UwbQ33+ze/sGOorPKA/jE4QT7ox1OcWRxGdIH6fjw+r8x226AQXF2jgZ4un4hgALPSH0QkufrYd+43yjxcHYurP46k4pv58x3ai/ONROKb+Cg/oD6P8Lzawg58tHptj6q/Q3m10uKMOd+rhTnXu1Kj5ix0c4AQXiM2xOTZ/tvi64MI4oBnYwQHGAa3ABRq4wQP6w6j5iw3s4ACxNWxR8/FbR0wpFh7QH0bNX2zgZ/M44qj5ixNc4GeLN2RiSrHwgJ8tfoWJKUWPX1ZiSrEwbDtwgGGL7UR/uGjgBg/oD6M/XGxgBweIbWKb2Ca2iW1iW9gWtoVtYVvYFraFbWFb2BY2w2bYDJthM2yGzbAZNsNm2Da2jW1j29g2to1tY9vYNraNLRpIvIMXY4yFHRxgVHfiAg3c4AH9YfaSxAZ28G/dv3c5fsHxgyjR4//9dbT4GLzHTbgLD+EpvIRP8FdXMeWYJySmHPN4Y8qxcIILtFhiBG/hI+xwf5c2PuWusIMDnOACDdxvH9kAEv3h+IGNTYwuPIQR0gM2PWDTAzY9YNMDNj1gz3cv7ckJnZzQyQmdi01MOaNTzihtYNMGNm1g0wY2bWDTBjZtYC+uYLaBRM7n4nwuuXz2E5YzSifYdIJNJ9h0gk0n2HSCTSfYdIK9uYCb87k5n5vzuTmfO8/nDDbhPJ8r+Ag7fH7CeYixldOFh/AUXsImvIWPcHpjz/4Tjs4QZ9YnNZqt4fsUzx1Dm4+38BHmyp3fT7gJd+EhPIWX8Lt6Mb5ZeMB39WJ8s7CBHRzgBPNwWvARdrjH4cSbGjGs+cexvd6Fh/AUXsImvIWPsMPjvRh18sWHxAku0MANHtAf5osPiQ3ENrFNbBPbxDaxTWwT28K2sC1sC9vCtrAtbAvbwrawGTbDZtgMm2EzbIbNsBk2w7axbWwb28a2sW1sG9vGtrFtbAfbwcZLludgO9gOtoPtYDvYDjbH5tgcm2NzbI7NsTk2x+bP5r8f2MAODnCCCzRwgwfE1rA1bA1bw9awNWwNW8PWsDVsHVvH1rF1bB1bx9axdWwdW8c2sA1s9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3E6SVOL3F6idNLnF7i9BKnlzi9xOklTi9xeonTS5xe4vQSp5c4vcTpJU4vcXqJ00ucXuL0EqeXOL3EXy85v9dLzu/1kvN7veT8Xi85v9dLzu/1kvN7veT8Xi85v9dLzu+HrWFr2Bq2hq1ha9gatoatYWvYOraOrWPr2Dq2jq1j69g6to5tYBvYBraBbeRTzwxewia8hY+ww/Mn3IS78BAW7xTvFO8U7xTvFO8S7xLvEu8S73sj9eSo50UDN3hAf5i/4HxvPJ5f/oJzuQuncQdP4SWcR3qCt/ARdnj/hJtwFx7CU3gJi3eLd4t3i/eI94j3iPeI94j3iPeIN3/b+eaJzi9/2/mmIs8vf9tJzt92LjfhLjyEp/ASNuEtLF6vCcuT06MXG9jv+OPJ6dGLE4xJvR5o4AYP6A9jevRiAzs4wAlia9jyt58enL/l9Nhb/pYTd2/L33IuL2ETznW+u7TlCyHfSNRp+ULI5Sm8hE14C8fZ/oYZTsu+kZx943IT7sJDeAov4fRa8BY+wg5n3/gmFE7LvnE5xiTi0GMA9OIEF2hgKPMyrJokPC37Q/6/s67zdsq6Ts66vtzuCOzJac2LA5zgAg3c4AH94fmB2A62g+1gO9gOtoPtYDvYHJtjc2yOzbE5Nsfm2BybP1tOa34vipyc1rzYwQFOcIF5kb6yiRHMP17BeTvu4CE8hZewCW/hI+xwvlhxuQmn14OH8BRewia8hY+ww+Mn3ITFO8Q7xDvEO8Qbg97fMN6J4cxCfxiD3hcb2MFY+Xuj+vQs4Jn//9j598bX6VnAl5twFx7CU3gJx87z6mcVX45Z5/xX/GHMVl1sYK4dd03+KJ9x18R09k70hzGdfTHmpePejXq/OMCYl46Fo94vGrjBA/rDnM5ObGAHB4jtYMsf0DP2kz+Iv/H20/MH8Yxrnj+IL0/hJRzrxBUe+fri9xldZ+Tri5eH8BRewiYcZ/t7T/6MrN3LDrefcBPuwkN4Cqf3F2zCW/gIp/e7uCNr+nL+tzt4Cx9hv5PiJwYcCxvYwQFOMFf+rs7IH6zfgMEZ+YPVYof5g/XyEJ7CS9iEt3Ds3OJqZl0mxyz0N5t5Yn6xsIMDzLXjSuZ7CN+I7okJxphXPzHBWNjBcefVT0wwFi4w5uBjozHhfPGA/jAmnC82sIMDnOACsW1s+eBscR/lA7LFUecDssUVywfkyya84XwQtriSWWc71s86u7yETXgLH+E429/YxZn5uv/lJtyFh/AUXsImnPs/wUfY4azLy+kdwV04vSs497+DHc46u9yEu/AQnsJL2IS3sHjfHzSc+f6g4czRwPqDhjPfHzScGD0sjD8xsEADN3hAf5h/0JDYwA4OcILYJras1x37yZ+X36fQnJk/L7+ZmDPz5+XlJWzCsc6JK5W//n4zJ2fmr7+Xp/ASNuEtHGf7xD7zMTk5H5MvN+EuPISn8BJOb9yl+evv5SPscFbxiYubv/5eTq8HD+EpvITD63HesrovH2GHs+ovN+EuPISn8BIWr9cfe5wYJiz0whgmjL+jODFMWNjB+EMWD5zgAg3c4AH9YfyJwsUGdhBbw5Y/e79Zn7Oy9r8Pizgra/+b6zkra//yEJ7Cuc53NVc+B39vLp6Vz8GXu/AQnsJL+Dvb7RcnM34aFx9hh+OndHET7sJDOL0WvIRNeAunN67ddHjl+iM49xnnZB1hh+0n3IS78BCewkvYhMUbP5njl7iYDbwYP5kvxl86xbXaHRxg/KVTLBY/mS8auMED+sP426OLDezgALEdbCfPXmzY8yzFXeF5luLu9SE8hZdwrBOPOjHg94c9uAsP4Sm8hE04zna8CBpzfo8djp/IxU24Cw/hKZzeX7AJb+EjnN7vvMXM3+P07uAuPISncHo92IS38BF2ePyEm3AXHsJTWLyj/ubsxAxg4QHrb85OzAAWNvC7y+JBOGYACye4QAM3eEB/GE/jFxuIbWGLn+ytx9XJ2o+XEi1rv8eBZO1f7sJDONeJq2m5zlcRMbP3uAl34SE8heNsxxNUTO493sJH2OHzE27CXTi9cS3OFF7CJpzeuPpZ9clZ9fFSomXVXx7CU3gJm3CsHy8cWnaDy3Fc8WJhzvgVp3cGd+H0ruApnF4LNuH07uAjnN7vXO3sEpfT68FdOLzxCs7OLnE5vPFqTg4GFoc3XpHJwcDi8MYrMju7xOXwxisuO7vE5fTGMWaXuJzeOMbsEpfTG8eYXeJyeuMYs0tcjueU2EI86V8c4AQXaGAa4yzlU8Flh/OpIF7h2PlUcLkLD+EpvIRNeAsfYYeXeJd4V64f+8+nhXh1ZOfTQrzCkTOAl7NjXG7CXVj2b7J/k/2b7N9k/yb7N9n/lv1v2f+W87bFu8WbnSSPMTtGHuOR/R/Zf3aMy1N4Ccv+j+z/yP6P7N9l/y77d9m/y/5d9u9y3ly8jjcn/PIYc5IvjzEn+XLPOclXbMJb+Aiz/9N+wk24Cw/hKbyETVj2346weLt4swPkMWal5zF22X+X/Xfu2zN+wk24C+f6FjyF4wf0DjRwg+fhrenkXOMEf2vECygxq1e4wW+NeGUkZvUuxg/5i19/+v7y5sSsXuEAJ7hAAzd4QH8YL85dxGbYbgV7cJxpy/9/nOl41jhZqZebcBeOdeL56OTPdosrkD/bk7NSLzfhLjyE42znVchKvWzCW/gIO5yVerkJpzeuRVbq5Sm8hNMbVz8r9XJ447W6kz/zgz0r+HIT7sJDeAovYRPewkf4u+bxPqa/DxM4/j5M4Hh+mIAHDnCC3x0WL5fE5F3hBg/oD+PDBC42sIMDnCC2ji3rO+5MzzqOSvGs43iHw7OOLy9hE851vlr3/Dkcrwh6/hy+PIWXsAlv4Tzbca7y53By/hy+3IS78BCewks4vSt4Cx9hh/PndrwW6Plz+3J44/U5z5/bl8N78r8Nb7zGFgN08QkPJwboCg/oD+N3/IsN7OAAJ7hAbBtbdoy8UbNjJGfHuNyEu/AQnsJL2IS3cHrj/GfHSM6OcbkJd+FR7L+s9O8P1vyXlX65Cw/hKbyEY5/fK2T+y0pPzp+93yth/sufvZdNOP/9HXyEHY7Rtl/86zHadrGD37DZ95qI52jbxQV+o22/2FR+8kfiAf1hfvJHYgM7OMAJLhDbwJZP3N+d4zmm1r/X2zzH1Pr3mpnnmFqxCW84Krf/4syvXCfWX1N4CZvwFj7CHhznyn7CTbgLD+EpvIRNOL09+Ag7vH/C6Y2rv7tweFuct3iy7i3//SVswlv4CDsc1VrchLvwEBZvTL32RAM3+N1iPa5VTL0mxtTrxe8W63FhY+r14gAnuEADN3hAL4xxs8IGdjDP3gjOs7SC8yx9VzCmyB434S6c65zgXMeDHe4/4SbchYdwnO3cZ/yGXWzCW/gIOxzP3cVNOL07eAhP4SWc3h684azWPPas1stH2OGs4rgH2pLjzSq+vITTO4O38BHO441rZ3KeTc6zyXk28Zp4TbxZxZe3sFxfk+u7xbvFlRXa4z7JCr28hfNY4vxkhSZnhV5uwrF+j/WzQi9P4SUc3m+Yz2OA7I/jHoifm8VNONYfcX3j52bxFF7CJryFj3B6v+ses2SPm3AXHsJTeAkbnHX6vQLnOUXWv1fdPKfIipewCW/hI5x7/s55TpEVN+EuPISn8BI24fR68BF2OOv3chPuwuNdu5wiK17CJpz321fXMSVW52124SE8hWPN7xVHz/mxe66yxpOzxi/H+jO88YxdPIRj/e9VSc/5sfpv5RotuUZLvEu8Jt6s/ctdWO4Nk3vDxGvi2jx19PvTObkLD+E8lmSeOvo+wg5njc/kJtyF81zF+T9T/tslbMLiPeI94s3av9yEu/AQFq+LK+v6e8XXR9b15Sacx3KCh/AUXsKx/vd6recUWvERdjhr/3ub3XParH/vqHtOmxUv4Vj/e03Lc9qs+Ag7nLV/uQl34fSO4Cm8hE14Cx9hh7P2L+eaKzj/2zi3WcuXHZ4/4SbchXPPcc6zxi8vYRPewkfY4az9y+mNa5S1f3kIT+ElbMKba5e1f9nhrP3Leb/t4MV5y5/pl7fwEY41Le6lLecqa/zyFI71Lbz58/3yFo71Le6TLdfoyDU6co2OeI94j3iz9i+bsNwbR+6NI14XV756tpOXsAlv4TyW756c91WyHdyFh3Ds+Xul0XOirdiE81yt4CP/rcP5+vdl8TbxNvG2KbyETXgLi7eLK+v6my70nG4rXsJ5LCd4Cx9hh7Ouv6lDn/kz/XIXHsLh/V459Jm1/73m5jNr/7LDWfvfy9o+s/Yvd+EhPIWXsAmnN6571v5lh7P2LzfhLjyEp3CuGfdA/uyO+y1n34qH8BRewiace45znjV+2eH8+X65CXfhITyF0xvXKGv/8hY+wg5n7V9uXLus/ctDeArn/Rb3Z9Z1nrf8mX65CXfhWPPEveRyrvK5/fIRjvW/mURf+fP9chOO9b+ZPl8/rtH6TeElbMJb+Ag7nD/fLzfhLizeJq6s6+gzK19bS84av9yE81hGcL6bsIJNeAvHnk/+tw5njV/OcxX//uj8t2MIT2HxDvEO8Y4j7PD8CTdh8U5xZV2fOFdZ15cdzrr+XoP1lXV9uQsP4bju8Vrryp/pl014C4f3+xJCzwm47nFfZe1fHsKxvsf9lrV/2YS38BF2OGv/cnrjumftXx7CU3gJm/AWPnDWdbz2u/Jnt8e5zVq+vIWPsMNZ45dzz3HOs8YvD+EpvIRNeAsf4fR+18iy9i834S48hKfwetcu5+aKt/CBs96/95g8Z+LyvOVMXPESNuFvzRGvMOfsW56rnH0r7sIj/v3wxs/34iVswT14y397hLlGOftWLN4h3vz5fnkKL2ETFu8QV9T1iN89Y7ztj2fwFF7CJryFj7DDd27lBDfhLjyEp/ASNuEN25ub8JyAG/HWRk7AFQ/hKZzHFefBTHgLH2GHo/aLm3AeVxz7HsJTeAmb8BY+wg4z/+J3Mi6P/chxnSVswltYjuvIcbkcl8txeRcewlNYjsvluFyOy+W4nOO6E3OXm3AXHsL2jj0n4/K4cjKu2OH2E+a4cjKueAhP4SVswluY47qTccldjqvLcXU5ri7H1afwEjZh59iHHNdowl14CMtxDTmuIcc15LjGEeY+yTm4YjmuKcc15bimHNeU45pyXHMLy/mccj6zb8Rr9Tv7xuUpvITzuHbwm3j1Owd3uQnneTvBQ3gK53nzYJP/dgsfYfFu8W7xMmnrm0lb30za+r6Ttsni3eKK3wVGvNOXM3HFQziOJd6Jy5m4YhPewnEPxPtcORN3OXvF5Sac3rhenuvHtXAT3sK5fuzf/XHOxBU34S48hKdwenewCW/hI+xw9orLTbgL55oeHP/tN53tOe9W3IS78BCewrHneF8s5+OKt/ARdjj7wOUm3IXTO4Kn8BI24S18hP1du5N94HIT7sJ5XVrw5rzlM8Nlh9dPOI9lBsu5WkvYhHPP4V1H2GHLcxX3ick1MrlGJtfIxGviNfHmM8PlIyz3xpZ7Y4t3iyvrOs9VPg9cPsIOn1wz7snz/u7E7zTd5SWcez7BW/gI557j/OdsTP633oS7sHhdvC5eN+EtfIT98Z2mu9yF4/zHe5E5KVe8heNYRv77DmddX27Ccd3jfUDPZ4DLU3gJp3cG5/rffeVZ+5ebcK5vwUN4Ci9hE97CRzi933X3rP3LTbgLD+EpvIQNzrqO9wdzjm7Ee3Y5R1e8hE14Cx/h2HO8T5dzdMVNuAsP4Sm8hE04vXGNsvYvO5y1f7kJd+HBtcvav7yETTivy1ePnnWd52134SE8hfNY4l7acq62w1njl3PP4c2f75eHcJ6ruE+OXKMj1+jINTriPeJ18ebP98tdWO4Nl3vDxevP9X00dv45587QNHQNQ0MufEP+DeXJcDS4hCz2eUPT0DXk/j3D1AWWBtOgO2i6g6Y7uH8Ae0PT0DUMDbqDrtIs+JUnMSu+QtMQB/e9p/iFoWFqWBrivvh+n/jC1nA0uITsD98z+RfSszJMDUtDeizD1nA0uITsExWahq4hd5B3SPaKCkuDadgajgaXkB2jQi6dt0v+zLc88dkEKriE/LFfoWnoGuIQLC9JtogKS4Np2BqOBpeQDaRC7iAvY7aQCkPD1LA0mIYtFzgbSQWXkK2kQl65lmHJGc3fECpsDUdDHlzcfO0nJ7HlrwMVpoY8hJXBNGwNeRItg1zGnOR7oWnQHTTdQdMd5CNEBdOwNRwNuoOu0uwUZ2RYGkzD1pBLx62c03zxyQ5f6BqGhjyEk2FpMA15CJ7h6AIuIT/6poLuYOoOpu4g/7C+wtJgGrYG3cFSaXaKnScxO0WFpSEObvcMW8PR4BKyU+w81/lwUaFrGBpyB7m3bCg778RsKBVcQjaUnfdoNpQKXcPQMDUsDaYhd5B3SDaUCi4hG0qFpqFrGBqmhlw6b5d8tjh54rM5VBgapoalwTTEIZy8JNk2KjghhwhfaBq6hqFhasgdjAymYWs4GlxCNpQKjQucH2n3wtAwNeSVaxmcM5rThi80DV1DHtzMICcxRwtfOBryEHIH+RxSoWnIk2gZ5DLmhOELS4PuYOgOhu4gn0NuyOeQCk1D16A7mCq9H5aVJ+R+WlaGbBsVmoZcemeIjpRt435kXYWtIQ/hZHAJ2TYq5CGkJz+45y6Qn9xTYWrQHZjuwHQH+fE9FVxCfoBPhaZBd7BVmp3CbzgaXEJ2Cs+SyU5RoWsYGuIO8SyMfPSoYBq2htxB3srZUDzvxGwoFYaG9OQ9mg2lgmnYGo4GJ+T04gu5g52haxgapoalwTRsDUdCdgr3DN8C8/fLYBq2hqPBJUTbeKFF6Bm6hqFhalgaTMPWcDTkDuIy5sjiC01D1zA0TA2LCzyyoVTYGo6E7CHeMgw5o/m7TIWlwTTkwcXNlxOMdRJX09A15CHkDtbUsDTkScy7aullXHoZl15G0x2Y7sB0BzY0TA16I5neSKY7MJXuXDpvy51LnwxTw9JgGraGo8El3I/uy6udn/pVoWsYGqaGpcE0bAmeJzEvsDcNXcPQEEfa8oREQ3nBNGwNR4MT8sP/XmgauoZ1P9P4YxPewinpGVxC+2loGrqGoWFqWBpMw9agO2i6g6476LqDrjvouoOuO+i6g6476LqD+3meLYNLyE8Yq9A05A5Ghrhx8jWTmZ+qW2FryCOdGVzC/GnII10ZuiyQv/xUmBp0B1N3MHUH+UhTwSXkI02FpkF3sFSaTadZhqPBJWTTaXm/ZdOp0DUMDXkZPcPSYBq2hthBz3s/nlVmz4uVHajC0BCenseTHaiCadgajgaXEB3ohdxB3iGnaxgapoalwTRsDUdCNp2et0u2lp4nPltLha3haHBCTmK+kIdwMnQNQ8PUsDSYhq3haMgdxGXMmcwXmoauYWiYGhYXeGXfqbA1HAm31ewMgzOaHz74wtJgGmLpETdfjmjWScxnlQpdQ3hG7iCfVSosDeEZPcPWBY4GvYxTdzB1B1N3MIeGqWFpMA26g6nSfIoZI0Me3MwwNSwNpmFrOBpcQn6Zx8wTn5/WX6FrGBqmhqXBNGwJ8cvPHDc0DV3D0JBHmickG0oF07A1HA0uIRtKhaaha0hP3r3ZNipsDUdDdP+76/zc0gpNQ9cwNEwNS4Np2ISc9fzlHZLDni90DeN+O8DHU3gJm/AWPsIO55d2XG7CXVi8TbxNvE28TbxNvE28XbxdvF28XbxdvF28XbxdvF28XbxDvEO82YHyJrDbgW6YGpYG07A15C3lGVxCdqDZMjQNXcPQMDUsDaZhazgaXMLSHeSvW7Nn6Bq+k1//1hRewiacjrxT8wlmzgyx0kmewks4VspT9DWbx0f4u4z5nmZMkz5uwl14CE/hJWzCW/gIi/eIN59Xsinm2Ois/yWvRB5atpcKLiF/Y6oQq+WbkjkMOvOZOqdBXzganJADoS80DXE18n3InAl9YWpYGkzD1nA0uIR8RMmrlTOjL3QNQ0PuYGZYGnIHlmFrOBpcQj6vVGgauoahYWpYGnQH0Vzy5cz4dMXHDkdzyZf7Yrb0cRf+7sp8DyhmSx8vYRPewkfY4fgSkuIm3IXFO8WbXSPfrc0PTZz5pmF+auLMd89yjPSFoWFqiNXyjdMcGZ358kDOjL7QNQwNU8PSEFcj33XMydEXjgaXkI8qFZqGrmFoyB1k6eSjSgXTsDXkDvJOyUeVG/IZ5J7rbBIVtoZcIE98Nokb4luH8nW3mBl93IWHcDjuzZYNIt/wiOnQk68hxnTo4y48Ph7JU3gJ28d3zS18hB2OD1wrbsJdeAhP4SUs3ibeLPp8SzFHRWe+PZizojPf/Mlh0RdMw5aQv6Tku245ADr3yTA1LA2mYWs4GuJq5NsoOQf6QtPQNQwNU8PSYBpyB5bhaHAJWewVcgd5RrPYK+QO8tpnsVdYGkzD1nA0uIRsEBWahq5Bd5DfkeLJS9iEv7sjX/GI2dLHDuc3peSFya9KudyFh/AUXsImvIWPsMNHvEe8+YJHvrWYg6Yz3wzMSdOZb57lqGmFfICo0DTkank68gEi31/K+dEXnJATpC80DV1DXI185yk/k/GFpcE0bA1Hg0vIB4gKeTwnQ9cwNEwNuYORwTTkG3tR4863qXxhaJgalgbTsDUcDS4hXyet0DToDvLLVS5P4SX83Wb5upDnF6xcPsJxe8dN4+87Vj5uwl14CE/hJWzCW/gIi3eJN7+CJZuf3+9ayXso3+jNBpOTpy+4hHxFo0KOuOTl5BtXvrA1HA0ySuP7p6FpyFGa3DVfvPKFqWFpMA1bw9HgEu73r+T9fb+A5YauYWjIHeRdcL+E5YbcgWfYGo4Gl8A3sXyhaegahoapYWkwDVvD0eAvtBpnveG7M+N3nvbLb2a5PIS/O3Pdf38Jm/B3Z8ZvFO33vp/lY4ffN7R83IS78BCewkvYhMXbxHuHV3uGPH8zQ56/lcE0bA1HwmDot/34tpYvLA2mYWs4GlwC39nyhaahaxgapoalwTRsDbkDy+AS8h2WCk1D7iCvcP7pWoX0jAh8hcsXuoahYWpYGkzD1nA0uIT8q7QKuoP8Rpc8gvxKl8tT+LudRl7P/FaXy1v4u53GXdPh980uHzfhLjyEp/ASNuEtLN4j3vu9L3kA9wte8h7Kv1T55Z2ff6pS4WhwQrt/odIyvD97+YJp2BqOBpfQfhryj25mhq5haJgalgbTsDUcDbmDuL/b/daXG5qGriF3sDJMDbmDncE0bA1HQ+4gzyjf//KFpqFrGBqmhqXBNGwNR4PuIL8NZiQ34S783ZmWJzC/EebyEv7uTMuL+b4U5uMj7PD7XpiPm3AXHsJTeAmLd4n3/uVrXsH75TD3f8m/Nc1Dy55SwTRsCffvWfOq84erX5galgbTsDUcDflns1GVjW+K+ULT0DUMDVPD0mAacgd5te43xtzgEvIv4SrkDvJOyV5SIZ/Z84TkqxcVtoajwQn9/t5yQ/7eYhm6hvy9ZWeYGnIHJ4NpyB14hqPh28HKn245mPpCi9AydA0jQs8wNawII4Np2BFmhqMhd5CH3X8acgd52L1ryB3kYfepIXeQh91NQ+4gD7sfDbGDbG052fpC7CDbe062vhA7yFadk60vxLNd7jN+2ynewkfY4Wg9xenO0ze7hqEh3fe/WRpMw9ZwNLiE9dPQNHQNQ4PuYOkOVnryyliulhfDcrU8/zY0TA1Lg2nQ4zE9HtPj2Xo8W49n6/FsPZ6tx7P1eLae0a072LqD0+Swz5TDPno8R4/nbA1Hg0twPR7X43E9HtfjcT0e1+NxPR7X43E9HpczmtOuLzQNk8POydV72Dm5eg8hP4CzQnacCk1D1yDHk5/O+cLSYBq2hqNBj6fr8XQ9nt416A667iD7yj3s2z3ysIcez9DjGUPD1LA0mIbw5I/vHGN94esgO3cTHaS4CXfhcMRoTMvP41z5IBAfyHlO/g/xOFLchL+VTv778ThSPIW/Hnhyd/E4UryFj7DD8V02xU24Cw/hKSxeE2/2hHxyyYHVlU8uObC68sEjB1ZfWBpMQ66WF/nkanmNztAwNSwNpmFriKsx8kxn5d+QlV+haegahoapYWnIHeRNm5Vf4WhwQo6lrhhUajmW+kLuYGYYGqaGpcE0bA1Hg0vIblGhadAdxKsf+RwVI6uPl/B3d+QTVcyrPj7C312Zr3fEsOrjJtyFh/AUXsImvIWPsHiHeLNr5O+xOYe68pfsnENd42Q4GlzC/GmI1eKPs1vOlK4YgWg5U/rC0eAS8lmhQtMQVyNmKFp+cOcLU8PSYBq2hqPBJVgej2doGrqGoSF3kGc0ny8q5A7y7OTzRYXcwV0gdpAv6sWngHo+YMZM6uMuPISn8BI24S18hB0+4j3izW60siyzG1WYGpYG07A1HA0uIbtRhaYhd5AXKLtRhalhaTANm5Czpyve1W85e/qCadgajgaXkP1jnQxNQ/43nsEl5PNBhfhv4s3ylp/4+cLQ8F3lfEEkZkofm/B3lfMRIj4L9LHD8c06+TJNzJk+7sJDeAovYRPewkfY4SneKd78XSNfTshB0WX3f4nzZ3lo2SVuyC5RoWnI1fLSZMVbXo2s+AouISu+QtPQNcTViOGBlrOhLywNpmFrOBpcQv5GUSF3kFcrnysqDA1TQ+4g75R8rqiQO8gzmr9R7PvfuITz09A0dA1Dw9SwNJiGrUF3kF/Gk1WQ38ZzuQl/t+XIMxNfyFM8hb/bMh+dVn4nz+UtfIT9seX38lxuwl14CE/hJWzCeWbjJszv1F7xN7ItP0B05QNkfoLoC0uDaYjV8iE4Py10xRt9LT8u9IWpYWkwDVtDXI34I9uWHxpaIX/nqNA0dA1Dw9SwNOQOWoat4WhwCflcEW8OthwGfSHGWnPluYWPsMPZLU5em+wWFbqGoWFqWBpMw9ZwNLgE0x2Y7sB0B6Y7MN2B6Q5Md2C6A9MdmO5g6w6yw5y8P7PDeN5r2WEqTA1Lg2nYGo4Gl5AdpkLToDv4OszOH6DxMaSPl/B3A+RPzxgnfXyEvxsgf0THLOnjJtyFh/AUXsImvIWPMN6YOn2cZ7ZlyPM3MuT5mxmOBpeQzxkVcjXLkKulJ1+hqHA0uIR8AqnQNOTV8AxDw9SwNJiGreFocAnZYfI3p/yw0Re6hqHh24Hla8n5gaMvWISeYWs4GlxCdJgXmoauYWiYGpYG3UG0pWyy8eGjjx3+2tI+eT2/rvS4C393Zbb+mCV9vIRNeAsfYYftJ9yEu7B4TbyWZzYPYOf5y0uz8/zlHbm7hqFhasjVoqjzu7gtXz3PDx59oWsYGqaGpSGuRr6untOkLxwNLiF+/3ihaegahobcQZaOLw2mYWvIHeQZdSfkZ5RavgifH0b6wtQQnnzmz88jfSGP1DIcDS6hpWdnaBq6hqFhalgaTMPWcDS4hK476LqDrjvouoOuO+i6g6476LqDrjvouoOhOxi6g6E7GLqD7D/5SmxOub5gGraGo8ElxDR6vvx3bl+5/8PSYBq2hlw5bvicUb13f86ovjA0hCdf480Z1RdMQ3jy1dycUX0LuAT7adAdmO7AdAc2NSwNpmFr0B1slWZzyVeaTzaXCktDHtzMsDUcDS4hG1K+pJvfOf5C1zA05A7ymmbbyRc6c1D1BZeQbSd/dchB1Re6hqFhalgaTEPuIE9Vtp0KTsjh1heahq5haJgaYul8GThnUy1fxc3Z1BeGhqlhaTANcQj5IqxnP6ngErKfVGgauoahYWrIHawMpmFrOBpcQvaTCo0LnPOsLwwNU0NeuZHB5Yzmg0qFpqFryIOzDHoSs21UOBrSkztYPw1NQ3pOBr2MSy/j0su4dAdLd7B0B9lQbsiGUkFvJNMbyXQHptL8DSgfjHPCtUL+BlShacil81a+v+fkYW/TsDXEIeQL3TnHWiHbRoU4hHwF2+/vOblAvpJSYWrQHRzdwdEdnKNBnu1zjvWFpkF34CrNTjHzJGanqOAv9BxQtXhtu+fnrb7QNQwNcYfEnwL2/MbyF0zD1pA7sAjZUOLPB3t+3uoLQ0N6ToalwTRsDUeDS8iGUiF34Bm6hqFhalgaTMPWcCRkp4i53Z7zq7byxGdzqLA1HA0uIdtGhTiElZck20aFoWFqWBpMw9ZwNOQO8jJmQ6nQNHQNQ8PUsOQCZ0OpsDUcCdlD4t2cnmOudUbz0aPC0mAa8uDy5tt6EvOXnApdQ3pyB/kcUmFpSE/eVVsv49bLuPUyHt3B0R0c3UE+h1SYGvRGOnojHd3BUWl2inPD0DA1LA25dN7K+S5v/KrbW77LW6FpiEOIP5Ds+XmrL0wNcQjxTkjPKdi3wNZwNOgOmu6g6Q5a1zA0TA1Lg+6gqTQ7Rbyb0XO89YWhIQ9uZlgaTMPWEHdIvM/Rc7y1Qj56VGgacgeWIT07g2nYGtJzMriEbCgVmoauYWiYGnIHnsE0bA1Hg0vIhlKhaegaYumdt0s+YOw88dkcKjQNXcPQMDXEIey8JNk2KmwNR4NLyIZSoWnoGnIHeRmzoVRYGkzD1nA0uFzgbCgVmoauIa9c3tfZKe4Zzd9lKriE/F2mQh5c3nyuJzF/Y6lgGtKTO8jnkApOyLFWi7+e6jnWehfIsdYXhoapYWkwDVvD0SA3Uo61vqA7aCrNTpFn9M6rVjgaXEI+esQ7Rv1OpWb93KnUCktDHEK8Y9RzKvWFoyEOId5h6Xcq9S4wmoauQXcwdAdDd5Dv8VTYGo4GlzB1B1Ol2SnyB0sOnb6wNeTBzQwuITtFhaYh7pB4Z6rn0OkLU8PSkDuwDOnJi5UNpULTkJ48nmwoFaaGpcE0bA1HQ+4g75BsKBWahq5haJgalgaTkJ3C83bJBwzPE5/NocLSYBq2hqMhDsHzkmTbqNA0dA1Dw9SwNJiG3EFexmwoFZyQE6gvNA1dw+AC52zqC0uDacgrF300x1HvGc1x1BeGhqkhD84yyEnModMK2TYqpCd3kM8hFYaG9JwMSxcwDVuD7qDrDobuIJ9DKnQNQ8PUoDsYKs1OEb9V9/wK+Re6hqEhl/YMzJ/1IfNnfcj8Wc/PW92/XCDaxgtdw4hw/5upCywNpkF3sHQHS3dgPw1NQ9cwNOgOTKXRKfYvT+L+aWga8uBmhqFhalgaLEIWRjx6vHA0uISTO8hb+aQn78QzNSwN6cl79GwNR4NL8J+GpqFryB3kHeJTw9JgGraGo8EJOdj6Qiwdbxn1nEvd8Y5Pz7nUF1xCPGC80DR0DXEIMUvV87NUX1gaTMPWcDS4hP7TkDtYGbqGoWFqWBpMw+YC52epvuASxk9DXrmRYckZHaZhazga8uDi5ssPSa2TOIeGqSE9uYNpGraG9JwMehmXXsall3HpDpbuYOkO1tJgGvRGWnojLd2BqTQ7Rc+N5lRJBdOwNeTSeSvnK6f9hq5haIhDiHeTen5I6gumIQ6h5/XJ2ZFawCXk7EgF3cHRHRzdgUzK9ymT8n3KpHyfMinf72zqDa7S7BQ9T2J2igpLQx5clkx2igpHgxPy41N3vIHU8+NTX+gahobcgWVIz85wNLiEbCh5TXNQ9YWuYWiYGpYG05A78AxHg0vIhlKhaegahoapIZaOtzt6fkjqjtf9e35I6gtDw9SwNJiGOISRlyTbRgWXEM8hLzQNXcPQMDXkDvIyZkOpsDUcDS4hG0qFJhc4G0qFoWFqyCs3MricUftpaBq6hjy4vPlMT6JtDUdDenIH+RxSoWlIT95VWy/j1su49TJu3cHWHWzdQT6H3JDPIRX0Rjp6Ix3dwVFpPnqMvC3z0SOfOvNzUV9oGrqGoWFqWBqyV6X0/k3NDUeDE/ITU19oGrqGoSH/KmxniJOYT5CWDaWCS8iGUiGPNFfLhlJhaJgalgbTsDXk39mdDC6h/zQ0DV3D0DA1LA2mweWEDD3S7DsVuoahQY906JEOPdKhR5p9p4JLyL5TQY906pFOPdKpRzr1SKce6dwa9FxPPdf3b3XzhCw90uwuFZYG06BHuvRIlx6p6ZGa3lWmd5XpXWV6pKZHanqkpkdqeqSmR7r1rtp6rree6/tXvHlCth7p1vrZWj9b6+fokR490qNHevRIj95VR++qo3fV0SM9eqRHj9T1SF2P1PVIXe8q13Pteq7zE03yCSU/fvWG/PjVF5qGzzPyCT8/ZDU/sKHnjOwLW8OJ/+ZkcAn5JVgVWgTP0GWB/KyTClOD7qDpDpruID/rpIJLyM86qdA06A66SvPrseLTAXoOzL7gEvLrsfI5PgdmX+gahoYZYWRYGkzD1pA7iMeVzbdwf6FrGBrSk8eTX21TwTRsDUeDS7hf2X1D7iDvkPyurApDw9SwNJiGreFIyG/Vy99yNl/M/QXTsDUcDS6Bb+f+QhxC/qTN2dgXhoapYWkwDVvD0ZA7yMt4v8v7hqahaxgapoYlFzi/K6vC1nAk5Ddz5u/bOShbZzS/HqvC0mAa8uDi5stx2HsST34JVoWuIQ9hZZgaloY8iZZh6wJHg1zGHJR9QXfQdAf5rXoVpoalwTToDppK76citQxDw9SwNOTSO0N0pGwB53720Q1NQx7CyTA0TA15CJ7BdIGt4WjQHUzdwdQd5OeoVRgapoalQXcwVZqdYuRJzE5RYWiIgxv3v1kaTMPWEHdIfNVAzxHYCvl9exWahtxB3sp82/cXTMPWkJ68R7Oh3JANpULT0DUMDVND7iDvkGwoFbaGo8ElZEOp0DR0Dbl03i58Afj3mSM/DU1D1zA0TA1xCPmIk4OuL2wNR4MTctD1haaha8gdjAxTw9JgGraGo8G5wPkpri80DV1DXrmWYXNGcwT2BZeQX9NZIQ9uZpCTmIOuL5iGPITcQT6HVHAJ+RySs3k56FoLjK5haNAdDN3B0B3kc0iFo0FupJyHfUF3MFWa32mV73TlCOwLR4NLyEePecP4pz4Nsueg6wtLQx7CDVvD0ZCHkNcnP731LpDfR1Oha9AdmO7AdAf5ia8VtoajwSVs3cFWaXaKlScxO0WFrSEOLufFcgS2QnaKCk1D3CErCyMfPSpMDUtD7iBvZfke8O7yPeA9B11fSE/eo9lQKkwNS4Np2BqOhtzBd4eMnId9oWnoGoaGqWFpMAnZKWKabvzke8DHT74HfPzke8DHT74HfPzke8DHT74HfPzu94D3CNk2KjQNXcPQMDUsDaYhdzAyHA0uIRtKhaahaxjvAo/8pNcXlgbTkFeuRchOcc9o/i5TYWiYGvLgZgY9ifkbyw3ZNirkIeQO8jmkwtCQJ9Ey6GVcehmXXsalO1i6A9Md5HNIha5BbyTTG8l0B6bS+9nQeRXuZ0Pf0DUMDbl03sr3E6DzJN5PgL7BJWTbiAGgkYOuL3QNeQh5fe4nQN8FlgbToDs4uoOjO8hPgK7QNHQNQ4PuwFWanSI+1WHkCOwLTUMcXMyLjRyBfWFqWBriDolvfR85AvvC0eASsqHEeOFo8j3go8n3gI8cdH0hPZZhazgaXML9uvAbmoauIXewM0wNS4Np2BqOBpeQDaVCLu0ZYoGTJ16+B3w0+R7w0eR7wEeT7wEfTb4HfLT7PeB5SbJtVFgaTMPWcDS4hGwoFXIHeRnv14XfMDRMDUuDadhygbOhVHAJ2VAq5JVrGZac0fxdpsLWcDTkweXNt/Uk5m8sFaaGPITcQT6HVNga8iTmXbX1Mh69jEcv49EdHN3B0R3kc0gF06A30tEb6egOXKXyvRPjfrJrBdOwNeSrx3HlunzvxOjyvROjPr/1hnyNeGZYGkxDvkq9MhxdwCXc7524QXfQdAdNd5DfO1FhaTANW4PuoKs03w+OXzhGjsC+sDTkwZ0MW8PR4BLuGzueoWnoGoaG2MHKveXbN/mAkYOuL7iEfPsmHoJHfgjrC13D0DA1LA2mIXeQd0i+bVzBJeTbxhWahq5haJgacum8XfJ9mZUnPt+XqTA0TA1Lg2nIQ8hLkm8bV3AJ+bZxhaahaxgapobcQV7GfMemwtZwNLiEfMemQpMLnO/YVBgapoa8R3cGlzOabxtXaBq6hlg6H8xy0LVOYk6bVDgawhN/PDNy0PWFpiE8+eieg653gRx0fWFpMA1bw9HgEvJt4wpNQ9egO2gqzU6RP95zBLbC/barG5qGPLiRITpS/PXAGPfbrm7YGuIQ8tk/B10rZNuokCdxZeiygHxD1hjyDVljDN3B0B0M3YF8Q9YY+Q1ZN+Q3ZFVoGnQHU6XZKfIXjhyBfcElZKfIh+07Aluhaxga4g7JZ/IcgX3BNGwNsYN8CM5B150PGDno+sLQEJ58CB7ZUCqYhq3haHAJ2VAq5A7yDsmGUmFomBqWBtOwNRwJ2SnyueoOuuYT8R10rbA1HA0uIdtGhTyEvCTZNioMDVPD0mAatoajIXcQl/EOulZoGrqGoWFqWFzg/ATXF7aGIyF7SP56eUdg84zeEdgKS4NpiKXzwewOuuZJvIOuFbqG8JzcQT6HVFgawpOP7nfQtRY4GuQy3kHXCrqDoTvI55AKU8PSYBp0B0Ol+eiRvxXcEdh8QL8jsBWWBtOwNRwNLuF+l16enfwuvQpdw9AwNSwNpmFLyA82OslNuAuHpOXFye/TrLA0mIat4WhwCfl9mhWahq5Bd7B1B1t3sHUHW3ewdQdbd3B0B0d3cHQH+d28dsPUsDSYhrzUWTz51Xr5wzQ/qPWFriFvqbzZsulUWBrylspazl9+aoGjwQk5M/tC09A1DA1Tw9JgGrYGlebjSd5Id0y2wtQQB5e/u9wx2Qpbw9EQ9RJ/7zPumGyFpqFriB3E38eMlU3Hc6PZdCocDemJulzZdCo0DV3D0DA1LA25g5VhazgaXEL+WlShaegahoZcOm6XOwzreeLzWaVC1zA0TA1Lw3cI55eXJFrLC0eDS4iXSV5oGrqGoWFGyMsYfecF07A1HA0uIZ9i7gXOp5gKXcPQkAXoGY6c0fx954b8fadC05AHlzff0ZOYTzEVtoY8hNzBcQn+05AnMe8q18voehldL6PrDlx34LqDfIqp4IScmX2haegapoboFPlCgN1v/r7BJeQLKBXy4FaG6Ej5q6Hd7/e+wTTkfWAZjgaX0PMk7gxNFrjf733D0KA76LqDrjvIX4sqHA0uIb8euILuYKh05E2eJ3FsDUdDHFzL8xad4oWmoWuIMmvpiaeYF5YG0xA7yJ+N+VmxJybhRn5W7AtdQ3pmhqlhaTANW8PR4BKyobS8Q7KhVOgahoapYWkwDVvCzqXzdtm5QJ74vTSYhq3haHAJ0Tbyu4RHDra+0DUMDVPD0mAatobYQc/LmA3lhmwoFZqGrmFomHKBfWkwDVtDFmD00ZxlvWc0P+/1halhaciD6xnkJOYs6wtNQx7CyDA0TA15EmcG0wW2hqNBd9B1B1130LuGoWFqWBp0B12lI6/PypAHZxmGhqlhaTANW8PREL0qX/3OD399oWnoGoaGqWFpMA3xlmLPC5xf4Vmhaega8khviHcRe56d/DrgCkdD3vEZsm1UaBryjOY9mgMl9b9MDUuD7sB0B6Y7yIGSG/Jt4gpNQ9egO9gqzYYSU3ojZ1krZEOpEAc3smSyoVQYGqaGuF1GFkY2lApbw9GQO8hrmm1j5D2abaPC1JCevN+ybVTYGo4GJ+TI6wtNQ+5gZxgapoalwTRsDUeDS8iGEmNkIydWT8xTjZxYfeFocAnZNio0DXEIMWQ3crD1halhaTANW8PR4BJG7mBkaBq6hqFhalgajAucI68vHA0uIZ9QYn5v5CxrndF8DqlgGraGPLi4+XKwtU5iPodUGBryEHIH+RxSwTTkScy7aullXHoZTS+j6Q5Md2C6g3wOqbA06I1keiOZ7mCr9OsU+efnI0ZZH+fCebvm80mFreFocAnZTio0DXloeQ2ynVSYGmIH+UifA68vbA25g5PBJeTzSYXvtap8KotJ2MdDeAovYRPewkfYH8cE7ONv/XzYjinXx3l0LYNp2BqOBpeQjy4VmoY4v/mOYn4c7AtTQ+5gZjANW0PuoGdwCdmDKnznN5/R4tNgHw/hKbyETXgLH2GHv9bzOI8vT3b2lwpLQx6fZdgajoY8vrhPcwL2hTzDefHy16EKQ0PuIPeWbaiCadgajgaXkL8oVYgd5LuS+VmxLwwNU8PSYBr+dpCfQDRiTjY/r2rEmKzlC2YxJft4CE/hJWzCW/jvAPNzxEaMxxZ/jehxE/68+dq+f/3p8RRewia8hY+ww+cnnOcuDz77T4WlIc/d/W+2hqMhrl6+lJmTsy/k1cuaygedCkND7iBv2nzQqWAatoajwV+YOTn7Qu7AMnQNQ8PUsDSYhu88xy91M6Zo82PzZ3yObH6+8oyPkX08hKfwEjbhLfxdx/gda8ZYbfHXgB434c/bLg/hKbyETXgLH2GHx0+Y+2fmwOwLSwP3z8yPln3haOD+mfnRsi9w/8ycq31haJhyxefSYBq2hqNB75+l98/S+2fp/bP0/ll6/yy9f5beP0vuH5P7x+T+Mbl/TO4fk/vH5P4xuX9M7h+T+8fk/tly/2y5f7bcP1vuny33z5b7Z8v9s+X+2XL/bLl/jtw/t//sDFPD0mAa8uqdDEeDS7j954bv+OJn5ow528dDeAovYRPewkfYH+ew7Yk3DGcO274wNSwNpmFriAOMt5RnDttWyEegCk1D7sAyDA1TQ+5gZzANW0PuIA8uH4HiTe2ZY7j5/bozx3Bf6BqGhqlhScjfouIH01/oGnKBkWFqyAVmhr9DmL/7n2zhI+zw12EeN+E05LnMXnHyjM1Y6f4PDq+fcKyUO/r6xOMhPIWXsAmnOK9B/g5VIa9B3Nk5Q/tC05CHkdfN4nzkSctfh+5Jy/d5bsjfjSo0DXE9PK97vL7ywtSg1yN/b6qwNegOtu4gG4LnhciGUGFpiKU9r0o2hApHg0vIhlChafgOzn95CPFA8sLUsDRYhLx144HkhaPBI8SJz4+U9XgvZeak7Qtdw9AwNSwNpmFrOBpyB3Hr5KTtC7mDk6FrGBqmhthBvK0xc9L2ha3haHAJ0TNeaBq6hthBvGMycyD3hbwP8oz23MENW8PR4BLGT0NKZ4ahYWrIw14ZTMPWkNI8vcMlzJTmSZxNQ9eQO/AMU8PSYBq2hqPBJcTTjMfbGjOnc1/oGoaGqWFpyB3kLXYbUp6DbEjZD3KI94WuYWiYGpYG07Bp/f12sRtcwu1iN2QXy41mF6swNEwNS4Np2BqOBpdw8ozmrXyGhqlhaTANcU3zgSw/1PYFl+A/DU1D15A7yFssW1qFpcE05A7y3smWVsEJOeubX5I6c9b3ha4hdhCvlM+c9fV4CXzmrK/HS+AzZ31f2BqOBpeQLa3Cn+cu/LWtwgUauMHzMPtGvMY6cyK3QvaNCn+HGq+9zpjHLRzgBBdoYK4dN0xO1Hq8PD7jE2Zn/ktfCyhcYDwmJG7wgP4wH00SG5i+k2FoyIuTVzdLvoJpiN3f1aKw/W4uCvuF7yzkfxFl7TNvgSjrF7aGo8ElfGV9z93m7G/O/ubsb87+5uzvI6f8NDnlWbAzb4Es2ApxPmbeXlmwFfIY8n74Cnbl2fjKtdAffqVa2MAO5tq5uSy4mZvLXy4+jEnYwgZ+q3jiACe4QAM3mL6TwSVkec381/KJoULXELvPQ8nPe/V4PXbm571W+H76r1w4f/bn6csh2BeGhqkhLT2DadgaDpcph2ArZA1X0B0M3cHQHQzdwdAdDN3B0B0M3cHQHUzdwdQdTN3B1B1M3UE+CFSwqq+clL21kpOyL0gV5aTsC01C/Kz2lTvLkq4wNHyllfavpAsN3OAB/WEU8sUGdnCA2Da2jW1j29h23nRRTDmz+kLTkEeZN2SWfYU45StXy7KvYBq2hqPBJeTP6Qqxg3xlLKdZXxgacgd5cbM5VDANsYN8AS2nWV9wQkyzZoePWdbCDg5wggvMtaMr5me7er7qlkOrnq+T5dDqC1PD0hDHkK/o5NDqC0eDS8hfHSp8R2GJ6c9tZvOoMDWEP/4YZOYw6wtbQ/h3nrZsHjdk89h5BrJ5VOgavh/fubOvdRQu0MANnofZFnae3Sz+fGUnP9rV9/3XTMPWcDTkMeRJyPKv0DR0DUPDdxSeuEADv6O4/+4B/eH3O0FhAzuYvlzOpoal4UiIJ3vPl6JyDvWF7wrkbfL1j8IFxpnLV5fy81xfOBrizOUrEzmo+kK686JkF6kQR5K/B6zsIvmyTY6wer44kyOsni/O5AjrC0fD9wCR/3k8QFxsYBjy96McRPWY3Z45iOr5ekkOonr+0pyDqB4z1TMHUT0Gn2fOnnq+KmL5ZF7BNMS7TIkH9IfZEWKOd+bUqfv9X74XU3OVeI/jYu7VM/yt830NYISv5glNQ9cwIrQMU8PSYBq2hqPBJYyfhvT0DLlantSZ/1qe1JkbzZM6u4ahYWrYElaulmdnNQ25Wp7alQeXp9byv8mTaE1D1xA7aHnebGpYGkw8tvV/ORpcwv5paHJ2dtcwNEwNeg72kcPeLuHo2cmCu/fayePJi3XyePJiHdOwNRwNLsF/GpqGOJ58DSlGPAlTQ+4gbwrPHeTBee4gD8FzB3kIt1Tjmu5bqjc0Dem5YWkwDV+RzcQD+sOWR+IZYp18iWfn+5GJG4y95ssUO0u15/+SpVqhaega4mzle1M7S7XC0mAatoajwSVkqVZITx5llmrMf86dpRoTm3NnQcZU5NxZkBWWBtPwTWnk0Xw/aQv94Ve+hQ3s4AAnuEADsS1sC5thM2yGzbAZNsNm2AybYTNsG9vGtrFtbDvGWRIP6A/PD2xgBwc4wQUaiO1gO9gcm2NzbI7NsTk2x+bYHJs/W8xZFjawg88WH+j597r/zBA33rj/S9x4+WvNyXrLx96Tt34+nZ+89Ss0DVF8+UpNzCPmo2RMIxYu0MANHtAffnVU2MAOYpvY8gddvkB08gdd/gYaQ4j5gBUjiIUDnOACDdzgAf3hVyuF2AybYTNshs2wGTbD9tVKPgzGrGFhAz9bXsOvVgonmGco+tjJH3b5gkFMEn5fmpuhaxgapoalwTRsDUeDS8gfgxV0B647cN1B/hjM32dO/hisYBq2hqPBCTFSSGgauoahYWpYGkzD1nA06A6+l8Hy0T2mDQs7OMAJLjDXjp8gnj8e85efGBjMh/aYFyyc4N8q+Ygfw4KFGzygP/x6QmGcmXVDHH++IhfTgISjIY4/X9Dy/JlZoWnoGoaGqWFpMA1bw9GgO1i6g3wkzlekPB+JKwwNuYO8hPmwXCF3kFdj5Q7yaqzYQb6yGh+o+UI+YFeIHeRDkecDdoXYQb5Q4vmAnc9a9wM1739vwlv4CDucf/pwOQ0rQxxJ/iLl2TnytzDPB+gKLiF7SnxIxvTsKf+3tn/blSWHrizBf9GzHox3sn6lkEioslQNAYIyoVQ20Cjkv7c7p5E2jh/5cm437niI4IhzfNnibRqNXCQHeEIgREJ/jl5eTfqgeJUmfdD7v0kfBgRCJCRCJhRCJbQJ6ZA+9PmXdEgfBniCPIiCSEiETJAHSVAJDdCnyQ/9pE+OjbRHum9LkSt9ZmykE9IZ6YJ0Rbo3Cz23z4mNtENa+c6CQIiERKgAjSF6CFA6NIYYIGtVEAmJ0HNypgvSFel2pfvE+Eg7pD3SAemIdEIaz414bsRzI56b8NyE5yY8N+G5Cc9NeG7CcxOem/DchOdmPDfjudKSPseVDmnJgEjoZd1Dp9Khj/UBhdDrtKrh6GP9BH2sV9W2PtYHeEIgRII8UKOQCg2QB8qPVKjKa6lQfymlQyo0wBG6B01ZkAoNiIRn8bsznZEuSFek25XuU/IjrSdIS6Q/TYUk/Wnqv9KfAe0CJ/0ZoJxkgScEQiQkQs+KV7pnpSit51fB8/l6IaQeCnjBs7H2D/R0Hq4pv84TNHv6PEBTaYe074b04y4bEyIhETKhECpBDsuXcBAcIVwen0d6K52Q7rlSYem4zTNdkdbjlK14EBxBGW6CQFCGVdoxETKhP/9MV6TblT5P2lTaIe2RDkhHpBPSGWk8N+G5Cc/NeG7GczOem/HcjOdmPDfjuRnPzXhuxnMLntuVxTk1za4sEwKhl7b6Y48ivCATevM6+0ZXlgkN0JVlgjwIAnmgdqRTamRZh9Sc6YS0Hp8EhVAJDdAOgiN4QiBEQiLQg0YPGj3Q4TW9NBVoONIOaY90QDoinZDOSD8rvn+TpvMozzPdrrR0qM9qph5eeIEnBIIyXgSJkAkNIJnqk5bJS6a8vJRMDUiETOjW+oxk6jGAD1AWQiBEQiJkQiH0SulTjclLhU6QCg1wBE8IhEhIBHngBIVQCQ2Q5IEKPjmCPFDxpkCIhGfjyKexjHRBuiLdrrSusT/TekIVKCeqzT56cUHV1EcvExqgj14m9JwE1aY0ZkAgREIidA+CClYaM6ASGkAaM8AR5IHyUwMhEhKhe3B2NcnMgEroHkR5LZk5u55kZkD3oM8ZJS+ZGdA9iHJUMjMgEwqhEtoFPfrvAkfwhECIhETIhEKoBHrg6IGjB44eOHrg6IGjB44eOHrg6IGjB54eeHrg6YGnB54eeHrg6YGnB54eeHoQ6EGgB4EeBHoQ6EGgB1K2Pu2VgpRtQCU0wLn4qbRD2iMdkI5IJ6Qz0gXpeqUlW30eLQWJU59HSz1a8QJlowkKoRIaIB8ER/CE/pwkdzKrJbNQJFEDHMETerX0ObcUJFEDEiET2DAKPShsGJUNo7JhVDaMyoYhiTp9k0QNYMOobBiSqNM3SdQJkqgB9KDRg0YPKFGBEhUoUYESFRqbZkMtxOMgOIK/fItHIEQCPIiUqEiJipSoSImKlKhIiYqUqHhKlHxzkZAImVAIqgUvaABJVN/4nqIkaoAnBILKQKYlUQMyoRAqoQEkUQMcQR4UQSCgm0WpUp+iTVGqNKASGiCi8UWNtwaw6iOrPrLqYyJkAqs+suojqz6x6hOrPrHqUyBEAhufhKvH/T2gASRcA/pzsspNwqVRV9Soa0AkJEImFEIlNIDEboCeo8YnSRuQCJmg56jxSdIGNIAkbYBGsMq2JG1AIERCImRCIVSAhEtfC1HCNSAQIkE5jQJZk9eSJ0GSPA1QzSWBJwSCSjQLEg1kQiFUAj1w9EDyNMATAiES6IHjQ6U7+mZL0p0BnqDMVUEkdNN9mSEl6c6AQuiZ6wsQKUl3TpDuDOgeaC0gSXcGBEIkyIMoyIRCqAR5oMqS1GhSPUlqBkSCnqMCkdQMKIRKaABJzQBHkAcqUUnNgEhIhEwohEpoAKlLVZVIQzQJnaQhAyqhAaQhAxyhZ0ET10nqMiASEiETCqESGkDqUlWNUpcBnhAIkZAIGRUsdRlQCQ0gqdGyVpKgnCUqQRmQCYWgzPXGlw8UYpagDAgEPScLEiET9JwiqDSAaszuINADRw8cPZCgDEiETCgEeuD5UH/NgOv40ZFOSD9nL6RTOnt0pCvSPVtak1Ac6ARH6NnSmoQiRCdEQn+6irLPYI90Qboi3a50XxwbaYe0RzogHZHGcyOeG/HciOdGPDfhuQnPTXhuwnMTnpvw3ITnJjw34bkJz9WARisyimWd4Akq7CiIhN6GtIqjWNYJhdDbUDsf2gASIy22KJZ1gjxogkCIhJ79M52RLkhXpNuV7rHmI/18wvnxqyhWrxUVRbH6Q0XRJWVCA/RvsAmugwqpD2UmBEIkJII8kAi0QqiEdkGPYr3AEboHmtzv55leEAmJ0D3Q5H6Pb72gEroHmunvJ50+IAkcQR5kQSDIAznqEiETCqESGsAfBEfwhECgB54eeHrg6YGnB54eBHoQ6EGgB4EeBHoQ6EGgB4EeBHoQ6EGkB5EeRHoQ6UGkB5EeRHoQ6UGkB5EeJHqQ6EGSB1UQCJGQCM9unc50Qboi3a50nwEfaYe0RzogHZFWBrsm9BjcxyLIIXCEng2943ok7gWRkAiZUAgVUPUc9a7KaqksFEnUgEKohF4tetEWSdQAR/AENoxGDxobRmPDaGwYjQ2joWHU4yC4y9F6eEIgREIiqESjoBBUoknQAJKoAY6gMpBpSdSASEiETCiESmgASZReO1USNSBcVV+lSlp6qVKlAZlQCPWqRgUuDwgHwRE8IRAiAVVfqUqVqlSpSpWqVKlKlapUqUqVqlSlPX1beVJA84RK6M/RIpNCnX2Q19KeAZ4QCJGQCJlQCBWQ9Rw1vuwJgRAJeo4aX86EQqgEve+VbcnTAEfwhECIhETIhALowyS97nXG6kh7pJ96qlGADlgd6YS08qheIMkaUAk9fEjlqvChM+2QVhGr20ivBkRCmmE9PSB6pgvSFek20z0YeqYd0h7pgHREOiGdkS5IV6TxXIfnOjzX4bkOz3V4rsNzHZ7r8FyH50qXtOjZpEsDHEHRVVUQCL20FcPRJFIDMqEPxk9jFel2pfu235F2SHuk9QQv6I1GS7GKovZafVUU9QRH8ITebjStryjqCYmQCYUgD1SWEqETJEIDekyQ/FQs0pkOSPeYIGVMsUhnOiNdkK5ItyutWKQz7ZD2SAek8dyM50qPtMjXpEdalmvSowENID0a4AieEAiRkAiZQA80XNKiiwKuB/SJpQndAy1sKOB6QiB0D7Qc0zTEGpAJDaDLsdSK+mkCIx2RTkhnpAvSFek20lmB1j6d4AieEAiRkAiZUAgqySJoAA2TBsiDJPCEQOhtySmdkM5IF6Qr0u1KS4j6gDwfEqIBntCfnc/fREIiKPdNUAiV0HPfV0nyodHSAEfoHvSFkaxA7PknDwNRyX7i4ZnUj1WOUp8BgRAJiZAJ3f2ijEl9BjSA1GdA96DIHQ2BBgRC96AoYxoCDcgEeaDmoyHQgAbIB0EeqJFocFSUHw2BiupTkjOgECqhP6dPw2ZFV/uqnEpyqhyV5FR5IMkZEAmJ0D2oclSSM6ASGkCSU5UfqUyVo1KZquYllWlyVCrT9FCpzIBCqIQG0IfcAEfoHjT5poHRADZWfbsNKIRKQKdQ9PUEPbQIPCEQlO0qSIRMKIRKaACJ0gBH8IRAoAeOHvRvt9DHuLkfxXpBJTRAl6YJjuA7JEEgREIiyIMsKIRKkAfyOsiDJnCE7kEP9M09vvuC7oGTo120JmRCIVRCA/TR1QRH8IRAoAeRHkR6EOlBpAeRHiR6kOhBogeJHiR6kOhBogeJHiR6kOhBpgeZHmR6kOlBpgeZHmR6kOlBpgeZHhR6UOhBoQeFHhR6UOhBoQeFHhR6UOhBlQfSg+oInhAIzyFCUbPWXYNnOiNdkK5Ityuty5LPtEPaI60MBoFk7QRloytmD+K+wBE8IRAiIRFUXL1/KzT7LC6FZp/loNDsCZGQCKqWLCiESmgAj4bhPT3wnhAIkZAImVDgmyRqQAOEg+Dg2ylRJwQCPaBEeUqUp0R5SpSnRHlKlI9omj6yFiJrIbIWTomSb5G1EFkLlChPifKUKE+J8pQoT4nylCif2A5OiTqBtZBYC4nt4JSoE1gLlChPifKUKE+J8pQoT4nylChPifKF7aCwFgprobAWCmvhlKgiyAR5UAWV0ACnRJ3QPfDyTRI1IBAiIREyoRAqoXvglYU+UpvQlepQOkIoJFV9pjUrQnxCIVQCKjscB8ERPCEQIiERUNmKEJ9QCahsRYhPcARPCIRIUE6joBIaQPLWp+yz4sCDl9eStwGBEAmJkAmFUAkNoE/APhOQFe09IRISIRMKQc+pggaQiA1QTpvAEwKh57SvBmSFfE/IhEKohAaQiA1wBE8IBHqQ6EGiB4keJHqQ6EGmB5keZHqQ6UGmBxIxTSwEiVhQwUvEBlRCA0jEBjiCJwRCJCQCPeghCn2yKuvM3JFuV7rPvZ9Npc+9j7RHuq9lKot9gDXSCemMdEG6It2udB9gjbRD2iON5zY8V5rVVzmyAsND3y2aFRge+ibYrMDwCYEQCbLW27eCvEOfls4K8p7gCYEQCYnQa0MzNQrynlAJDSD9GeAInhAIyk8VJEImFII8CIIG0N3MKlBdzXymPdIB6Yi0sq+qkSipYKU85x9IK3o4dFYM9oRK6LvO5FSPYBpph7RHOiAdkU5IZ6QL0hVpPDfjuRnPzXhuxnMznpvx3IznZjw347kZzy14bsFzC55b8NyC5xY8t+C5Bc/VTe5qCrrIXWnd436mHdIe6YC0qlK1r5FJVL/SyCSq+psjeEIgREIiZEIhVEK7QEHZQaKhoOwJnhAIkZAImVAIldAAjh44euDogaMHjh7obp+sdEa6IF2Rblda1/qcaT3BC5STIFBOoqASGkDfXAMcwRMCQTlJgkToG8TkgE4uOtMV6XalNSBJyouGHVo6OGOszz8oSFekFZnb02d8tdIOaW0lUTogHZFOSGekC9IV6Xalz60dSjuk8dyM52oooZUIhVeHvhUkK7w6aPFB4dUTPCEQujV1fYVKh6w60hfMAEfwhECIhF4bWSUtNRhQCJXQANKJAY7gCfJALVg6MSARMkEeqIalEwKFSod+ClJWqPSETOgGqtIV6Xal1cfPtEPaI92foC8zBTwHrZ7olNygNRJFP09wBE8IhEhIhJ4TravolNwJTw8k0wqOPtO9k4+0Q1rPiAJZSoKnJclKD3Qe6f5tMdJPS1IbHaI70gHp5xOkeT3QeaYz0gXpinS70r17j7RD2iMdkMZzE56rLwZN9ClwOeiFp8DlUNQ+9F0wIBISQU1HptVlq8pGXXZAIERCImSCWqiqRhMVAxpA3XyAI3hCIESCPFALVjcfUAiVIA/UUtTNB8gDtS51Wa1jKRR5QiW0CxSKPMERPCEQIiERMuHpQd+4lBWJPNLtSvc+L41QGPJIe6Sfz5bcKAZ5pBPSGemCdEW6XekuECPtkPZI47kez5UC9L0OWUHEoYffZwURhx5KnxVEPCEQIkHWenUqIDj0iPusgOAJnhAIkZAIvTa0iKaA4AmV0ACaSRjgCJ4QCPIgChIhEwpBHqiGNZNwQn/BRy3W9ajgCzwhEGIHlWhXjAmZUAiV0ADlIDiCJwQCPegqoyVkBROPdEH6+fiz3XSFOdNdYEb6+eyzoXV5GemAdEQ6IZ2RLkhXpNuV7rIy0nhuw3ObSlY12FR+ampN5dc7iGKHJziCJ8haE3RrWgZVHPCALhETHMETAqHXhianFQc8IRMKoRIawB8ER1B+qiAQIiER5EEQFIBGDRq3Kow3alCtMN4JhVAJDRAPgiN4QiBEAj3oWlLOdEG6Iv18vN7uCu4daYf089kaDiiyd6Qj0gnpjHRBuiLdrnRXj5F2SOO5Gc+VPmjhQUG70asNSQW0VKCg3QmeEAjdmub9a5G13lt0avEER/CEQIiEXhua2VaA7oRCqIQGaAfBETxBHqh9t0hIhEyQB2oF0oUB8qD3cZ1aPMERPKF7oJlgnVo8IREyoRAqoQGkJQMcwRPoQb83T5rXw3ZnOiNdnumkdEW6XemnigS9IHrQ7kx7pAPSEemEdEa6IF2Rblc64LkBzw0qWS9Q+Sk30pQgt6UpJ0hTBjiCrBWBrFVBJTRAOgiO4Am9NjQTrBOMJyRCJhRCJTSAxhoD5EEWeEIgRII8UEuRlgzQc1TW0pIBjuAJgRAJeo7qRyozQDlVLZRKkAdyVPozQB6osqQ/A+SBCl76M0AeqItKfwZ0D5IKUfozoHugL0Gdijyhe6DvWp2KPKF7oK9ZnYo8oXugKTGdijxBHijb0p8B8uCZ7aJg3QnyoAg8QR5UQSTIgybIhO5Bn1gqCtad8PSgf/sVxeqOtEPaIx2Qjkj3Z/dpqHJoFDOgEPTs8zcNoFHMAEfwhECIhETIhEKgB54eBD0nCWRNlaHxTVb5S4sGVEIDSIsGMD+R+YnMT2R+IvMTmZ/I/ETmJzI/iSWa6EGiB1KpM9vSojPbifnJzI+0aIAnBALzk5mfzPxk5iczP5n5KcxPYX4K81NYooUeFHogLTqzLcU5s12Zn8r8SHEGJAJbSGV+KvNTmZ/G/DTmpzE/jflpzE9jfhpLtNGDBg8Ub3tmW1G1Z7YVVXtmQVG1EwqhEtBCFFU7Qc+pAk/og4gzHZFOSGek9YwuZIqOjX2CtfToWMXllR4cO9MJ6aclp7z34chIV6Sfw5H+yVR6WOxMO6Q90gHpiHRCOiNdkK5I47kRz5Um9InjorjWWJQb9fwit9XzBzSAev4AWVMlaxRSVEcahQyohAZQzx/gCKoNVY16/oBISIRMKIRKaAD1/KJGq54/wBMCoXtQ1VLU8wd0D6rKWuOTAZXQABqfDHAETwiESEgEevBUC4XdlB6mOtPtSj+lQpEopYepzrRH+tkqvfrMUyZmOiGdkS5IV6TbTPeY1pl2SHukA9IRaZVsb7g6aTj2WeGicNbYVyyLwlknBEIkyJpMa6zQ53GLQlMneEIgREIi9Nro815FoakTKqEBNBcywBE8IRDkQREkQiYUgjzwggbQ+KKpdDS+GCAPZEBa0lRuz/GFImBKj0yd6Yx0Qboi3a50OpB2SHukA9J4bsJzuxqlflZKUTjqhEpogK5GExzBEwIhEhJBHqiCciFUQgOUg+AI+o1aeWmAehAcwRMCQV6rUmsCNP1GNdwCIRL0G5V1y4RCeNZyPC23me6xoDP9rOX+EVZ6JOhMB6Sftdw/7koPA53pjHRBuiLdrrQ7kHZIe6QD0niuw3Od1g57RSvCM+kFqwjPpBGCIjwnREIiyJpMB1lT2QRPCIRISIRM0IJnFVRCA2itdYAjeEIgRII8iIJMKIRKkAe9pYRz1fWE7oFXiWrd1es3WngdEAmJkAmFUAkNoN4/wBHowbP3Kwyi9DDOmU5IP5tlPv9+Qboi/WyWWVns16CPtEPaIx2QjkgnpDPSBemKNJ5b8Vzpg1cjrCo/db6q8lNF10pogHYQtDCvDiJ96JOKRZGXEyqhXaCYzAmOoPX/IAiESEiETCiESmgAp/w0gSN4QiDIgyhIAPV+FYjiKydkQiHIt14lOip3lIF0YUAg6DlZkAiZoOcUQaUB1kJkLUR6EOlBpAfShQGJkAmFQA8SH6oO3+dDiw7EnZAI3XRUuanDD6iEBlCHj3qOOvwATwiE7kGPmS06EDdFNRe91Ac0gF7qUe1AL/UBnhAIkZAImSAP1EI0RBjQABoiDHAETwiESJBpNZcmAyp4jRcGBEIkJEIm9CwkVYn0YEC7QIGYExzBEwIhEroHfRK2KBBzQiFUQgNIDwa4q4IViDkhECJBzb8J2lWiOh13giN4gjLnBShERWBOqARlQR6Eg+AIKsQoQDUqAnNCItCDQA8CPZCgnCBBGeAInkAPIh8aMVZK5whCcI4gTnAEZe4EjJUUgjmhENQOTmgAycYAFaLqJ2O0pkjMCZFADzI9yPRAgjKgASQoAxyBHhQ+VEqh2XwdezuhAaQUmsBXLOcETwiE/hzNwiuWc0ImFEL3QEMPRWwmjZ0UsTkhEPQctVEJyoBMKIRKaBdkCcoAeZAEnhAIkZAImVAIFSCl0DymIjqTpi51uO2EQqiEBpBsDOhZ0PSlYj0nBEIkJEImFEIldA80g6hozwmO4AmBEAnpquAsQRlQCBUgDdHy0xkBepaohh4DEiETlLne+M5wz7MQJRsDPEFZkAcahwxIBBWiWlViNSZWY2I1ZnqQ6UGmBxKUAZHAhpTZkDI9yHyoZjfrCYEQCYmgzKkpn3OYqoV6EBxB7SALAiESVIiqn3MO8zRQCJVADxo9aPSgeUIgREIi0IOGhypQNPWQnqJA0QmB0DOnWWEFik7IhELoLaSH+BaFig7Q0GOAI3QPNN2rsNCkaVHFhU4oBD0nChpAgjLAETwhECJBHiRBJhRCJTSABGWAI3iCTBeBDKjgJQ4DHMETAiESehaaqkSyMaAQKqEBJCgDHMETugeav1Uc6YREyIRCqISGCpagDHAET1AHVLuWUpwlqqHHgAbQ0GOAMqfGV1iI+mIZkAnKgjzQOGRAA2gc0tSqKquxshorq7HSg0oPKj3QOGRAJbAhNTakRg8aHyqlkIrphNkJldAuUJRo6oHPRefInqteOkd2QiKoHZwGCqESVIj6jcPq2hk/OsAT6IGjB44euEwohErA+t4ZPzqAD5VSaPFAgaETCqFHsWtGXafFDuhKMcEReiS75s11WuyESEiEHkXfT0YvCibNPVisKJh0giPoOVEQCJGQCJlQCJUgD9RC0kFwBE8IhEhIhAzIMq0qyTKggs+RkAiZUAiV0LOgKXJFlE5wBE8IhEhIhEzoHjhVYxeUCQ1QD4IjeEJABddISIRMUAfsOqrw0lGizRMCIRKUOTW+xkJs7QIFkU5QFoLAEwJBhRgFiQYyoRAqgR44eqBNKwM8IRAigR44PlTbUvTBrpNds75cdbLrhECIhETIhEKQVh2CBjh3rp3gCJ4QCJGQCIgBUiRp7vHkRZGkExzBE5RTlY4EZUAiZEIhVEIDnNFbKpDkCJ4QCJGQCJlQCIj4OmNMzwLJzKl0Z0AkJAJzmpnTzJxm5vTUnRMcwROY08KcFua0MKeFOS3Mqb6MTqgsa8aCnTGmZ4FU5lTqMqAQKoE5bcxpY04bc9rYqhpbVWOrasxpY04bc9qunNYzxnSAI3hCIERCmQVSFUmqnFZFkg5wB8ERrpxWRZNOiIREyIRCqATm1DOnnjn1zKlnTj1z6hMhEwpAihSUOSnSAE8IBOW0Ca5o9HrGkw5oAClS3/xRFU86wRN6ifb9HvWMJx0GEiET6EGkB5EeIB6+HoiHrwfi4atOg51ADxIf2j+Gcl8+rgouneAIylwUBEIkJEJvLl5tVCI0oBIaQCLkVaca4nhVloY4AxJBz1F+NMQZUAkNoCHOAEfwBHmgFqIhzoBEyIRCqIQGkAgN6KaDmkvXkBxU8BriDGgX6PzWCY7gCT0LfWW1KtJ0QiJkQiFUQgNIXQbIgyTwhECIhETIhHJVsM5vndAAGgkNUM0FQbpKVAezTiiESlDmeuPT8aujEPVlNCAS9Bx5oC+jAYWg51QBqzGyGiOrMdKDSA8iPdAQZ0AmFEIl0IPEh0opzkLU2GVAJhSCTPemfEamSgLOyNQBgdCz0FeXqyJTJ2RCz0JU/SgydRhogHIQ6EGhB4UelEhIhEwoBHpQ+VApRVQhSikGJIIyd/6mECqhAaQUUR1Dw5UBnhAI8kBNWYIS1RIlKAPaBTo5Nfe1w6qTUyd4QiBEQiJkgjxogkpoAAnKAEfwhECIhG66rztXRaTmvgRcFZE6IRAiIREyoWehr/pWRaROaABNtQxwBE8IhEiQB0mQCYVQCQ0gQRngUMESlAGBEAmquSBoKFHNrgxwBE9Q5rKAhZgKoRL0HHmgccgAR9Bz1KoyqzGzGjOrMdODTA8yPdA45ASNQwawIRU2pEIPCh8qpTjULPWVc4JkY4AjyPQJ2ld9CDKhEHoW8gkNINkY0LOQVT/Nw0ALhEigB40eNHqgr5wB1578qlNMJziCJ0RCr5++2F11POmEBpBS9BXpquNJJ3hCIPQWom+moKHHgEwoBHnQm7KCV3NfGK0KXp0QCHpOFSRCJhRCJTSABGWAPGgCTwiESEiETCiECpBS9HXnqnjVXFTwEocBhVAJDSDZGNCzUFQlko0BgRAJiZAJhVAJ8kDVKEEZ4AieEAiRkFDBEpQBhVAB0pC+EF91oOgoUX3LDEiETFDm1PgqC1FfLAM8Qc+RBxqHDEgEPUetqrIaK6uxshobPWj0oNEDjUMGRAIbUmNDavSg4aHnqaJ9/aeep4oOiIREkOkmaP8wzrqp53mjAxyhZ6GvLlfFqU6IhJ6FvqBcz/NGh4FCqAR64OmBpwc6c2xAIERCItADz4dKKaoKUUoxIBCUuShIhEwohN5CqspaQ48TNPQY4AjyQL5JUPrCaFWg64RC0HOqoAEkKAMcwRMCIRLkgVqIBGVAIVRCA0hQBjiCJ3TTTc1FA4ymgpc4DHAETwiESOhZaKoSycaAQqiEBpCgDHAET5AHqkYJyoBEyIRCqISGCpagDHAET1DNBUFBiepbZkC7QCGwE5S5LEAhKtB1QiboOUVQCQ1wnkxWBajG5DwhEOiBoweOHmgcMqAS0JAUDzuBHng+VEoh4ToPIR1QCQ2goUdfrKvnUaOSjfOo0QGJ8HxO6avLVYGuEyqhddBzdJ7ZaUDnmQ3wBHoQ6UGkBzrPbEAhVEIDJHqQ+FCdMnSckAmFoMxFQQPoqKEBjuA7JEEgREIiyAM15aznqCWWg+AIeo7aaAmESEiETCiESpAHaiH1IDiCJwRCJCRCBnSlKE7NpQ8wilPBd3GYkAiZUAiV0LPQV32rAl0nOIInBEIkJEImyIMkqIQGcAfBETwhXBWcXSQkQiao5rqOKgT2LFGFwE4IhEhQ5rIAhahA1wHhIOg58iB4QiDoOVWQaCATCoEeBHoQ6UF0BE8IhEigB5EP1YllWjNSCGzRko9CYCcEQiQkQiYUQtcqfX0oBHaA7lAY4AieEAiRkAi9ELVQpajXARKUAY6gnKpAJCgDIiERMqEQKqEBJCgDns/Rckk+b99TOiGth6jD1UKohAaQtAxwBE8IhEhIBHrQ6EGjBw0e6HDVCY7gCYEQCYnQX3/66lTM7IRKaACJjpbgdJCqdl5WnaQ6IRGU0ywohEpQTnsvV8zsMKCPnwGeQA88PfD0QEOaAYVQCQ0Q6EHgQyU6WvdTzOyEQuiZ65sOq6JpB0h0BjhCr0YtMimadkIkJEL3QIsyipktQZUlBRrgCHqO8iMFGhAJiZAJhVAJ8kAtREOaAY7gCYEQCYmQARIdLZrp6NSiRTPFzE5IhEwohEroWdC6kmJmJziCJwRCJCRCJnQPtGSlmNkJDSDdGeAInhBQwdKdAYmQCeqAXRN1supZojpZdUIgRIIy5wUoRMXMDpBsDFAWgsATAkGFGAWJBjKhEOiBoweeHmhIM8ATAiES6IHnQzWK0XKaYmaLltMUMzshECIhETKhELpWaXlD0bQD9Fk0wBE8IRAiIRHUEk9oAAnKAEdQTlUgEpQBkZAImVAIldAAEpQBeo5ar2RjQCJkQlf/02sd/z6gAXSXwwBH8IRAiIRE0HPUQnT8+wk6/n2AG9fA1B4/O9MB6Yh0QjojXZCuSLcr3a95Gmk8t+G5Dc9teG7Dcxue2/Dchue267k93HamHdIe6YB0RDohnZEuSFek8VwpkBpBOxXoBE8IhEhIhN6ktIipiNsJvemm86ENIAUa4AieEAiRkAiZUAj0QJ9bWjBWLO6EXvhVaY90QDoirWf0lqpo26J12x5t6zTp1oNtZzog/bSkWeEeaTvTGelnNWoypYfZznS70v22qZF2SHukA9IR6YR0RhrPTXiuxisSRUXQFq24KoK2aMFUEbQTCqEC9F2kRUlFw5azaWqIMiATCqESGkBDFK1DKhp2gicEQiQkQiYUgjxQQ9cQ5QQNUQY4gjxQS9EQZYA8UOvSEGVAJhRCJbQJTXGyExzBEwIhEp4e9KXlpqNYR7og/Xx8n+Joip49011cRvr57D4Z1RQ6O9IB6Yh0QjojXZCuSLcr3SVlpPFcj+dKNfIJvfyKPJU29NWzpqjYCY7gCd1aXzhtin0tfXqgKfZ1gPRhgCN4QiD02uirjk2xrxMyoRAqoQE0VBngCPIgCAIhEhJBHqilaKhygsYgVe1DIjEgEbqBqoKXSAzQF6jS7Uqft0kp7ZDWM1QdEogqJxVIcqbblVYYyZnusRWqvvOgZqUD0gp3UzohnZEuSFek25U+D4hX2iHtkQ5I47kNz1Wn7y+JpvDV0pcHm8JXS1/8aQpfnRAJiSBrvT8oFLX0vaNNoagTAiESEiETem30ZZSmUNQJDaCBwABH8IRAiATlpwoyoRAqQR70VuDU2QfIgyTwhECIhETIhEKohAaQQAygB+f+P6UD0hFp7TVQOiNdkNb+MaXblT43EivtkPZIB6Qj0gnpjHRBGs9NeK4mPJoarrShqWqkDe38a4VQCQ3Qv0Lqoaz2AUQ91Dj6AGJCIVRCA3SFmOA6qLtVTwiESEiETCiESpAHqtF2EBzBE+SBWkqLBC3s9T7ucQlV87iEqnlcQtU8LqFqHpdQNY9LqJrHJVTNnxfPnVAJDeDogVZ7q9Ie6YC0lnqVTkhnpBX7onRFul3p6yKq5q+LqJq/LqJq/rqIqvnrIqp2hrSe6Yw0nuvx3PN6qkOg0BMvUOhJEGRCIVTAeT1VElyBLM3jEqrmYyYUQiU0AC6hah6XUDWPS6iaxyVUzZ+XUJ2QCJlQCPIgChpASzEDHEEeqIa1FDOgvw/Vx/15CdUJmVAICiZVieISquZxCVXzuISqeVxC1TwuoXpAJCRCJhQCPdBFVHJNF1GdaYf08/Fnu9FFVGc6Iv189tnQrouomr8uomr+uoiq+esiquavi6iavy6iav66iKoptHWkI9J4bsNzz+upeg2eIap9pb0FbcTr66jtjFcdkAiZcAX9toBLqFrAJVQtuEhIhEwoBIXcekED4BKqFnAJVVO86oRAiIREUH6qoBAqoQHO66mCwBH0nCSQ1yoqXELVAi6hagGXULWAS6hawCVULeASqqYQ1QmFUAn04PywUNoh7ZHWUFTpiHRCWh+5ShekK9LtSl8XUbVwXUTVwnURVQvXRVRNQakjnZDGczOeK31wcu7c/qI2dG5/cYJEyIQCOHe8qDpxCVULuISqhZoImVAIlaBPDHmNS6hawCVULeASqhbOz4wTIiERMkEeqH2fl1Cd0C6I5yVUJ8iDIvAEedAEkZAImaBtnk5QCQ2AS6haxCVULeISqhZxCVVTqOqERMgEeqCLqKLS7UrrIqoz7cYFVS3qIqozHZCO49KoFq+LqFq8LqJq8bqIqsXrIqpHul3p6yKqFq+LqFqPYZ3pgDSeG/DccwuvavC8hEq5kaYEuS1NGRAJiSBrqnVsum0Rm25bxKbbFrHptinidEIm9Nroi4ct4hKqFnEJVYu4hKop4nSCJwRCJMiDLMiEQqgEeaCWcl5PdYLG7CqQEgmJkAmFUAn6alCBnN8tJ+irQV3n/G45oXugN6ICUyd0DzRzp8DUCd0Dvd0UmDqhe6A3lQJTJ3QPnNqOvlsGyAO1EH23DJAHKsSWCfJA2W6VIA96thW/OkEeNIEndA+k6IpsndA9kG4rsnVC90DSpsjWCd0DybsiWyd0DyTVimyd0MdYRemIdEI6I12Qrkjr2b34FNM6wRH0bJWLD4RISIRMKIRKaIBwEByBHgR6EPQc1Uwf39SgyujjmyrBVYDrBE8IhEhgfiLzE5mfyPxE5icxP4n5ScxPYn4SSzTRg0QPUkO2s0e2M/OTmZ+uRRMyoRCYn8z8FOanMD+F+SnMT2F+CvNTmJ/CEi30oNADadGZbSnOme3K/FTmR4ozoAEaW0hjfhrz05ifxvw05qcxP435acxPQ34U+jrBETwhXdlWGOuZbYWxnllQGOsER/CEQIgElagXZMJzECHN7CGtM92udB+8jLSeEQSyFAVPS9K+Hs460+1K9+GIVLDHss60R/o5HJG69kDWmU5IZ6QL0hXpdqX7RVQj7ZD2SOO5Ec+VJmjkooDVqpGLAlarBh4KWJ0QCJHQrWkQoeDTqjGAgk8neEIgREIi9NrQIobOX51QCQ2gnj/AETwhEJQfNVr1/AGZUAjyQC1FPf8EjU96+E7TAa4TPCEQIiERMqEQKqEBGj3QRVRn2iMdkH62jrMN9IuoRjoj/WyVZ6Ppd9GMdJvpHqo60w5pj3RAOiKdkM5IF6Sv55bz6ssiUPk1QS+/flZ9UxzqhEKoAI0i+ubsppjS2oMpmmJKJ2RCIVRCA2iskOS1xgoDPCEQIiERMqEQ5IETNIDGFwMcQR5kQSB0D7T0otDTCd2DfBroHmSVW7+I6qyEfhHVme4XUY20Q9ojHZCOSCekM9IFaTw34blSox7A2xSIOsETAiESEiETCqESGkBqlFVBUqMBnhAIkZAA0g+tCyj2dEIkJEImFEL3uqhSpR8naHyggAEdxDqhEvSb3sp1EOsER3jWslpVjymd6Yj0s5Z70E3rx7POdEH6Wctq6z3OdKT7RVQj7ZD2SAekI9IJ6Yx0QRrPdXiuvjUUFaFA0apZNZ3BWjUtqKjRCZXQANKCvim5KTa0KopAsaETCqESGkA9fkCvDQUPKDZ0QiBEQiJkQiFUgvLThwWKGp3gCJ4gD9RSNK4YIA9UovqiqOdvCqESGkC9f4AjeEIgREIi0IN+EZU6Sw8nnel2pftFVOopPZZ0pj3Sz2ap7lh1EdWZTkhnpAvSFel2pXUR1Zl2SHuk8dyK50oftIBZNYrQeo3OYq1amNFZrBMCIRK6Na146cTVqoU+nbg6wRMCIRISodeG5gZ04uqESmgAfXMMcARPCAR5EASJkAmFIA+qoAF8j6z0SiekM9IFaS1uHYIGCAfBETwhECIhETKhEOhBoAeRHkR6EOlBpAeRHkR6EOlBpAeRHkhhtFKqo1eb4hd09OoETwiESEiETCiESmiATA+eCuPOJvAUmJkOSD8bwNkhnuoy0xnpZwNop82KdLvST22ZaYe0RzogHZFOSGek8dyC52rVVrPmCiBtmtJv5/psFmRCIVTAuRar/nAuuqo6z1XXEzKhECqhDfCHgkHbcyb3CY7gCYEQCYmQCYUgD4qgAdxBcAR54AWBIA+iIBEyoRAqoQH8QXAETwgEetDHMf5MZ6QL0s/HPydcn+l2pbsojfTz2c/5j2faIx2QjkgnpDPSBemKdLvSXYpGGs+NeK7Uxsk5aYpT1USVX+0gTRngCJ7QrT2n0p/QrXk1DunDCdKHAY7gCYGgAAh5nRMhEwqhEhqgHARHUH7UdUogREIiyAO1glII8kDFK8UY4AnKqQr+DPU4QTlV8UpLBhSCniN3FO9xggI+BjiCJwRCJCRCJhQCPWjwQAeuTnAETwiESEiETCiESqAHjh44eiD9CYcgECIhETKhEJ6votirVNGrZ1dQ9OqESEgEWXYC9BjFqE5wBOXACwIhEpSDIMg0UAiVQA8iPYj0IHpCIERCItCDyIdKXEIUeEIgKHNZkAiZUAj9OaEIGkCCNMAR5EEV6DlqOpKdAYXQnxNVp5KdEyQ7AxzBEwIhEroHUUUl2RlQCJXQAIo7G+AIniDTai7Sk6iCl54McARPCIRIUBZUJdKTAYVQCe0CxbNOcARPkAdFEAmJkAmFUAntqmDFs05wBE9QG02CcpWo4lUnNIAGKgOUuSpAISo4dUIm6DnyQB9KAxpAgpIOAapR561OCAR6EOhBoAcSlAGVgIak81Yn0IPIh55fQCqD8wvohEpoAI1WkhPoO0fZTpGQCP05yQsKoRL6c5Lq5/zOkQHJxgBPoAeZHmR6kDOhECoBY3vFsU7gQ6UUSYUopRhQCMqcuoyU4gQpxQBH6M9J6hgaugyIhESQB6ofCUqSoxKUAY7Qn5PVRiUoAyIhETKhECqhe5B7C9F5qxMcwRMCIRISIQOkFDkIZCAKIiERMqEQKkFZ6FWi+NUJjuAJgRAJiZAJ8qAIKqEBJCgDHMETwlXBimydkAiZoDbadVRhrqNENfQYEAiRoMxVAQtRsnGCZGOAniMPNA4ZEAiK3TkErMbEakysxkQPEj3I9ECCMsAT2JAyG1KmB5kP1YpLO8ERPCEQlDk1Za3yNtWCVnkHNIBko3iBI3iC4p9UPzXSQCJkAj2o9KDSg3YQHMETAoEeND5USlF6gSi8dYIjKHNZEAiRkAiK7yqCQqiEBpCglCrQc5ogEhKhP6cegkKohAaQoAxwBE/oHlQniIREyIRCqIQGkKAMkOkgkAEVvMRhQANogDHAETxBWVCVSDYGJEImFEIlNIAEZYA8UDVKUAYEQiQkQiYUVLAEZUADSFAGqI0mQUKJaugxoBAqQZlT4yssRH2xDIgEPUceaBwyoBD6c5paVWE1VlZjZTVWelDpQaUHGocMyAQ2pMqGVOlB40OlFGeJKnpsQCYUgjLXm/IZlar+c0alDgiEnoXmBYmQCT0LLQgqDTSAOwj0wNEDRw+0xjMgETKhEOiB50OlFHqxKOh0QiIoc1lQCJXQAFKKVgSO4AmBIA+qQM9pgkpogB5bdhzKTw8um+AJgRAJiZAJPcL/UAvp4SITGiAdBEfwhECIBJlWc8kyoILPnhAIkZAImaAsqEpyJTRAOQiO4AmBEAnyQNVYMqEQKqEB6kFwqGAJyoBAiAS10SRoKNF2EBzBE5Q5Nb7GQmyFUAl6TvegB51e4Aj9Oe4QoBr7easXJEImFEIlNIA7CI7gCfTA8aFnlJkXNIBkY4AjKHNOMOPPnpAJhdCz4E4DDaAdMwN6Fpx+c8afnRAIkUAPAj0I9CBUQgOc8WcnOAI9iHyolEKrUllKMaABpBQuCxzBEwKhtxAt//TzVi/IhEKQB70pZwmKFkWyBGVAIPTnaM47S1AGZEIhVEIDSFAGdA80lZwlKAMCIRISIRMKoQKqTKtKqgyo4GsmFEIlNIBkY4CyoCqRbAwIhEhIhEwohEqQB70aFaA6wRE8IRAiIV0VrDDVCYVQAdIQrT0WKYVKtIetXpAImaDM9cZXPAqxaOfdAE/Qc+SBNt8NSARtvzsEhQYqAdVYAj0I9CDQA+3CGxAJiZAJ9CDwoVIKLQ+ckaoDIiERlDknUIS0IB0ER9A+Qi8IhEjQVkLVj6LThoFCqAR6kOlBpgdXpPwTAiESEoEeZD5USqHVpCKlGBAIylwWJEImFIK2aKpjaOhxgoYeAxxBHqgpS1C0ilAkKAMKQVtQVacSlBMkKAMcwRMCIRK6B2dRSVAGFEIltAuqBGWAI3iCTAeBDPSCV/TqBEfwhECIBGUhCzKhECqhAc6dvCc4gifIgyKIhETIhEKohHZVcD339J7gCJ6gNpoEBSUaKqEB9C0zQJmrAhaivlgGZIKeIw80DhnQABqHaJ2pJlZjYjUmVmOiB4keJHqgcciASmBDymxImR5kPlRDD60ZKY710KhTgawTGkBDjwGO4AmBoD01eui5p+aETCiESmgA7akZ4Aja5aZakKBoBFklKAMKoRKUU1mToAxwBE8IhEhIBOVUjUIzJQMqoV1wxskOcARPCIRIKFeBtAM5bdKdE6Q7AxwBOW0uECIhETKhECqBOfXMqWdOPXPqmVPPnPpEyASUdTv36qpAAnMqdRkQCJHAnAbmNDCngTkNaFUtHgRHYE4jcxqZ08icRuY0MqexEljWiWV97uJVgSTmNCVCJhQCc5qY08ycZuY0s1VltqrMVpWZ08ycZuY0M6eZOS3MaWGrKizrwrLWiSYaoej41QmV0AC6HksjfB2yGjWqUYzshER4PifrE66d94CfUAmtQ5doHbI6DOiskwGeQA8aPWj0QGedDCiESmgTnOJqJ3hC6o56QSYUgjIXBQ2g67EGOILvkASBEAmJIA+yQM8pHa57wJ/gCHqO8qMj0gZEQiJkQiFUgjxoHXRX1gBH8IRAiIREyIDzhnAn6AaCCv66B/wJiZAJhVAJPQtBVaJb9QY4gicEQiQkQibIA1XjeV34CQ2gW/UGOIInBFSwrukckAiZoJoLHXTf3lmium9vQCBEgjKnxldYiLpV7wTJxgA9Rx7oVr0BgaDnqFVVVmNlNVZWY6UHlR40eqBb9QZ4AhtSY0Nq9KDhoe48FSkIHMETAkGmm6ArkiRAca4TGuC8B/wQOIIn9Cz0LzCnONdpIBEygR44euDogc5RG+AInhAI9MDzoVKKqEKUUgxwBGVOv5FSDIiEROgtpMfqOoXATqiEBpCg9M8+5657wJ8QCYmg51RBIVRCA0hQBjiCJ8gDtRAJyoBEyIRCqIQGkKAM6KaTmst1D/gTKqEBrnvAn+AIntCzkFQlko0BiZAJhVAJDSBBGSAPVI3ndeEnBEIkJEImFFSwBGVAA0hQBqjm1LelFGeJ6kLfAYVQCcpcb3wKdD0LUYGuEyJBzymCTCgEPacKUI0KdJ3gCPTA0QNHDzQOGZAJhVAJ9MDzoVKKvtLlFAI7IRMKQaYF57mKh8ATAqFnIZ+QCJnQs9Aj/ZwCXaeBBjhPaTyBHkR6EOnBeUrjCYmQCYVADxIfKqXIKkQpxYBEUOaioBAqoQGkFDkJHMETAkEeqClf94A/oRIa4LwUXG1UgjLAEwIhEhIhE+SBWogEZUADSFAGOIInBEIkdNNFzeW6B/wJnhAIkZAImdCzUFQlko0B7QIFuk5wBE8IhEiQB0mQCYVQCQ0gQRngrgrWSa8TAiESVHNB0K4SDedZzyc4gicoc1mAQgznwc4nVIKeIw80DhngCHpOFaAaFeg6IRHoQaAHgR5oHHKCxiEDHMET6EHkQ8+zoVUL59nQgvNs6BMcQaabIP3DeZ70EzKhEHoWegCQC+c94ILzHvATehaq6uc8AVoGzhOgT4gEepDpQaYHuk9iQAPoRokBjkAPCh8qpagqRCnFgAaQUlR1GSnFAE8IhN5CqspaQ48BmVAI8kC+XfeAP8ETAkHPURuVoAzIhEKohHaB4mEnyIMm8IRAiIREyIRCqIDzhnAn6AZ6MJyL1z3gTyiESmiA6x7wJ/Qs9FA0p0DXCYEQCYmQCYVQCfKgV2M8rws/wRE8IRAiIV0VHCUoAwqhAqQhPa7TKQR2lKi+ZQYkQiYoc73xKdB1FKK+WAZ4gp4jDzQOGZAIeo5aVWI1JlZjYjVmepDpQaYHGocMiAQ2pMyGlOlB5kOveyeeEAiRkAiaPVbNXfdOPOC6d+IJjqA5YpV1DYRI0Cy1CvG8d+I0UAiVQA8aPWj04Lx34oRAiIREoAcND01aD9YHR9J68IBA6JnTYDspwGRAJhRCn4LXmDxpYecELewMcITugQbBScs3GmAkLd8MKAQ9JwoaQMvGAxzBEwIhEuRBEmRCIVRCA2jZeIAjeIJMF4EMqOC1LjPAETwhECKhZ6GoSrRsPKAQKqEBtGw8wBE8oXugkd0Z6DogETKhECqhoYK1YjPAETxBHbAJCkpUy8YDGkDLxgOUOTW+wkJUtMmATFAW5IGiTQY0gKJNNHRPldVYWY2V1VjpQaUHlR5o2XhAJbAhNTakRg8aH6or7vR617mrEyqhXXCGwOpLIuu2q757wGXddjUgEdQOsqAQKkGF2OtHJ7IOA9cNWU/wBHrg6IGjB9cNWU8ohEpoAE8PPB8qpdAHR5ZSDCiEnrl6/qYBpBQDHKG3EI3JdVDrhEhIhO6BBsE6lPXQAEOnsk5wBD0nCgIhEhIhEwqhEuSBWogEZYAjeEIgREIiZICUQuOqM9BVI+Iz0HVAImRCIVRCz8JZ25KNAY7gCYEQCYmQCd0DjezOQNcBDSBBGeAInhBQwRKUAYmQCeqA6ttSirNEFWAyIBAiQZlT42ssRMWlCc5A1wHKQhB4QiCoEKMg0UAmFEIl0ANHDzQOGeAJgRAJ9MDxoRp66KvgDIHVAP0MgR0QCJGQCJlQCFJllY7u0jtBd+kNcARPCIRISITnc7Saq4Nbz7QONjrT/SFaMFIw7IRAiIREyIRCqIQG0LU3A+hBogeJHiR6kOhBogeJHiR6kOhBpge6Aaec4AmBEAmq6iLoz9HLVAe1DujTJBPUpNTYTtE5IRDUpFQ/us93GMiEQqAHhR5UeqD7fAd4QiBEAj2ofGgfnri+BcspTHaCJ4QOXhAJiZAJpYPacZejCe0ChclOkAdRoOckQSJkgp6TBZXQAO4gOIInBII8KIJEyIRCqIQG0NHyAxxBppugG9C6hYJhB/SxygRH8IRA6FnoW3xcPzz2gkwohEpogHgQHEEeqBpjIERCImRCIVRUcGyAdBAcQTXnBBklmgqhEhogK3NqfJmFmCMhEZQFeZALoRJUiGpVhdVYWI2F1VjoQaEHhR6UTCgENqTChlTpQeVDz5u/Vafnzd8nFEIlyLSa8nm/t6rxvN/7hEhQFqogEwpBWVD9nPd7dwPtvN/7BEfwhECIhETIhEKoBHrg+FApRY/Sc4p/nZAJPXMKflP864QGkFIM6C1EMTE9/vWCQIgEeRAFek4SNIAEZYCekwWeEAiRkAiZUAjyoAgaQIIywBE8IRAiIRFkujeXftTrYxlNBS9xGBAJiZAJhdCzoGgmBbYOkGwMcARPCIRISAR5oGqUoAyohAaQoAxwBI8KlqAMiIREUM11HW1SirNEqyN4QiAoc2p8lYVYK6EBNA5RlF7TOGSAJ6gQ1aoaq7GxGhursdGDRg/a5YE/NA4Z4AieEAiRkAkyXTpo6NGj9PyhoccATwiESEiETOha1We/vQ5/ndAAmkAZ4AieEAiR0JcUeyyeVyzrhAboHz8TlNMT+ipiVOnoOuABmdAra0AlNIBko8fveR3sOgz0758JgUAPIj2I9EBXCA+ohAbQMvEAepD4UAlKj9LzhwRlQCUoc7GDBGWAI3hCby49MM8fEpQBiZAJ8kB1KtmIaqOSjQGeoOeovUk2BiRCJhRCJTSA1CWqhUhdBnhCIERCImRCAUhQkpqLZCOp4CUbAzKhECqhXeAkGz3IzjvJxgBPCIRISIRMKAR5kAQNIHUZ4AieEAjxqmAndRmQCYWgmgsdNA5RiTqNQwZEQiIoc1nAQtQ4ZIAj6DnyQOOQAZGg51RBpoFCqAR6EOlBpAcahwwIhEhIBHoQ+VB9sfTFEu80QhkQCJHQTffVPe8kKAMKoRL6XNFZWX2mZIIjeEIgREIiZEIvxKwKlqAMcARP6DnNKhAJyoBEyISnKms20ivkdUID9JmSCY7gCYEQCSrREyqhATRcGeAInqD8qAdLQ7I6oDSkBwB6Lw0Z4AiyVgSBoHKrgkTIBOWnCSqhAaQhAxzBEwKhe9CXIb2XhgzIhEKohAboIxStOD3+CVe5eQnKgETQc5ygECqhASQ1A3pO+8qj95KaAYEQCcqpPJDUDCgEeaBqlNScIKkZIA+UbUnNgECQB0EgD1TBkpqiKtEcSlWJSncGNIB0p6oMpDsDIiER+nOqykDDFTVlr+HKAEfwhEjo3fms+j71OqEBihqFPOgRahM8IRAiIREyoRAqQOOQqrLWOGRAIESCikpVr3HIgEKohJ7Ts6P3uJMJjuAJgRAJiZAJ5QLFv2ozulf86wTlNAkCIRISQTk9TRdCJTSApGaAI/ScarCg+NcJkZAImVAIldAAkpoBjqCcFkEiZEIhKKdV0ACSmgGO0HMaTwiESEiETCiESmgACUoPF/BBgjIgEhIhEwrh8Zyz4p9yciafH0Ij6a6kv5LhSj6eelb2U1xGMl/JciXrlWwzKUlparL6zmmqO33nDCgElU8UNID0ZYAjeEIgREIiZEIh0INCDyo9qPSg0oNKDyo9qPRA+tJXgH3QgOUEDVgGOIJKNAgCIRISIRMKoRLaBVGDnL6E7KMGOQM8IRDkQRIkQiYUQr2qPkp5TpDyDHAETwiESEiETNBzehuNmr0d4Ah6ThHoOVUQCYmQCcppE1RCA0h5Bjw98Icc1eXDh6pEtw8PiIREyIRCqIQG0CXEAxyBHjw1SQOMHnQ7kulKPrXBK1muZL2ST23octBDcEfSXUl/JcOVjFcyXcl8JcuVrFfyelq+npZVjmqzWaWlCs8qLVV4roQGKAdB1lR5/SPIOz2nz6pMqIQG6LMqExyhl71TyfXRzIRISIRMKIRKaICm/KjNNkfwhECQB2oXLRHkgbp3kwcqqlYJ7YJ0HARH8IRAiIREyIRCeHjQzmSbyafSjOTj2eq8Pch2JMOVfDxV8tADb0cyX8lyJeuVbDP51JuRdFfSX8lwJa+n+etpusLcySHpRV+w8gqX9X0xwCfpxYBISIRura9EecXO6nowr9jZCYEQCYmQCb3svbyOldAAfZF4giN4QiBEgjzwgkwohEqQB6r2fBC6B1oZUOzshECIhETIhEKohO5BUMFLUwY4gicEQiQkQiY8PNBCu++xtzPdrvRThGbaIe2R1hNUtVKTvs7jFUI7QN9GmilP+jYa4AmBEAmJkAmFUC/QkbK+rzR5HSnrtZqjI2UnREIiZEIhVIJy2ruejpSd4AieIA+aIBISIRMKoRIaoI9dvBYv+smzD3ACTwiESEiETChXnSogdwJqWwG5ExzBEwIhEhIBWqSA3AEaoQxwBOVU7YBalKlF+dSiE/pz4mmgAaRFA1Si+k2CGuYUCJFADxI9SPTg1KITGuDUohMcgR5kPlQio1UjBeROaACJjBYIFJA7wRMCQc1FTVkiMyATCkEeqI1qSKNpC4XdTgiE/hx92SvsdkImFEIlNICGNAPkgVqIhjQDAiESEiETCqFeoIBcrxUghd16LeAo7HZCIVRCA0hdBigLReAJgRAJiZAJhVAJ8qBXo6JzJziCJwRCJKSrghWdO6EQKkCCojVPnTw7SlSyMSARMkGme+MrkYUo2RjgCf05WowpGtwMSIT+HK2LlMhqjKzGyGpM9CDRg0QPJCgDIoENKbEhJXqQ+FAphT5KSg6ESEgEZU5NOeMLpZSD4Aj9OVo+UUjthEhQIap++I1U+I1U+I1U+I1U+I1U+I1Uzm+kEwIhEhKBHlQ+VEqhWW+F1E4IBGVOXUZKMSATCqE/R+s8Cqk9QSG1ExxBHjRBf46m2hVSO6EQ+nM0Oa6Q2gESlAGO4AmBEAnywAsyoRAqoQEkKAMcwRNkOgpkoBe8QmonOIInBEIkKAtFkAmFUAkNIEEZ4AieIA9UjRKUAYmQCYVQCQ0VLEEZ4AieoDaaBQUlqqHHgAbQ0GOATKvxZRaiZGNAJvTnaJ5FIbUTGkCCojkjhdQOA4XVWFiNhR4UelDogQRlQCWwIVU2pEoPKh8qpdDclU6e9VpC0smzExpAQ48BgSBrKl6JwwBZ6w9tkgDNoDd1dC1eNHX0AZUgD3pz0YmwExzB4znq6ONPIiERMqF/gfnTQCU0gNZsBqAMFPd6ZltxrxMyoVvrkcReca++ntDzoyUFxb1OCIRISIRMKIReopojVtzrAPX6AfLAC+SBMqder9lwxb16TXPr3Ffd+eB17uuEAnj2bddOd9S3Neej8FivWSqFx06IhETIhEKoBOVUFSwJGOAI8kC10McU4ZCjXRyCZgkUHhsOlc5THFw7y+0pDhdUwFMCnC798j0I9oJA0HNUvCURcgcVVZeACZXQOijbXQImOILvoIfWQIiERMiE7oFmVxVFO6EBulJMcARPCIRI0HOejS/0iFina+6C4l5D3xwRFPc6IRG6132uNvSjXi+Q11nQAO4gyOsi8IRAiIREyIRCkAdV0AD+IDiCJwRCROl4PacJKqEBwkHoz/Ey0HVnQiBEQuqtVyUaMqEQKqEB4kFwBE/oJdrnc0MPj72gECqh57RPhoYeHnuBI3hC741ZbSdFQiJkQiFUQgPkg6ASVbuWugxIBOX0/E0hVIJyqqIqB0E5VVMunhAI8kDNUrozIBMKoRIaQLozQB6ojUp3BgRCJCRCJvSyTqrg1ks0Kgutt52kamyeEAiRkAiZUAi9TqPKurULnBRpgCN0D/oMU+jBthdEQiJkQiFUQgO4g9Cf0+eIg0JqQ98CERRSOyETCqESGkCKNKDXaZ/kD4q8nRAIkdBzGuSoz4RCqIQGCAfBETwhEHpO+7HHQZG3Eyqh57RveAmKvJ3gCMppEASCcqqql1YNyAR5kASV0ADSqgGO4AmBIA9U9SkRMqEQKqEBpFVRpZPZqjJbVWarymxVma0qs1VltqrCVlXYqgpbVWGrKmxVha2qsFUVtqrCVlXYqipbVWWrqmxV9WxV//t//+M//Ot//2//9B//8t//7b/+x7//8z//w//x/87/8T//4f/4P//ff/gf//Tv//xv//EP/8e//a9//dd//If/7z/96//qf+l//o9/+rf+3//4p39//OnD/X/+t//78d+Hwf/nX/71n5+p//2P16+P9z99His6fv48OzRMEw8B+MOIe2+kPkf33cTjQ+IyUN0fBrzhRb/0T0483lNvTVgZeZ5oNWw8Dxh6m5H43kh8zvx3ExFelPrH79P734fnG7n/PjR/OZDjci60YqhchNDeV0d5b+QZYXDaeC7ow0RaNRH68eHKyWMVAib+LItmmAhplkW6DJS4aiC70TAfq17TwEPe/myWRrt8Hhs3CjM9PH9rw1sl8RzWnCVRwlsbVmHWNIviMfnxtjCd0TJ9XzVRnT4E67IR/Z820t0aMTPSLgtHfZ8Rw0bKYdTJI3nZyOVPE9Wq1udn9Vmtyb81YbStUkalVipW9ssW+l17spDdWwveaJ3+mLL53Bs1bbzUqDcaZ33OfMuJVt47EYwq7fvlVKWPwryad3Hf1Ud5Xx9WqyjH0JtHsr0z8eyK71XvOWd2ql50b02U23Va79dpu1unwXiJPLrmqI/HTOf1IgyhrGekb+89M5Lcu4wEo3H2GWu1rOOtAVsqWp6NwoV3NRriffW2bMQe+qVRwWPB763qhWy+ifzsIigN79qfNqziqKNG8pFgoa43jD47cw7USnrbMILRPFuso30+5l9hI//pRzT8eK79j8b1WBy/KvYHdVJGZ3+M2crbOonWoLOmOdR6TNtfNvzLeNGQz+cxnZf2xYR3ov9zsBXj/dYR093WYeclH3m6kVN7nxdr8Nm3kp3CgcHOoxP9aaPebh/tvgTa5dHiNXxsHDK9lEdy1gu2HPMFW1geLzYsJS2lzvKoV2t/jMf+tBGsHjNf9NGjnf5lw1JTPxvIM4b2vY1kDWTDUNNnWP17G9n8aJ099w9FrusNZFEKU70vhandbep2xbZRGDFAxl4LNFuNtN+ydb4m4/vGkf39is3hdsWaxdHmh9JjWPq+jea0oTjyhuIo94vDHITNbv+MEHjvhtFGUz8JVeMwh9fTX13W8qPlMEeDx3s/itFKc55+5OLey6Ap6rlHJalMc+AI+0WQi2El+9lr82PZ470NawjTTwJUQ3Xo+T+yUa5hUMUo/S8b2foUnm+58vjnKlX/Mi9gNNQS5wuqJJ/e2zDUNFz9Firmw59KWCwtde3qcviIfLVRjaFp8uO1kMLxnYU2B2Iuvc+H1br6SoBMRPe+hdZgfTvFmZGcv7RRyvVRXvx3Nur1YV+P9zbsPluOOvvsY+rmvSe3P59MP4qbE3nPU3bfDwhrsyaqawpzorqW4807v93+gDKV45qzjw0+vOak+fvK0cJ95WjxrnK0dF85Wr6rHKaFJeWwW2i9VnNKS+/7W2t3e4rVulI/qvEcMfj4Xa9/jFzm6KfG9v7Tup/J+7Zqw/XtxGlv718moo5wt7/ZfsS5nPHcQPzWD3PGosyW/lhQrW9nLPoJv28dSaHNedI/VP3VSLHkY86rxfqHkbhu5LHaOLtM5FLXX0ba/bmTfgbsvRb/oVjrbCLZuy/rpt8ofBqx6sZZX0BHnXXj/pjF8T/xpF7jdZ8MT5K1mtnmezv+0V5fPHHZWrWaWhJCLd8ZWS4Te51jtam1X21qz9i2WTf1SxnQAe7nvFQs741Y60/P43fnlGHzrb1VRsuTfrTdWcFWz/HW+mg/XeucdvxjZHa8GDHaa8kzN6X8MZf7AyM1z+WCmv/4Jns1UjY0NWsNZ7GpmT04YsTrjM5nLTv4Hj87VuayYcSZ776pJQUTdu61RMwlqcX3uClHc2HskSpfdr4wZw7DY/7uvZFweznf9iPOEfxjzisYfpizVNeMSghs8O4HRnrYoWrmqIdhxJrULXOyqxV81Lx+TDhrcapHCZ82MJsaj5/4US4/sAbytx+mtpbZaw7Ouv3liRVj4Kaiec7Y/9VrzOWpx8opvr9zetdvrPWp56EjUwRSNDzJZitpVyspRsGW+5+tzlqiWv1u7Yf03vtwdem4/+XqrDWqtU9X28TSt6v9Ck9zquh5NsL7F6e1RPU8Wn+2ELywXmNRrCWqcE2NHO8jMFwyZ//dDEbxJWJ56eXlmyxNPJqfo4BHOrxdYTKl1fsrJiU6Q5/Tjs+sfP8zy5SROkM0n1tW3suItVT1WN6J1wQrVPGIPzBSZhXnkiwj1tTV4eaK6oERZ0wvL2BruapdIt+egS3vjVjLAHn24Mdcb34vaNaCVUpz8T+linfWDwaLeYYNPQ+CeD9YtFasnvdPxmvpHgX7okfFnGQNaGr+vSfWmlX07goeYkzwX3FQ/r6oWYsKi6JW4gZRK2mLqJm9L1+977Eu+L73ldtLAna3WR1MWAtXy4MJa91pcTBR3YbBRPW3BxOmibXBhCmsfdPamDXie+Jl7rhaMVVpxrukRE1cf1/pUg/58RjGv39fWUtXz2OFpiY247um1g0tte5oqe1+S207Wmq731Lb/ZZqDs+imwsUqRlfvtYCVoq+zJaK8vjrNdPy/ddMK7dfM61ueM1Ya1g/ec1YMnJVTvhj6upFRvoJtHeHVt5aP1ocWmU7fG9OXXlk5nWc2A97NYZWWIw/QjHMpPtq5K3pq1U18tYq1Joa9YNc76qRtxay1tTINrGkRnZbXa0Xa8/Ucr1Yy1iL9WJumlqtF2sKfLFeTBNrbwlzHOFnTFD44zviZRzhnamsV0xiYBDeX/XSNrQQf2xoIdYGqsUWYi1gLbcQaw/VYgsxTSyOeM1OF+biFaORX7+IvLcXW/9xrEtwEe3FgrmTa0ZtPF5T+DBLr25YsYBHuT69W35rxC4QN0fNJXMw8log1nTE82r1fxzLTpWevOylsmbh0zGjYRD58bcJf3+iqMvE3Ykib229WR7NhHR3NGOXyOIXnjf3VC194dnlsaqHYcN3lY+3v6v6icW39TDe/q6yTayNZMz2sTp0j2lDY7dWrRYbe9wxXN6xZuXvr1n5HWtW/v6alb+/ZmU3stVPqrTnkyrtaCNpxydVuv9JlXZ8UqX7n1Tp/ieV9favc+GbG3D+evube6sWJwC9tblquX1YcwjL7cPcX7XWPsztVavtw1yuWmsfponF9mENMXO4Yqya0UKsxarn8XtDiBw8+duI29DMyoZdAb5s2Bbgy+19Ab5s2Bjgy+2dAbaJDd+HOWEoE95/DlkrVTHPr7vIIxn+GlRZK1UuznhAFzO/VI8XI1ZbbXPb6/OQzatM2suESDU3B8xt4s/L2a5mFl9PygjmivWcwM+M9nqZr7ZfEjPc+nkW1vvuWxe3VpvTO3XDgqavG/YD+np7Q6CvG3YE+nZ7S6BtYu0tYfa8Y67wxCMZ3+7Wbqvlnmdtt1rueeaOq9We1/KGnme+OfttZ+cQvhhdr+2YWW0bZlb7QdJ3u144bs+shmPDzGo4bs+s2ibWup79lrj20Efsynltq+HYEF8VjtvxVbYfy41sw3RVcLenq4LbMF0V3O3pKtvEWiOzBXGxkbkN01XB3Z6usv1YbWSu7mhkt6ergt8wXRX87ekq28Siklm6jp1jHrvxX1/dwW+Y8A7mVqvVyjVXqxYrt+yo3Hq/cut9BYkbKjdsWP8PYcP6fwi31/9D2LD+H8Lt9X/bxIae+8f6fzYq12pkR5wLkUfhuac/+A5paZ7fehzx7QxAsFaq6gw0qzi8769XnbVSleZ+hNQYI/ZSHHFHM433m2nc0Uzj/WYa0+9q0Gozjb/dTI82T0ZyKNPXz+WQ7jfTdL+Zph3NNN1vpmlHM033m2m630yt1pGus7dSCO/XhkPaEFAd0o4vqXz/Syrv+JLK97+ksv/Vyo3uOhQtWF0/7/iCyXlH5Zb7lVt3VG67X7m3F1PtI6HTjNfJ+e0h39bJNdf585Fbmf86zdncTHXMMx6eV8FcRl62qtpGGDsQvGHEPKBh6Sz8YJ8AuHIYvmli7eT0UO4fnR7K/bPTzW1Uiwfir9dKMWpltXnwXpYftTE3TxB93u/93ki1j6deukYjVPNM1cWT2M3spDwPrclmdsz9/3Ot7ZFEg39taaaR6mdwaY3NMNLud15raWmx87bjdue19kGtdl5rcWqx85qfH6udd7lWjM5rNo82A6lL4/n0fxWIuTNs6UaLYC1MrdZtu1230VqVWqvbaK1JLR/pbhpZPPY7WktK61cgWF9Ta2fc2xo0z1QutX0pZNW1S0DK+w3q0VqXcilehzNh+fP1MCJb3K+Tux/d4v2gKh73JTW625JqmljrdtHdl9TobktqdBskdb1Wvh0PtXkwxENq8vvm4cqG5lHvN4/bqhzNVanF5mGtKC02D2sD1XLzWK6Vr5vH9Z18HPW74XK8dtk8xNtoY9aq1OINZ9FvaKf+fjv199tp2NBOw/12Gna0U3+/nX5oHXdnMB7LLtMCt4L9dfeRdSFV9nO3YI7BeO1bu6eam4HLHJG9vvXNE6HmCbGpYYYsvfQ3a+9UDvPoz/yovsuN+noDkxWTOmuFS6ePubcXE+7+bF+01qTWZvuitSK1OtsXrTWptdk+28TaceZmVq7btZ63zRtGzMGpv6YvcNLtD43kq+vX9qWRHlQlI8HX90aSGeA3vyxj/s5Em2eo8WisH5lwB47XyEb1mnf1xDyHdH8c8N5+UqbXHTkhfVu7YbbV55nV3xnZkhs3xw7OxfplrylzFOOL1Xvti6k2GHH5mjnMpX5p5LrkxpVmiIC9O36p11gmFnuNZWK511hLU6vtzCzTdilR80aZmi/edN2ClHio+uuL11qbeswFD08K7wl17rVIrCi/OpvIY2oPI5FavhqJ4C3xOhKx9k+5I103Bh6pubeORPO4v6NWDKw4Oksvo9ViXqZ2XMfvP9LtWzPuOv33kf7eTIGZ8rUZf21heKTT12aug80f6fytmTZjZZ/p8KWZ5z6K+f75c//Pz8xc03CPdPvazJxpeaat5me14sc/Be8ywxtrd1XESPSPUzhLXjeSjqnd6eDU4l9G0t0Z2w9+tOsmPe7B+1FmrluoHiNbKzPWXRaP0fk1oG3VmE+3fMnluA7BdeW7DOXr2PZc0rdGrovGcqUsvBqx22yOV5vNVn82t1m9mCnfmblmtDgd7l9fjNaugujSFQaHE/H/NpJvN3zTDz/f8pFq+7cf9Zf9mAcLPZL5y0IN85KtyPv5/jZiVS5e8RxOvthI1h4rd52p/0jmb43466hkn741cr0HE94YPzOSr1d7Dl9mx7tr0dS1DUZ4rMfPjMQZC+tjLN8amZdrPJJGg/2JrL3Xo2TttnLxeo0+0vntbcXu9hUsn/yYd2090u34zki/z+A04jgT+yMj13170WENNn//1ZDefjUkaxEl+HZdo+Ti2+xYJsIVXsOrtl5NmMGX04vH0lP5slCvaXbLiDfPXL1ifN4uOpgWNuWkXDnxb9uYrQD1ujgQH3E/kxHslC7OvTdiLV0slshhn5c0D23z4fguMyGmGdQWjZFR/3L4zczAj+S+fUuk68q/VIyBgLW6tSEzPl+6nN23b6tyZYZ3YtwwYngS8t3+v9xl0pf97jHhj0Dh+O3gKrT/dAHjayMpfTny7adcnO2s1W+Hz3M+KYb49RjcX0H+wSgTa4Uqt7l2kBml9xMTdWpArsV9ZaJNTczNv++87v4XiWlkMSumiftZWauTD/MJ897y/MeZrT+bTwjXfAKv93kxkqwFrjUVMpfIlpT9Q07mQZjPKv520mkusj8mnYJRHPeHqOn+ENVa+9hgYrVWrAm4XObE5nOmyZqAM80cs409PmJ4T+DPzLj50n1+htdvzVzn4DzS7X2AbbJWuB4eXN9m2eX2rTfhmoHOoXxfNtfVow9v6vdm1jL1oWyWi9g69ajOeTCul4Vy/EASroOTkvfvp22TNTWx+Ao2Tay9t2wvVt5b9urw3K3T/LcLzPma702316gtE2ZwyFpGTBNrGVkMUbFM2JF25Yq0q19G65W5qvBItnc2knk+YDyuk3341nu1YW7BWooHTdXc0roSD2qaWIsHTeZdVmvxoMmS0rV40GRt8lmNB12vleK/ax1hDiU8Q/5+ZCPN7aiP6YTw1kYzz0m7VhVbbl/amLcumjbs3rK06Sm12xtaTROLLd1crnLhupIemxVfW7q592quxDM2Jv7Ei7X+lo/b8dfZmn7A+PIxvHRv+9sPjOQvjcR52HqOWID420i6WS8f8jIXAB/Jb/PiZxPLj57/rZHZXR7jyW+rJsybuZ/x2O+NWLumWp170Rpb2uvI1jayuE/QNuJm4GJ7hrN9Z8TPEMrGDf4/M7K4YzFb5/Gt7ljM7nYYgO3H9c3bCtYP//Zj2Uj71ki7xqgtfWfEHUe+VvGPapkxq3iuErUY6reNLV6NDREWPzQyj6J/GHnfAX/wBn+7/ymbxwOuTJx9GP1PLUk8qfwvL6yI7sXtYLaRflzvOVPtq2HEjMaeFeNLfJ8b856BtW+IbB8PuDKyMk2sjayydTTg6pjGOhtwcUwT0v1viPVaef8N8aF15EuZa/zKRnAzHvDxxinf2jhu2wjX0CowtONHNvI1z1zf27BvoFr6HvpgY+l7yM5LvBpZzPW+jS/b2GPufh5HE+v7ujV3t+TrdVm80etMR8qcRg2P18R7R9qGym2/XLnFXXkxOm4ydwtccfV/3Pzys0K9zvSvRiuzzgdcu/o5W0f7uXbNtLdifIpYfsS5KzWiefxdHOY7ey4RxcCTNV7f2eYVVmvzfjndP84i59vHWZgmFt/Z+f5xFjnfPs4i5w3HWazXiqGnZutYm/ezbazN++Vc78uY3dKX5uxyud9Ky/1WWvztObts7Z9ZmxsqG/qKdQTdYl+xDvVbno4xjSx+UtpGVr+QTSOrE0OmkdWJIbtMFieG7DJZnBiqG46yyvX2UVa2H6sTQ+tG2rdGFieGLCM/mBiy28ninM66OL8f2rW70dT2iCrGa1TmwpdTKdFdO5+tqRT7Dqy10yxz23CapZ2dNgMhkzu8kZ2yIzv1l7OT3DSSnsfIvMtOMa+vut3SUpxj95RaNtwwA6rnt4xn6G96MRHuqqLtxTyjh18yf3thbgBciVQzTbijhutyQsZC/shIu6KfjvZ2u80nI9d2G8dD4H5SqHOn2p+7KV4K1Zom32Di8dXerjdEdW+zYhtZrBnbyGLNfDCyVDN2z834FOF+8deea61SuXJNIZTC873bi5Fyu++aflxxVK79cf18+4mRiPmQ8KWRcu2Wa/wWeDXi3f3XTDEPC1x8zZjZ8a7OaRXvDyM7VuTO40MS0beuvaviD0aukzEyD5N/NWJl59rD6xOjs//KTjHbyTwn66jvbysofsN9FsVvuM+ihNv3WZSw4T6LEm7fZ2GbWDoEzW4hdQ6dw+ENEbDWqnI/4V2ORFza+nr7s22kuOu0h2QZsSL4r0XVwJ3vr9dzFOsmq3aJQONOgr+NWG118bbEYh0cuHZbol2s+SrWjMn3v4rVXGuqs6Ed3N1Vf1AeqwJg7WZaFgDrJqpFAYh5gwBYC1aLAmCaWBMAs8f0mxTHcub7S9dLMtvpdWpoYmNfF6JHR5vLu/4w3rzJ3FZZ4hxacRbutX2Y+6pWW2ra0VLT/ZaadrTUdL+lpl9uqXFuNQspvr9Xq5jrVauybN1ntSrL5m41XsCS379jrCUrl9pxjREP7FT928yGO1dL3nDnasm371wtecOdqyXfvnPVNrHW4O211cV6KRsODi7l9sHBpWw4OLiU2wcH2ybuj5n/vIfSv39VFaudXjvtfMCe17/rZcdXVdnxVVXvf1XVHV9V9f5XVb3/VRVMMZyTq4UrX38Nus1LreZ+hBBhwr9YMDeY5TnnVTGv4tKrG+YnVbm+EDnlnX7wcfeYEJs3WmUG8PxVIOZZvdcBt39svU8vx9tb91GleaZgiodhwm34yLQutVr+yGxhw2jGutdqcTRjlsjqR4S1K2rxI6LtGLpb61XLemjtrVrTw2qtVq3qYbV2V63poW1iTQ/N9rE4dK/WpVarjb1aqzxrjd32Y7GRVetSq9VGVo96v5G1DY3MWqBZbGSmiQ2NbPGTqrotn1TV7WgjbsMnVXW3P6mqKzvaSL3fRu5/Upm3Uc71kPrH+bt/vv2rtVi1OsdUrcWq5fbhw4b2Ya0zLbYPaz/Vcvswt1SttQ/TxFr7MIeYOVybCJrVQqx3/xGunSp/HCL/YsS82mq1mdk7qhabWfAbmlkIt5uZtalquZlZHyKLzcw0seH7MCcMZcLbz6FqLVPFPL/uIjch/jWoCma0+XUscuSN5cefYRHVWqby7drgcWD97/H/X4xYuhqu65giJ0TiS6+Ji+cq5spTkOoPXhL1inv547qEV0fi/emdGtOG7mutVS13X2uhabH7xrqh+5r7ota6r721aqX72j3v8MNGPNL7b/dqbq1a7XnWWtVyz7PWqpZ7nrVWtdrz7DfndepX8MXoemnDzGpNG2ZWa9ows1rz7ZnVmjfMrNZ8e2bVNrHW9ey3RLz2vWF31F9t1VyrWp1JyPn2TELeoe+57mhk96eryo7pqnJ/uqrcnq76IIiLjazsmK4q96eryo6piLJjuqrcn64qO6ar6v3pqnrcVzJL1484t/LxWti/Xt11w4R3rRtiVWq9HatSa95RueV+5Zb7ChI2VG7bsP5f24b1/9pur//XtmH9v7bb6/+2iQ0994/1/2xUrnnRdpwLkUfhpuQffIe0NC+DP474fgbAWqmq8/LSyh20L6+6Zq1UpXlCTMJ5BiG0FxMbmmk7bjfTdmxopu243UxtExs0aLGZtuO3m+nRrnviUKavn8vtuN9M3f1m6nY0U3e/mbodzdTdb6bufjO1WkdyxwxSCeH92nCzlqhWX5XN1R2Ve/tLqvkNX1LN3/6Ssk1smClz5bpJxer6fsMXTPMbFlObz/crt+yo3Hq/cu8vplpLy7HMpfJYeHXzTzYQxmvbXizx/QbCFsy51LUNhM1cotqxTx33MGRXrAMZTSNX5YQYvzRyNficjvalkTD772PJyr010iwRWK+d9tu1k2bQXc7OyI41BfkMEbluRm3u3c7MT0bCdTNqQxThqxHr8p08d/AW3pj5d3asE838de7FH9HML+citGierTaHZ/5wbw/wa9ZC1doRby2aU//uulq1xLeLEM1aqHoMUa8400cabS3/xIyL1/7qRxcob82YTbaEmaUSotFkkzVrvnbCa7PXq5ZOi2v21qqVc7hME2vncDVzqWrtBKxm7ataOwGrmbdNLZ4Wt14rxagVs3UsnfBq2lg84fWTjeO2jbUDPFtevWkifVemiyfNfrCxdNJsM1ep1g4j/WBj6RQ/Oy9xHokQonfv/Wi/7cfSibfrNr7sc4sn3jZrS9XqibcfGvtiAwm/XDFrp9U2a5Vq9bTaD44snVbbrGWqxaGMtcK0elqt6cfaabUfB6oZA9V3Fyu2GjaMduvt2yrtYWqZyzKP5PuGaq1SrY6Dark9DrJMLI6DrGDX1XGQGSu3Ng4y4/ZXx0HLtWJosv0RM9/ZrrX3Ywd7eWlNCs2vmMVQKtvINWn2SLrvjLjjOj8omt9TlicpXGdE5u8/ynCkWcNyxk8/yq6ou8cHWjLMWFkK7SoXl78slzhvvfXxjxNw6/pH86rC259DxyUD9auu85hDmE3WvX97Pw9vu/vWfNgo91+btierpWrW7jxs8lHR4ctW747rDL7HOsnXUxG4ZNa58nXncf7A+MroPMEKSPZzMv965byeFGOfjBavW4nL2zMF3WFer7R4vpptZfEETHNNYfXcOnNV4XDX/Fv49oy2xYg1d3hzlTXMxYmM8dHr4SjWhAQieD0Oe/3ZIW1l7tL2xVgleeQm/LYVl68Z8IxVgR9aKXMy/jHb4i0r5n6A2f9i/tIGLtBN9Usbjz+9ZllzsqxYXzgxX6c2N6y3tJ8UbLvOa2zeam9WqOZ1kl6q9ctD8FxxOOPAce755Vhu87y27OeqzR8nDNcfmJjDx8xm8teRb+bRc8e12oKx8GuJPF5yVjtZvtp8/Zyz8j7M4OGMvZSV5tfwY04/vnfGPi8tXUcdMJzlBybyNW+TOar+iYklpbZPwlo6s8E0cTXWRzJ+Z2IpI+bxRKuvnLLlZWF/ue2wsv7KMa0sv3Kshrb6ylm8s9185aRjxyvHWoFafuWYBbv6ylk+dsXUtJS3aJp9fMuSppkm1jTNNrEiBR+OCFnRNNvEkqZ9MLGWkXZf02wjy2pk7XTaY2Vd00wry5pmb7ta0zTLxqqm5bpD06xNU8uaZhbssqaZgxIc03/5kV4nkqwtT/HavxV5X/jrkWX2ER3LX8Plvh6Zx2usdmO/pQOW9ttW1ruxaWW5G1d/vxtbNla7cfU7urG1CWu5G5sFu6Mbt3l5YEvJ6MbVjAy/Nj/6w73vxjHt6Mbt9qeSff7Bajc2jSx3wBZ+28p6N25bJrXahkmttmFSq22Z1Go7JrXahkkt80AG3661u1b9+47szFuRjnnXY/zj8q70k7OMVjuyM/dVrXXkEDd0ZNPIahd0R/ltK8sd2bay2pGduz9VYNpY7MjO7ZgqcG7DVIFdsDs68mM1aZ4m7JozOrK5WaPOk2JiC+F9R047lpmceRjgWkfOG5aZbCPLXdD/upX1jmxaWe7I5qatxY5s2VjtyOZq8XJHti8HXezIZsGudmTzwLYwl4tdKFxmOl5csU4XjDMOLnLLR/E/sJFmgAMDrn5oY4bAJB7o/SMb+bh2XB0bbKRvbeTr/qpvyyPP8shfl0eZeSlflwdtfFsevG312/IoszzK1+VRZ17q1+VBG9+WR50SUsvXfsyz+Gv91o9+lINU9evyoI2v/Zg3RzZDg+zjHheDHG0ji5vGHqsq1oAxt+utmUwr1jxsLv+JLr8eUWBnZzE20TSyGvhpe7IY+PnhmLWl1RjTxNpqTL4/jWuej7Y62jSNLI8T869bWR9tmlaWR5s53B9tWjZWR5vmjVzLo02rtS2PNs2CXR1t1g0XjDxcabd7j3k22GrvMY0st/vif9vKeu8xrSz3npLu9x7LxmrvKWlH77GOGVzuPWbBrvYe+6CwazOqb8hPe3WlmvtjrnstHG+Cei0Uc32JO5942vDr9I+lBjnOa35T+NLE3GKTa/3WxDwN5njrxYez12bcTDr4XfFXiVpTAmnuE4wMkbxhpL0zsnwcXTgOo5VZK1wuXlfKx1DfZ8cKSMrH3NiWnSuGEaupPhr53OrzGHPXLWZ42sePplvaVSzGKd32+XjXLEdzb0f1j+zku18G9tl2i+9Q28jy26+137ay/g5tOwIJ/HE/kMC0sfgONW0sv0P9sSGQwC7Y5flOa57/CP+5Vr/GOHrzpqx4Hdjv33bihw3zBKK5Kcxz3uRll6p5TN3qcNq72+HO9hFzq1Lgd3xGehd/28qyFNhWlqXArOVFKbBsrEqBKzukwB/3pcAu2EUp+FAoc4jS/NcFO8+6aSXdrxzDht13wryH9NEV3ZdG/HVxRzisUt2xtmUa0VTvOdiK9UtXHtMIs8W6mr61gjFbaF/7kq7NrgkHE/7USr7OJajt6xxd3Sd4K0fh/pKsaWNVl8KOJVkffr3ZhvlJ60Iq3xbKoi6ZNhZ1abFyTBvmGHQxL6aNxbwsjoUtjTU/VVY11v5oWtXYuKOxxi0aG7dobNyisXGLxsYtGhu3aGzaoLFpg8amLRqbfr3ZLmts2qCxaYPGpvsaa8+Vr+XFtrGWl9U5e8OGvaSyqLEfFndWNTbvaKx5i8bmLRqbt2hs3qKxeYvG5i0aWzZobNmgsWWLxpZfb7bLGls2aGzZoLFlg8aaq/mLGmvaWNTYxagCS2PLhrmCD+EnqxpbdzTWukVj6xaNrVs0tm7R2LpFY+sWjW0bNLZt0Ni2RWPbrzfbZY1tGzS2bdDYdltjPwTFzW3Wj3WI9zeg3j7xwY4yXDxo74ORtbMYP+xXWHzn+Pt1u7pvwqxbt+GdY2+wWXznBLfhbALTyPI754OVxXeObWX1nWNbWX3nfLCy+M75kKPFd05w94/UMG0svnNMG8vvnOB/vdmuvnPsQlnTJdvGmi6tVo6pbebmzkWNNW0sauziJlNLY809wKsaa+9GXtXYsKOxhi0aG7ZobNiisWGLxoYtGhu2aGzYoLFhg8aGLRobf73ZLmts2KCxYYPGhvsaa5+EsZYX28ZaXlZP5LA01jwwZVVj7aNbVjU27WisaYvGpi0am7ZobNqisWmLxqYtGps2aGzaoLFpi8bmX2+2yxqbNmhs2qCxaYPG1vtxFraNRY1dPLzM0ljzbLlVjbVPuVvV2B3nGJpG1jW2bNHYskVjyxaNLVs0tmzR2LJBY8sGjS1bNLb+erNd1tiyQWPLBo0tGzQ238+LbWNRY/PtvNjH8K5qrH0g8KrGth2NtW3R2LZFY9sWjW1bNLZt0di2RWPbBo1tGzS27dDYePx6s13W2LZBY9sGjW0bdCndXgO0Tdw/9T3VeWr0H1ssf2LiOmw21bcmqnmh87zALARuW305Hc9Fa8p/4XqsDzclLL710v0Z8tUbGwwb9oUai2+9D1d7LL71otsQQmAaWX7rfbCy+Nazray+9Wwrq2+9D1YW33ofcrT41osbDi6MGw4ujFsOLoz+15vt6lsvboiOiBuiI+L96IgPFw6tvPU+mLh/f9PaW882sfTWsy8KG52O2Xi9KOzTHV/XfuRHGkelvF5B8zybwrBT50HTrjnEApU/N3oXcwXF+zYbKiQtppe3cIz3L9cyTaxdrmV7sXS51o6MbDi8yTayuk88/r6V5d3mtpXV3eYxtvvvK8vG6vvKsrH+vkp+w/vKLNjVGyyyNQ5YPauhHzNzs/dYsf3LvSfvOCk+pvrbVtZ7j2llufdYr+HV3mPZWO09lo313mO12eXeYxbs8v0vfsdL1Gq1i73HinNefImaJtZeou3+tRPHjvNDjx1HtsQt91yaVtZloOy4PyaW+/fHmDZWZaDsuD8mlg33x9gFu3p6k9vyErXWqBd7j9vwErWNLLf7mn7bynrvqTvuQoz1/kKBaWO199QtCwU71rfsgl3tPdZgePmuh9jMQcHSXQ/xw/trdMDytY21ux5MG4t3PSzbSN/aWLvrwbaxdteDaWPxrodlG9+Wx+JdD7aNtbseTBuLdz0s2/i2PBbverBtrN31EO3dhkt3PSzb+NqPtbsekvnaXLzrwTSyetdDsg8bXLzrITnrjM21ux7M7Kze9ZDMU7cX73owPVm966Hcv3m73L95u9y/ebvsuHl7y2W7ycfftrI82rStrI42k79/vKZpY3G0adpYHm2msOF4TbtgV0eb7djwrda7+s3e0zacU1233HGbQv5tK+u9J+xYLkjh/nKBaWO194QdywUpblgusAt2+VvNaG/Ldz0k67bq1bsekr2utHbXQ7JObVu768E2sXTXwwcTC3c9tGPDXQ/J3Lq1eNfDD4y8v+vBbmWLdz0k83DAxbsekjXiW73rISWrqS7f9fATM8ZdD/Z0y+JdD+7+XQ/Jurpp8a4Ht+OuB7flHZp/3cr6OzTvWC1I+f5qgWlj9R2ad6wWpLxhtcAu2B13PUQXpkK6HN4vGibr6qbFux6StfixeNeD37H0ke5/jDa/YenDNrLciUv9bSvrUlB2xA+kej9+wLSxKgV1R/xAjxm8LQVlR/yAtz686iyUcEQM/f5yxTyyrU5BcRXx1vHPeceSdlyBmOrtKxBL2hFFl7Z80Db/21bW+3HbcQViavevQDRtrPbjtuMKxNQ2XIFoF+xqPzb36a72nnzcvvGoVLeh95hGVtt9PuJvW1nuPbaV1d6Tj/tTsqaNxd5j2ljuPdltmJK1C3bHW/DxjZ/n5z72Gby+BU0j8bgCAI7s379Ks7XmtcdKrmlOK9VyZSj/xEab61X5MWb90sY1vdXSexvH/duobBtr+1lWO461n6VuOO3zg8Iu7rPrS3S3O59lZHmf3Qcri/vsbCur++xsK6v77D5YWdxn9yFHi/vssrXwtfrOCMf9d4ZlY/2dEX692a7us7MLZVGXwv39v6uVU9K3Q+q1vNg21vKyOrS3NDZtuCnlwzfgqsbGHY01btHYuEVj4xaNjVs0Nm7R2LhFY9MGjU0bNDZt0dj06812WWM3nLGQN5yxkNMGjTWnHxc1trr7Grs4DWreqlrua+yH+fJVjc07GmveorF5i8bmLRqbt2hs3qKxeYvGlg0aWzZobNmiseXXm+2yxpYNGls2aGzZoLH5/onKto1FjV1cdbY01u24VdXtOJMn1x2NtW7R2LpFY+sWja1bNLZu0di6RWPbBo1tGzS2bdHY9uvNdllj2waNbRs0tm3QWDMqdVFjTRuLGrsYHWudqtc2aOyHMOpFjS3HhsZqGlnW2A9WFjXWtrKqsbaVVY39YGVRYz/kaFFji7uvscXd11jTxrLGFvfrzXZVY8uGG4vKhhuLitugsf7+mpdtY1Fj/e01L3t71fKtqjtOVC471rzKljWvsmXNq2xZ8ypb1rzKljWvsmXNq2xY8yob1rzKljWvEn692S5r7IY1r7JhzavcX/P6sP106UTlcvtEZXs/7+qtqraRxVtV7ZNBFs8NrfdPy149ocSqW7dhfvrDUTar75y44WBY08j6OyfuOM/YtrL8zok7zjP+YGX1nRN3nGdc0v3zjE0bq++ctOM845J+vdkuv3PS/fOMbRuL75zFyjG1rdyfn7ZtLGpsuT0/bR9xt3xTyrFDY/OOxpq3aGzeorF5i8bmLRqbt2hs3qKxZYPGlg0aW7ZobPn1ZrussWWDxpYNGltua+yHI0CXzoy3TayM6z8cVruo9Pl+tMfqobnmKfwbRtMfTldeVfq6YQ+taWRd6W0rq0pvWllWetPKstLbVlaV3s7RqtK3+1u/S7u/9du0sa707deb7bLSb7hzumy4c7rcv3P6w3H6ixob769Erh7rb2ls3BG1HHdELZu3F642VtPIssZ+sLKosbaVVY21raxq7Acrixr7IUeLGlvdfY01bSxqrGljWWOr+/Vmu6qxdqGs6ZJtY02XVivH1KXj9mjaNrE0mj78/RK1bSzetefvl2jYsQcw7NgDWMOGE7hNI+tKH3bcMGtbWVb6sOOG2Q9WVpU+7Lhh1jzwZ1Xpw/2D400b60off73ZLit9uL9mZttYVPpwe83sQzxQu05bfp5VPM38xMjjh+0ygjL5q4LNZtLqAVe+sxLd8+gONRPv3u09L0faUCamkeUyMQ/NWy4T89qvpTIxA2JbS9cZ47zKMNefGLkabKveMGIebXrM48Meabw1fmRm7awE28TSUQkfTKyclJCtg86Xa8Y2slgz3m2pGcvMYs2YJtZqxjaxVDOHdXdnuO7CCOi64eWgO9uIn+eaPoyUt0b6GOjtwDHOk058dNdgPL+cFlutkwxdbNfQBscE/WXE3M81jzWt4fLjMQz8gY06ryqo2Vk2rDO2jnmbuHeom/iXEUPPah6yWluxHDFWHYKbn1rhUaxv6/cHdVPe1o3dSMJ8S/xx3cGPbCQ/z4FKIRhtxHiFp3Z9OrbcvjUyD6ezjATroK+1xhqts7XadWduq38EaZUfGPFhqrNP3xq5vpIajyX+mRGXr+tKavo2O/OErkfOvGHEGkuU6wrEkt+/sX5gpH1rpF1D+ZYMI2aZxKtMUn5bJh9kvl7XhOCj/K+OY13QxcuG3upisM6FLK3Mc8UbhfEvcW3mYcI4Zz0aKtDihneWeXrh4jvLsrH6zjKrd/WdZWna6jvLWthaf2ct102x6sY8GXkeg+8eX21vjTRrjLX4rvjkyZxu8Qc/sv7yxBoNzBqOh1E77dhw45DtSXTzjGacFf2ftJNgNtjjarD1u3L1j5nBaaRGo1zb/XI1ZzlaqrOp4bvkr1ZverJWrqa+VjcDv+tjguitvtpvrcXPxg9G1j4bTSPrn42P+sm/b2fxFEXbxtopih9sLJ2iaF7wXK5lnPpWYc2Tohe/HJv399/CzdrKsvgWNm0svoWbT/ffws0q1sW3sHmSzvJbeL1uyndtZO3D0TSx+N3YrMn91e/GD0aWxgLmFWpLLdXc6LT41WjaWPxUM20sfqmZG/YXP9TWbbQvbax9poUtc89mqS5+iZu5WW0h7f60gmljR15WW2q731JTvd9S1220L22stdRUt7TUdn9Wwh5BrE1KNPuaiJVJCfOA7dnWHyManvX9OjS0tlwGP990IXA09BMbYUYIPL7I3g8NzX1aSwt6wfzQvFbTDxTpf1Ie5rTzdUp+cuj97uX+gWZdyBXyvIg9ZO6GfbFi3TK4WCLWZXjzatvHksu1mP5SHqaFObrkLXZ/WbA+YdKMEnKJx9q/BDmYNqK/BnQ+vLXxqBPz1kZf8/zafV6A95+XqHkYaJmfmI/JEURs+LBu41EMB7KD8ZRPr/lp93uuaWOx5xZ3t51G836La9t3wc0ULxbS3ZZuWlhq6VYuVlu6aWO5pVv7sZZburnN5ZhfQB5Xmnnv1m2k6wb2lAwbZm/p+6zOIqmIXPm7t1iHxa72FtPGYm8xjyBc6y3rJeLC2xKxLhd9lEG7PrUj6uZbG/W+DUwf/mXDmr9w88vh0VQxpqtt3YbPcdrI5UsbM7DBh3y8t2GNYq5rh8Iz7O07G9fow4dy3wauP3q1Yb0Z8jFXzfLBy01fbFhv7dW6NW0s1q1tY61uszVOzhmjQrfBRvrSxlxheiTLdzbKNVVXkv/ORp2LKY/VjC/Lo98mdvqBtZTvbdQv83KM9hGq+7J91HlrWajxy7rtoaTDRvvWj9k+av62buc9YY9k+7LPlWsMYtWtvR9tzm0HvCt/aOO4bMT7Nnz4VoOuzRK+fulHuMojtft+WFroN+i636DrfoOuuw267jboutug626DrrsNum7df/qY4BuLFkfLX40/UmijPB5JYxxkjk/nGCZwZfp1fOoPX2+vsD2MmB/rM/j20Ymz4Yp5pGAqw0pJDZMP9dWI+SVUry8hLveVVyNW17sCXR7i6A0j5vmTR7w2XHEvzl8Zsss2XRcnlmJVs2mlXTXU3jcW8/Muu9lWHgtsxgfvo2DKzfnlD45ME09HquWIvUo1Z+1dQy2/dGTzmmk3r2iP7r0jlo10XdGeWMOvNqyP95QvUco1f2fjCqp6ru6+tWFXTQxzf2CO8Wsrsxc/0s0ok9uTzPX2JLN9hEnFnqJ2vItw8Yd5+oGbq9yPRbvynQ0/h5vN+/rVFHOYe/EeaQydf1S3BUEQJblmdF5rlWpt2uyDjaVps4eN9KvTZn+WiP++XOtlJXzZ88o1M/pIY9j5n9RO21A77X7tZPe7tfNHiZTj69opsOLeWrFigdcUzbSwtphg5eQxrzujgKsztPlRM+Xu0opt4yGL19umZEzk/8xKmbFMj3R231q5lL5wsuYHba36a0hSg9GHnRVi7Wqcn5+PdKvfmXl8gM44Me6Ge6y6fGnE+S+NpBn66hPq50dGHlnwc1D/x/fSq5Fyf/ncNJJcGi0l+Uop+ImRMINwUvDlrZHH8Pi4r9OmjUWdrrd3TX8okPk9nKJLVoFY16kfMyQxH6lZVqxjy+cUY8aM61/ffbYj115Ufpj/MDvX0SGPjyb3tZW5+JsZNPZjK3VaacFo9tbsS5wz0SlaRqzdBWvvUdvE0ovU2QdVrS3L20YW1+Uf8zzp/rq8s2Lo4zFj6OOfXed1LsnaeLWqSKaNRUUyDxRcVKRszVhe02LFs/OFHxjJ1/xP8eGtEW8PCRaDxx5Wwoa3X7DiWdzsORjg/CeOpC3ZyTuyYx5HPXXacTnavYSSPDdlWRPTs6VA1Kr7gR+5zUFs/eO77dVI26AD9s1zczjd/lh0eJVo28gs1laO9rWRMI1waevVSDRP7YlTphnNGuLxYsQ8AmG+ch7TNOG9ETsOfb7MW2Xkw4/KpF4F2zB1+mpEWwF/18of2w0ZUvJSKh+sXIEpj+nsw7BiHqjiar0m6vy3Vq559kejit9aiXPL0kPekmXFnJteOsTrQ+GGPD/TQ31fuC7dPzHD5ftjtnx/zJZ2jNnSjjGbM49XW9Vq8/DltY3/D0/CYvW+33L4MGJdPLC0kcu2sbbl8Ck19xdEzZfx2pbDhw1rSLC45fAHdWN0PbORrO379y7e3+vnrPMUfJ4a/UhiUPDXbnvLSLlifx+t/zsj6/v+LU9SuHbrZMuIuU2uXQO/Rxpv0fwTMy7G6/0XGbPyQzMuXmaitS/cfOu0q3hd/rJ4V+9sa+bun6WjGZqtKEsnM5g21g5m8C7dPvDiYcOcKVg7mMH2ZLVUzdpdu9bvQ3M9Ak6f5MD8Z63eXaXiXPm6D7pr/437Q/PzT4Y5aY6UGLb+s5HSnO+DLr2a+DQUnn483pVfD6jj3O3xGDa5HcNyw8qHL6c5FG4VcRp/f/Pk+/Nbto21+S13f4OVbWNxjswu1NlKHuWbjUItt5cPbBuPLjzfXPmw2qtpJc9lGZdD+9ZKTdcaa/ralza34/jjcF9aWZ26+ODLFfXlSjVz1HZ8pJe24yO9tB0f6ebC1+pHul24V+hHde7rYlkVbLtYVgV7uYoswbaOW1mdabauyl2fabbCwJZnmq3DcEqag+KSHVcEj3Uj1cV5ntVTY78zkmYd1/THmsRrHbfbEVwfHJknu9f0R+jkX46k+6/klu6/TtvtkwacNyce5tk+lZeJ/F299fZUm2libarNlw1TbaaR1ak2b56atjrVZt4avDjV5u2Fr7WpNm+tey1OtZk2Fqfa/LFh74G3FsAXp9q8tZi/PNW2XjfGVJvZSBan2h6Tfven2lLeMNVmGlmdakt5w1Sb6cnqVJt1EswPptpMM+tTbR/MrE61pbxhqs00sjrVZkdSL00KWd1ndarNtLE41eatg5gWp9q8+e5anWozPVkt1bxhqs1urstTbbaZ5am2D2ZWp9rMYc7aVJs9UlqZanOW3i9+53j7JKPF7xwfdoTHWnFkwc+NwOGh2xjD+h8YKTMYLbQ/tqq9Gqn33+judsy+bWJtMG3mZHUwbRfH6mA67og1tPaKuoiQfVfeV6+9gn7tZ2qR57K1nxiJUOnwpZFSr9O7OIz9q2TTsaMPm/uKV/uweVxULteNXLm495Vsbd4pc5rh8dpp3xVtvLLzGD2aRZu2FO2WgMPDGpnP0xV9ztlo+paRNN9cPpf41sgjP21Hqew4ktBcinDpOgX8kXbv7pFzJe0YmQc77uraE4ydTa/HPeqQiPffTlc1l2h8CeYd0wV5w3RB3jBdkHdMF+QN0wVly3RBvj9d8KmVzAlQX6yPlWxei1Wuk85a+drIcd9ISVfEfDYafcmL0x/py4INiMh+DCC/NZKvieVqGLGWQhZPWv9kZGlK6EN24nynBy7K/GWk+l/35OqBj2W4DUa+7YCPtYMyjVSj2Vfr4ytf50cXb8pS3tFQ8m9XT3FXN7ZUqZlx9wUf+sl6aZiutOv0M6ulNH9/Nse+smh1Nqf527M5H0ZKIV8jpfR2vcubMaFoKE8r9Ssriyte9tr34rJKu3/dpo5KuzlOMm0sjpPCcf+6zYeR29dtPmxsuG7zB3VjTMLYkTBryyrB3GC8uKxinfWzvKxiGlldVrGMLC+rmJ6sLquUtGVZ5cPH2+p6iJml1fUQ08jqekgJt7X+w827S+shpo3F9ZDgbt8J95j43XAnnO3JaqnGDeshdnNdXg+xzSyvh3wws7oe8mHa79osmY2jVIK58PWYBaqwkr6ysji2iGnHVKgZ/u+uuyrD+7BhF80z8+ZnRineCJMN1rmGKV+HJ2SGlb4snFkTh9xsiT2ozxPB142UGST7mOY63hp55Cb9tpXHt9dxtbX6rZVSrvDW5i0r1h3Y8wC+woWeH9nALZGpfmnDHX4uR/Dgyr+tWDu+VkNb7YJt1zpC80Z7s47STXUWSqqYh3nI7rqRxzrTVSrFcTt5eH2d3j6V0Daxth5oZebR6PNcdsZY9rVEHjVstZPsrjj17HgF12uR2NNkPs1psj/uR3o5UCx8WP2aJ2U85+7je2fMo3vStPJIlncaaZq4DkBIXNT/kYkVpfbmRcvpuDLCV8YPTFyN9ZGM35lYyoiL9185tpHll4W14LXHyvorx7Sy/MqxhGD1lWPZWH3lmOq6/Mqx1lSWXzlmwS6+crw11FrXtFx3aJoZlrOmabaJJU37YGJJCqyx9KKmmSbWNM02sZSRHcNov2cYXcpvW1nXtFJ2aJp1IOGqplk2VjWtHjs0zbyXa1XT7IvXVjXNOsIhX/Of8CO9KpG11BXDnBOOfxx2nl4Gnjns+Bq2tnYtdmP7vpHFbmwaWe6Azf22lfVubFpZ7sYt3u/Glo3Vbtzijm5sbu5a7cbN/XI3bnOL2B+n/L9242itUyU3D9NNHluL/+rGlhYsd+O44QvD2p653I3rjm+DeKTftrLcjW0rq904HvcntUwbi93YtLHcjaPbMKllF+xqN7ai0Hy71t4adtT/3ZGdeVf3vO3q8ff8+45sLRGtd2R3f1hd0oaOXLZ0Qdd+28p6R3Y7pgqivz9VYNpY7ch+x1RB9BumCuyC3dGRg5sF+1i5dEZHtvYRxTqvzIkPZXjfka1Yi/WObAWXr3VkO4ZlsSPbRpa7oHWC3h4r6x3ZtLLcka29Xqsd2bKx2pHNPWfLHdk6QWi5I5sFu9qRze/9MJeLXeBFMcfLaRQxmifCzOw0Xj3nf2AjzQAFRkz90MYMYUm8UOxHNvI8AP2PexC+tpG+tTHLI39dHnmWR/66PK4D4cvX5UEb35YHr+D7tjyu+3vK1+VRZ17q1+VBG9+WR50SUsvXfpShiLV+60ebV/G2r8uDNr72Y25HbJYGVfO1uRakaBvp51ycwwAjSPExXW+eydaut2YyrVjzsNeuLp48FtoPsrMYW2gaWQ3ctD1ZDNy0A2KXVmNsE0urMR9MLI02rY/65dGm2zEBG4v/bSvro007tH51tGl9Tq+ONi0bq6NNO8x4dbRZ6obRph2OvjbaDNbx/uvfatXd7j1WoOVy7/E7ViFjjb9tZb33mFaWe491Be1q77FsrPaeWnb0HmtP13LvMQt2+VvNOuXAXztNfUN+2qsr5hGGbp4g8ZjF4R61VyOrB8PxmvDX6R/r/ME8jzvJPDLlRybmHpmM2yt/aGJ0nHK89cIMPU3HjJtJB78r/ipRa0ogzU1/kSGSN4y0t0bsVjaHWSEcx/tWluzLu65zSmKobz1J1oaufMztadnxxJS/jFhNleeuuHTULWace1+45nTLdaVuZL95mW4xg5Qxy9Hc+1F9slaW1r4MQtwQ42gbWX37pS3jWNPK8jvUtrL6Dk3ufiCBaWPxHWraWH6HPlbX779D7YJdXriwDhU4wn+u1a8xjsna1hXmgcQRp67/NWeavHlm0dzU5Tlv8ufGsJDqhuF08uH2cDrv+BjNWzqxz79tZV0KTCvLUuDbfSmwbKxKgW87pCBsODzeLthVKbALZQ5Rmv+6YOdZNq2k+5Vj2LD7Tphn5T26ovvSiJ/Lsc/d+lYFb1jbMo246w7ox8CrfumKc7N2HO+A/qEVjNlC+9qXdG1WTTjT7adW8nWwAPbi/zRHV/cJ3spRvL8ka9pY1aW4Y0k2xV9vtmF+0rqQyreFsqhLpo1FXVqsHNOGOQZdzItpYzEvi2NhS2PNT5VVjbU/mlY1Nu1orGmLxqYtGpu2aGzaorFpi8amLRqbN2hs3qCxeYvG5l9vtssamzdobN6gsfm+xtpz5Wt5sW2s5WV1zt7SWHNJZVVj7cWdVY0tOxpr2aKxZYvGli0aW7ZobNmisWWLxtYNGls3aGzdorH115vtssbWDRpbN2hs3aCx5mr+osaaNhY1djGqwNJYt2OuwG2ZK2g7GmvborFti8a2LRrbtmhs26KxbYfG5uO+xpo2FjXWtLGssfn49Wa7qrF2oazpkm1jTZdWK8fSJTsobm6zTrwH8EdxdUsnPphRhosH5X0wsnaW4of9CovvnHC/blf3TZh16ze8c+wNNovvnOw3nE1gGll+53ywsvjOsa2svnNsK6vvnA9WFt85H3K0+s4J94/UMG2svnPCjiM1cvj1Zrv8zjELZfGdY9pYfOcsVo6pbebmzkWNNW0sauziJlPLhrkHeFFjP+xGXtXYuKOxxi0aG7dobNyisXGLxsYtGhu3aGzaoLFpg8amLRqbfr3ZLmts2qCxaYPGpg0aa56Esaixpo1FjV08kcOyYR6Ysqqx9tEtqxqbdzTWvEVj8xaNzVs0Nm/R2LxFY/MWjS0bNLZs0NiyRWPLrzfbZY0tGzS2bNDYcl9j7UPD1vJi21jLy+rhZWZ55A0aa59yt6qxO84xNI2sa2zdorF1i8bWLRpbt2hs3aKxbYPGtg0a27ZobPv1ZrussW2DxrYNGts2aGy9nxfbxqLG1vt5MY/hXdVY+0DgRY0tx4bGahpZ1tgPVhY11rayqrG2lVWN/WBlUWM/5GhRY4u7r7GmjUWNNW0sa2xxv95sVzXWLpQ1XbJtrOnSauWY3+j57hrgBxP3T31PdZ4a/ccWy5+YuA6bTfWtCet0vODmBWQhcNvq38dcWudOz053Na/4mpF8f4bctrH41sv3Z8jdhgjuD1d7rL71/IYQAtPI+lvP74h8sa0sv/X8jsiXD1ZW33p+R+RL2XBwYdlwcGHZcnBhCb/ebJffehuiI8qG6IhyPzriw4VDS28928T9+5uW3nofTKy89T5cFDY6HbPxelHYpzu+rv3IjzSOSvnrCppirirVedC0aw6xQOXPjd7Out+ned9mQ4WkxfTXIdG3T4x3+fbRZ7aJpaPPPphYykjdsNvcNrK6T7xYO/D3WFnebW5bWd1tXqxNwKvvK8vG6vvKsrH+vrKu6Vt+X5kFu7rb3Do/f/mshnK/93hrFXT5vPljS7svx29bWe89ppXl3mOtbq32HsvGau8pYUfvKXlD7zELdvn+l7DjJWoe/rLWe0K6+xK1Tazd5hbuX7UZN7xEbSPLHbim37ayLgN1x/0xpd6/P8a0sSoDdcf9MaVtuD/GLtjlI1u2vEStNerVuxB3vET3DB5b+W0r672n7bgLsR73FwpMG4u9x7Sx3HvqlvWttuMuxGauNize9VAPc1CwdNeDaWPxrgfbxtpdD6aNxbselm2kb22s3fVg21i768G0sXjXw7KNb8tj8a4H28baXQ+mjcW7HpZtfFsei3c92DbW7nqo9m7Dpbselm187cfaXQ/NPCdw8a4H08jqXQ/VPmxw8a6Hap16sXjXg5md1bsemrnQsHjXg+nJ6l0P7vbN27aJtbse7l8RGPyGm7dtI6vjxBryb1tZHm3aVpZHm+H+8ZqmjdXRZthxvGaNG47XtAt29a4H68re5W+1Gm/PdISw45zqsOOc6hrrb1tZ7z1xx3JBTfeXC0wbq70n7VguqGnDcoFdsMvfaoYny3c91GSMCVbveqj2utLaXQ/VOrVt7a4H28TSXQ8fTKzc9RA33PVQza1bi3c9/MDI+7se7Fa2eNdDNQ8HXLzroVorW6t3PdRsNdXlux5+Ysa466EtxgGbdz2k+3c9VOvqpsW7HtKOd2ja8g7dctW1aWX9HVp2rBbUcn+1wLSx+g4tO1YLat2wWmAX7I67HqILUyFdDu8XDat1ddPiXQ/VWvxYvOsh71j6qPX+xYN5w9KHbWS5E7fjt62sS0HbET9Q2/34AdPGqhS0HfEDtW2IH7ALdlEKnPUZqY9MDXSOiKHf365Yn+h1CoqriLeOf847urrjzpZ23L4C0bUdUXRtRwBAO+JvW1nux7aV1X7cjvtXIJo2FvuxaWO5Hze34QpEu2BXX+mu7eg97vaNR977+73HNrLc7l3+bSvrvcftmJJt7v6UrGljtfe4HVOyzW+YkrULdsdb8PGNn+fnPvYZvL4FTSPxuAIAjuzfv0qbtea1x0rus3nnnFC5MpR/YqPN9arcfPnSxjW91dJ7G+7+bVS2jbX9LKsdx7LhN5z2+UFhF/fZNStScrnzWUaW99l9sLK4z862srrPzrayus/ug5XFfXYfcrS4z65ZC1+r74zo778zLBvr74z46812dZ+dXSiLuhTv7/9drRzTxnH/phTbxmJeFof2hg37y2tRYz98A65qbNrRWNMWjU1bNDZt0di0RWPTFo1NWzQ2b9DYvEFj8xaNzb/ebJc1dsMZC23DGQttwxkL9vTjWl5sG2t5WZ0GNW9Vrfc19sN8+arGlh2NtWzR2LJFY8sWjS1bNLZs0diyRWPrBo2tGzS2btHY+uvNdllj6waNrRs0tm7Q2HL/RGXbxqLGLq46WxqbdtyqmnacydPajsbatmhs26KxbYvGti0a27ZobNugseE4bmusbWNNY20bqxobjuPXm+2ixn4olCVd+mBjSZeWK8fUNjMqdVFjTRuLGrsYHWuVR9ihsWGDxobD3W+stpFVjf1kZU1jP1hZ1NgPVhY19pOVNY39lKNVjfUbNNZv0Fi/RWP9rzfbZY31GzTWb9DYDTcW2ftmFjU23F/zWt2/Y95cveFE5Q8bvVY1NuxorGGLxoYtGhu2aGzYorFhi8aGLRobN2hs3KCxcYvGxl9vtssaGzdobNygsffXvD5sP126VdXdP1HZ3M+7equqbWTxVlX7ZJDFd85x/7Ts1RNK7JvN779zPhxls/rOSW1D500bzjP+ZGX1nZM2nGf8wcryOydtOM/4U45W3zk533/n5Hz/nZM3nGf8sPLrzXb5nZPz/XdOzvffOYuVY56JXO/PT9s2Fs9mrrfnp+0j7lY1NrodGlt2NNayRWPLFo0tWzS2bNHYskVjyxaNrRs0tm7Q2LpFY+uvN9tlja0bNLZu0Nh6X2PtI0CXzoy3TSyN6+3DaheVvtyP9lg9NNc8hX/HaPrYMZp2x/09tLaRZaX/YGVR6W0rq0pvW1lV+g9WFpX+Q44Wld4dt7d+2zYWld60saz0zv16s11Venf/zukPNtaU3m24c9o+Tn9RY/P9lcjVY/2tqOW6I2q57hhNO7+jsfotGuu3aKzforF+i8b6LRrrt2is36CxfoPG+i0aG3692S5rrN+gsX6DxvrbGvvhVpqV0fQHE2v3Dob78ya2jcW79sL9Et1xw6zbccNscDFs6DJxww2zn6ysKn3ccMPsByvLSh833DD7KUerSp+O+0qfjvtKnzYcHP+w8uvNdlnp03Ff6dNxX+nT7TUzZ21vzmketY4joV7vl7NNLF1R56wTNVa9OG57YYVJPtYF65DXP/qu9z8wkts8CSO38KWRegl9O9J3Rh5viHna5eHfZ8cf1gWEj3lIP63U8KWVxZMJbBtrJxN8sLFyMoFdN2WeevQ8NP3LCv7DSPzWiL+MhPdVE5w1VRh8G60+PMTzTZF8sBHmW+8xkCrvbaTftRHdzEv07svqncdDPqZY67c1Mw9n9aV9qyT05GsjdQ7Dn2fBfmtkjiRMI+32i6bdfs/4I1qRjd7NV6Y3NMS2Mc86eiTbGxvWsYNrZVFvXwtbrUOfipuHPhWc2OR8WrdR5zV0qQb3pY35vnwk85c20uUHLnb/mY3rk7emL/1os3WlR0v7tjzaZeN9vRTr3O50HbCZEF72vY36nY08B8ox4yaPn9mYl5vEYrSxYt6fM18Lpbj3x6QFb0WoxTRb6iNjmNHI9SeeLB3YFj7cbr1yYJu1frx6XptpY/GgtWBeBLvHyupxbR+sLB7XFvyGRSy/YRHLb1nE8jsWseyCXTyurfkdndjF+534gyeLnfj+RTjWJsXVTty2dD/XftvKeic2rSx34g37tfyG/Vp+y34tv2O/ll2wi53YepunY9pIh38/ynpkx7p1ws+LK5LnmLG+GrE+J8os2Vwwg/1ixM5NnmNGzo38nRtrCWs5N8H/bm7cvGPlkfxu1JiCG1MSKfjynY3rrpdHcoON7L60UWft8jaQn9mY1ww+zH1bpnNh4pHMX9oIl40YrX53fx+Q37DX0t/fa2m+9haX4+zX7+JqnI95gzRbRpZX4z5YWVyNs62srsbZVlZX4z5YWVyN+5CjxdU4n27fZWDbWB1RpA13GTys/HqzXV2NswtlUZVSuK9Ki5Vj75q+H0PiN8Tp+ftxeubswKLC2rMUqwqbdzTVvEVh8xaFzVsUNm9R2LxFYfMWhS0bFLZsUNiyRWHLrzfbZYUtGxS2bFDY+7sarJjdUMpc7CwV0z+1fWmjfmejHqNeAu9S/5mNOYEUKm6z/JmNWC8b7Vs/5t2cFXcX/MzGnLR5JA0/rFVKP+vl8eKI39kIh7/eWuFbG8dlI9634b/0w7fr7enrl36EqzxSu+9Hft/WU7pftyndr9sPNpbqdtmG/9KPxbq1/Vir22U/jLqNxbIR50jRJ4axvNwH2EeUbxVkLYzFtrEWghKO9Ls21sJYzDIN81XpQzmsMrXmWacoZ7yjXqYUTTfiFQfDMczfblihfasTpMFax1qcIDVzk/xsqI8Jxre5sW3MicnH9/X7Enm0ACsQPMUpISkdX1pZC8r7YGMpKO+TjZWgPOuspLWAGtPCUkBNuB3UE24H9ViH17SW5ii7Vfd2ddO2cY2yW/VvbbhmX0B/zPiRRxrfuj+zs9pGTRuLbdS2sdJGgxWs7WeAUfMIMAqh/MBGuMLXUnlvo91vI7aN1TYSN7WRuKGNxA1tJH7XRv7LA/7pv/3Lv//Xf/3v/+2f/uNf/vu//c/H7/7309S//8s//V//+s8n/j//69/+G/70P/5//2P8yf/17//yr//6L/+f//o//v2//7d//r//17//89PS88/+4Tj/9X8+BqTN/+NjOOj8f/nHfwj9/zyPunr8O9fH/3HnX3qsaj3/qnv+L6e/9RiAPf+d/sv/frr6/wc=",
      "is_unconstrained": true,
      "name": "get_invoice"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "partial_note",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "token_address",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "title_hash",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "types::invoice_note::PaymentInfo"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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Yz+P/TzO8zjP4zyP8zzO8zjP4zyP8zzO8zjtUc1Rl+zReDQfrUf+KB7lo/3oedjzsOdhz8Oehz0Pex72POx52POw5zGex3ge43mM5zGex3ge43mM5zGex3ge83nM5zGfx3we83nM5zGfx3we83nM57Gex3oe63ms57Gex3oe63ms57Gex3oe/jz8efjz8Ofhz8Ofhz8Pfx7+PPx5vDr3V+f+6txfnfurc3917q/O/dW5vzr3V+f+6txfnfurc3917q/O/dW5vzr3V+f+6txfnfurc3917q/O/dW5vzr3V+f+6txfnVfTVXrRaao6B9mj8Wg+Wo/8UTzKR8/jtEc1YF2yR+PRfLQe+aN4lI/2o+dhz8Oehz2P+mJcfQervhoH8kfxKB/tR6epviYHskfj0fP46nyPIn8Uj/LRfnSavjq/ZI/Go/noecznMZ/HfB5fne9VdJq+Or9kj8aj+Wg98kfxKB89j/U8/Hn48/Dn4c/Dn4c/D38e/jz8efjziOcRzyOeRzyPeB7xPOJ5xPOI5xHPI59HPo98HvW11DrD6pupIH/0eURRPtqPPo/vHUs1dF2yR38ep86mr84vrUd/HieL4lE++vM4GOU0fXV+yb5vcP4KB3ESF9GJQUziJp7G6vZqNOIgTmK5WaETg1huq3ATz0P7EY04iJO4iE4MIt2Mbka3UW5eaMRBnMRFdGIQk7iJ5+Gk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Kb083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbue57d+PaMRBnMRFdGIQk7iJdDO6Gd2MbkY3o5vRzehmdEOW7MLzEFkCNOIgTuIiOjGISaTboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Kb083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbue5nd+PaMRBnMRFdGIQk7iJdDO6Gd2MbkY3o5vRzehmdGOWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWVJ+gmRUGMYmbeB5Wllw04iBO4iLS7dDt0K2yxEbhuTiqibDRiIM4iYvoxCAmcRPpZnQzuhndjG5GN6Ob0c3oZnQzug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LbotujndnG5ON6eb083p5nSrLLFVuInnYWWJZaERB3ESF9GJQUziJp6HSbekW9It6ZZ0S7ol3ZJuSbek26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HbeW72+xGNOIiTuIhODGISN5FuRjejm9HN6GZ0M7oZ3YxuRjej26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotuim9PN6eZ0c7o53ZxuTjenm9PN6cYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZ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mCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSxB3+v3u74Tfa8XF/FzW7MwiEncxPOwsuSiEQdxEheRbkE3ZEkWbuJ5iCwBGnEQJ3ERnRhEuiXdkm6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbue5oe/1ohEHcRIX0YlBTOIm0s3oZnQzuhndjG5GN6Ob0c3oZnSrLPFRaMRB/Nx8Fi6iE+ucXIVJ3MTzsLLkohEHcRIX0Yl0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3RzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6Rb0m3TbdNt023TbdNt023TbdNt023T7dDt0O3Q7dDt0O3Q7dDt0O3Q7Tw39L1eNOIgTuIiOjGISdxEuhndjG5GN6Ob0c3oZnRDlljhJp6HuC4BGnEQJ3ERnRhEug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG/peLxpxECdxEZ0YxCR+br4Lz8PKkoufW9R/W1lycRI/t5iFTgxiEjfxPKwsuWjEQZxEug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLem26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HaeG/peLxpxECdxEZ0YxCRuIt2MbkY3o5vRjVkSzJJglgSz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",
      "is_unconstrained": true,
      "name": "get_payment_info"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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ugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq8G/ffBatgNfyP7+iAaTkNe+GoQMBqsYTasht3QI68eefXIq0fePfLukXePvHvk3SPvHnn3yLtH3j3y7pG9R/Ye2Xtk75G9R/Ye2Xtk75G9R/YeOXrk6JGjR44eOXrk6JGjR44eOXrk6JFPj3x65NMjnx759MinRz498umRT498euTskbNHzh45e+TskbNHzh45e+TskfOOnL9fw2iwhtmwGnaDN0TDaeiRR488euTRI48eefTIo0cePfLokUePPHpk65GtR7Ye2Xpk65GtR7Ye2Xpk65GtR5498uyRZ488e+TZI88euWswuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7BrNrMLsGs2swuwazazC7Bv++kP89Go/s0Xy0Hu1H/igenUfPYzyP8TzG8xjPYzyP8TzG8xjPYzyP8TzsedjzsOdhz8Oehz0Pex72POx52POYz2M+j/k85vOYz2M+j/k85vOYz2M+j/U81vNYz2M9j/U81vNYz2M9j/U81vPYz2M/j/089vPYz2M/j/089vPYz2M/D38e/jz8efjz8Ofhz8Ofhz8Pfx7+POJ5xPOI5xHPI55HPI94HvE84nnE8zjP4zyP8zzO8zjP4zyP8zzO8zjP4zyPfB75PPJ55PPI55HPI59HPo98Hq/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46ry4k/3p4qw3p0nj05xHVO/zV+aX1aD/yR/HoPMqmr84vjUfPw5+HPw9/Hv48/Hn48/DnEc8jnkc8j3ge8TziecTziOcRzyOex3ke53mc53Gex3ke53mc53Gex3ke53nk88jnkc8jn0c+j3we+TzyeeTzyPaoxqVL45E9mo/Wo/3IH8Wj8+h5jOcxnsd4HuN5jOcxnsd4HuN5jOcxnoc9D3se9jzsedjzsOdhz8Oehz0Pex7zecznMZ/HfB7zecznMZ/HfB7zecznsZ7Heh7reaznsZ7Heh7reaznsZ7Heh77eezn8ep8vTpfr87Xq/P16rw6nsKKzqNsqjoHjUf2aD5aj/Yjf/Q8/Hn484jnEc8jnkc8j3ge8TziecTziOcRz+M8j/M8zvM4z+M8j/M8zvM4z+M8j/M88nnk88jnkc8jn0c+j3we+TzyeWR7VHPUpfHIHs1H69F+5I/i0Xn0PMbzGM9jPI/xPMbzGM9jPI/xPMbzGM/Dnoc9D3se9jzsedjzsOdhz8Oehz2P+Tzm85jPYz6P+Tzm85jPYz6P+Tzm81jPYz2P9TzW81jPYz2P9TzW81jPYz2P/Tz289jPYz+P/Tz289jP49X5fnW+X53vV+f71fl+db5fne9X5/vV+X51vl+d71fn+9X5fnW+X53vV+f71fl+db5fne9X5/vV+X51vl+d71fn+9X5fnW+X53vV+fVcRW7yB/Fo/Mom6rOQeORPZqP1qPnkc8jn0c+j2yPasC6NB7Zo/loPdqP/FE8Oo+eR/1W3Cgaj+zRfLQe7Uf+KB6dR9lkz+Or82NF9mg+Wo/2I38Uj86jbPrq/NLzmM9jPo/5PL46P6vIH8Wj8yibvjq/NB7Zo/loPXoe63ms57Gex3oe+3ns57Gfx34e+3ns57Gfx34e+3ns5+HPw5+HPw9/Hv48/Hn48/Dn4c/Dn0f9QmqdYfU7qSB79Hl40Xq0H30epygenUd/Hlln01fnl8ajP4+MovloPfrzyBrlq/NL8eh8v775K8yHX6U3DqIRJ3ERN9GJQaRbPrdq+Gost1FoxEkst1W4iU4M4iHmw/EjDqIRJ5Fug26DbqPcduEh5kP8wixwEI04iYu4iU6km9HN6DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26eZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJuh26Hboduh26Hboduh26Hboduh25Jt6Rb0i3plnRLuiXdkm5Jt3xu5/cjDqIRJ3ERN9GJQTxEug26DboNug26DbohS06hE4N4iPkQWQIcRCNO4iLSzehmdDO6Gd0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt2cbk43p5vTzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAt6ZZ0S7ol3ZJuSbekW9It6ZbPLX8/4iAacRIXcROdGMRDpNug26DboNug26AbsySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySypJsExRuEkLuImOjGIh5gPK0suDiLdkm5Jt8qSYYVODOIh5kWrPsLGQTTiJC7iJjoxiIdIt0G3QbdBt0G3QbdBt0G3QbdBt0E3o5vRzehmdDO6Gd2MbkY3o5vRbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TrbJkrMJNdGK5ReEh5sPKkouDaMRJXMRNdCLdnG5Ot6Bb0C3oFnQLugXdgm5Bt6Bb0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLemWdEu6Jd2Sbkm3pFvSLemWz238fsRBNOIkLuImOjGIh0i3QbdBt0G3QbdBt0G3QbdBt0G3QTejm9HN6GZ0M7oZ3YxuRjejm9Ft0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdONWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpkl1Yk5vkeTWrViNi7iJjoxiIeYDytLLg4i3SbdJt0qS2wUOjGIh5gPK0suDqIRJ3ER6bbotui26Lbotum26bbptum26bbptum26bbptunmdHO6Od2cbk43p5vTzenmdHO6Bd2CbkG3oFvQLegWdAu6Bd2Cboduh26Hboduh26Hboduh26HboduSbekW9It6ZZ0S7ol3ZJuSbd8btXX2TiIRpzERdxEJwbxEOlWWWKzcBCNWG5euIib6MQgHmI+rCy5OIhGpJvRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeh26Hboduh26Hboduh26Hboduh26JZ0S7ol3ZJuSbekW9It6ZZ0y+e2fz/iIBpxEhdxE50YxEOk26DboNugG7NkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s2QzSzazZDNLNrNkM0s2s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0uCWRLMkmCWBLMkmCXBLEHfq2VhEA8xHyJLgINoxElcxE2k26DboFtlyffCD0Pf68VBNOIkLuImOjGIh0i3SbdJt0m3SbdJt0m3SbdJt8qSaYX5sLLk4iAacRIXcROdGES6Lbptum26bbptum26bbptum26bbptujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dboduh26Hboduh26Hboduh26HboVvSLemWdEu6Jd2Sbkm3pFvSLZ8b+l4vDqIRJ3ERN9GJQTxEug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRzehmdDO6Gd2MbpNuk26TbpNuk26TbpNuk27MksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxB3+tchUE8xHyILAEOohEncRE3kW5GN6Ob0W3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083p5nRzujndnG5ON6eb083p5nQLugXdgm5Bt6Bb0C3ohizxwkPMh8iSUziIRpzERdxEJwbxEPNh0i3plnRLuiXdkm5Jt6Rb0i3bbaLv9eIgGnESF3ETnRjEQ6TboNug26DboNug26DboNug26DboJvRzehmdDO6Gd2MbkY3o5vRzeg26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptunmdHO6Od2cbk43p5vTzenmdHO6Bd2CbkG3oFvQLegWdAu6Bd2Cboduh26Hboduh26Hboduh26HboduSbekW9It6ZZ0S7ol3ZJuSTdmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCW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",
      "is_unconstrained": true,
      "name": "is_paid"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "invoice_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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",
      "is_unconstrained": false,
      "name": "pay_invoice",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/+y9CbxdVXk2vk7uzeWe5CYn8ww5NzNhJsxIvMgYIBAJg+IYIEIgAYSAom0daWktzlgEaxMmcUSrdagVg2id2++rfvpvv7a21X5qa1ttqR207d8N+733uc959jpr7732zUmy9++XnHP3Wut513rX+77rXe8aTsM9/bTSz5tuvvGqrbfc8qIdv/hvyzVbL/3Fq0aa1J9+HpR+Ju9nuvGP5W27oKeRI+/4QjloNFz1NCa56mn0uepp9LvqaUx21dMYcNXTOMhVT2PQVU+j6aqnMcVVT2Oqq57GkKuexjRXPY3prnoaLVc9jRkuP40idGa6iaEzKzzvU9gj4l0eerNd9X00x1VPY66rnsY8Vz2N+a56Ggtc9TQWuuppLHLV01jsqqexxFVP42BXPY1DXPU0lrrqabRd9TSGXfU0lrnqaSx31dNY4aqnsdJVT2OVq57Galc9jTWuehqHuupprHXV0zjMVU/jcFc9jSNc9TSOdNXTOMpVT+NoVz2NY1z1NI511dNY56qncZyrnsbxrnoaJ7jqaZzoqqdxkquexsmuehqnuOppnOqqp/EMVz2N01z1NNa76mk801VPY8RVT+N0Vz2NZ7nqaZzhqqdxpquexlmuehpnu+ppnOOqp3Guq57GBlc9jfNc9TTOd9XTuMBVT2Ojq57Gha56Ghe56mlsctXTeLarnsbFLj+NInQ2u4mhc4mbGDqXugJ0LiOCyYaGZMNBsiEgWbBPFtSTBe9kQTpZME4WdJMF12RBNFmwTBYUkwW/ZEEuWSxLFrKSxaVk8SdZnEkWT5LFjWTxIVkcSIL3SXA9CX4nwekkeGzB3eFf/EuCl0lwMQn+JcG5JHiWBLeS4FMSHEqCN0lwJQl+JMGJJHiQTO6TyXcyOU4mr8nkMpn8JZOzZPKUTG6SyUcyOUic98S5TpzfxDlNnMfEuRv5xb/EOUqcl8S5SAb/ZHBOBs9kcEsGn2RwSIx3YlwT45cYp8R4JMqdKF+iHInwJoKVdPqlLvuxzs3Yf3PHbU+/HkyTJ0GxHPtBGoNELl/5V//uIAPmKu+eKp+UGSxW/jIr3yxW/inxTZ7nQ3msi+H2pZ87oOwOoml5HoU8j1Ieq28xfrvnl2zvzCE3vo2G4aBuU4phz8I22dNH7xC/6Ur1faNBeEaP22e6MQR5jF6D0vpFPS1tMqQZ/xPTtxbycd8OUprVJXl2UFofpN2QflqfYL1y8OjGkvIyUqG8nL4vyks/pcWQF8RgeTGM5HmU0gYg7cOUdhCkfQRoHw/fL0q/l7RJoza84Bj0lEvA9BHL6mtPH30mj/HJeD8o8ltaE9KQ98kzBd73CayDqJzlPy79nJ5+Yt9Y+ZagP0D0Vb2VbDYEVp94Z/kT/hwBdTbMMyBv2wU9fVb2TFX2yVu+/fBX7/ro5x/Z+Z6H3jHzz6a9c+rhU151xx3/tPgfl9z74zsesLJnQTsaLpj2gJU/W9Fe/4m+K679yH/eOPWc1z36sj/70wtvnbZky+eW3vnQFV94y9IfvuhXrew5quwPfvO+V7Uefeuu9mFf/9eBc970oxf9y4bJJ/3Z139p4ROv/fkPf/w2K3uuKvsnV/z8Lz7WetsrXn7Xp1550prZWz7wtm//5O+++NUPtf7lrz/40m8fb2U3QJuL+GjnQfk8+3Gt/PnFyo/Sv6BY+UlWfiOUz9H+GVb+QnjZti+vefCRvzj9rq8f/d2fT/mNjVte//J1b/jG5f/wigXvWfm3131wyQdmWtmLVNm/2XnGW3bO33HCPwz+8V3H7F588HeefM/Hvv/T27ee9KPv/+Djw/9iZTepsl0eK/tsUXbBsatPvume/zXnz9cs+78jez5w5NsXPrniGX/+yXN3//g/v/zvUPbi9DMnv0b5vblY+X4rf0mx8qP24VIon0PHR+XtsmLlR+lfXqz8KP+eAy/b/jKjLoyVfW54WXsmW9krRNm1z2j++KHf+JU73F+95+/f+NO1fzByxMxDTp955Dfv+9biG25+3sIfW9nnQYVy9NmSZExIxraRdF6ZTOFXpIm37ty2fdvO20+/5ZatN+8848YdN23Zue3K7VsvunnLVdu3Xrb15lu23XgDAzbo7zMy3id0Foync87WnZc+/e2MG2/YufXlOycTLvuiTfp7Cv09lf5m/8zeKz8v5DGfaxrhqU/nOn3c5LFxukVY2B7zs6ZDWg653mTlW8XKb7XyM4qVv9nKzyxW/iVWflax8qNzodnFyu+w8nOKld9m5ecWK3+DlZ9XrPw1Vn5+sfJtK7+gWPlbrPzCYuW3WPlFxcpfbeUXFyt/lZVfUqz8bVb+4GLlbzc7cwi8NBti2EvhfQ77f3CInUL8JtUlJ73RufhSosftw7k48grLtkSaz0b2iXeTPFitiFgzImLNjIg1KyJWzDbOjog1JyLW3IhY8yJizY+IFZP3MXVoQY9iLYyIFVMmYvI+pnwtiogVU7djysTiiFgxbfSSiFi9Oj6an2W+A/oajYxPo8PvjE6TsBqumN/TJnpcP6M36DrblYPeKB+HBT3lZ1n+ZYH1S+bW1v/p/P3MrVfees0FN17j6OEp9VkZVVzixle/7aka4zboH79n7D6RF5+keWaK0+advXXnVddesuWaa7Ze/YtG3sIlGOnMjPcmlMOirHX6Mqpp2wU9k0KEGvGbVJeiQq2EBtuHQmPGLOXqBTduufqMLTfdcuv2rbhEimLKVBqEiu9UnzagZvhuCuU7k/7eIMo5gY2ytBzSFCcMc7rrbNPyjHKssvxuksi/jLCWiXJW9z5PecTAciwxPqkOkUprR/K0XHb7Q6bCBbVnTlHtKTsV9vE6eXhIWF6M3myfjCKm1cd4vUKkGdbK9O+BDCwr20/5v5R+tihf8mwiGitEffEdLnU+QXVH3rKclOEj4lm98B3iN10puWz4+g3bx3Kyohi9WSF8x/oYr1eKNMNalf49kIFlZfsp//9JP1uUL3lYTlaK+uI7lJP/RXVH3rKcFORj8DYXw2+6UnLZ8PUbto/lZGUxeiMhfMf6GK9XiTTDWp3+PZCBZWX7Kf/fpJ8typc8LCerRH3xHcrJX6TfBzPq23ZBz3bF6xzlXzboOnmXo/xOK7+6WPlrrfyaYuVfaeUPLVb+aCu/tlj5XzbZOwxesp4fDu/zLKGG6rnhN6kuRfX8cKLH7eMQ+hGiLi2RxiH0IwSdIwQdhTUjItasiFiLI2K1ImIt6FGsORGx5kbEmhcRa35ErBURsWLKfa/ya2VErJiyuioi1uqIWDF5H7ONCyNi9aqsromIdWhELN5ejv5BI/0cFOXyzg0Rz+qJ7xC/SXXJSa/h4wu2j+c0RxajN7NB5ZEeYlp9jNdHiTTDOjr9eyADy8r2U/5jUoa2KF/y8JzmKFFffIdzmsNT3OmivhzfySuPWJ55hOVYHsv0F+JZPfEd4jddKflv+ORD8cXad1QxejNC+hfrY7w+WqQZ1jHp3wMZWFa2n/KfTvJ4NNSJ5fFoUV98h/L4jMb4uiNvWU4K8vGsUDkx/KYrJZcNX79h+1hOji5G78wQvmN9jNfHiDTDOjb9eyADy8r2U/4LSU6OgTqxnBwj6ovvUE42pLiDGfVtu7CHdcQwEBv5Et4PjZ+EypnhN12pfm/4+Kj0zdp3bCF6jR+zbCA9xLT6GK/XiTTDsiNUAxlYVraf8j+f5AxpsGxYGtYX36GcXU72CHnLclKMj+5ZoXJi+E1XRi7H5ET1m9I3a9+6YvROD+E71sd4fZxIMyw7wjiQgWVl+yn/NpKT46BObI+OE/XFdygnV5M9wvomT9sFPQ3F6xzlO3iHGIZ9PLzP0Y//Eyqnht90nf1YRE6PJ3pZ/WBtP0HUpSXSkMeYhnROEHRqrBqrxqqxaqwaq8bat7GOrbH2C6wDQb5qHar7sbYTtT7uq1i1fNWyeiDKau1P1Pyq21jzfl/FqmW1lokDkV+1fNX9eCBi1TpUy8SByPvartY6VPOrxuqGVc+t6jbWNrqW1X0Vq5avul41Vq2PE9nGGqu2OfU4VLexbmNtc2p+1f1Yy9e+i1XHOuo21janthM1Vi33tQ7VvK91qMbqZVmt/YlaJmre17yfSKx6HKr5VetQjdUNq9dlwu6FxTvDlhMddT/X8R46WN7yDYlyjfRzUNQvodN2QU/wvWWG33Sdbc5Br+Hjv+KLtf1EUZeWSON+PlHQOVHQqbHKY63rUay6jfsHvw6EetVY+4c+1naixqpltbb3E1mvuh/rNtbyVY8d+2q9apmo+VXLV92PNVatQ7VMHJi8r+1qrUM1v2qsblj13KpuY22ja1ndV7Fq+arrVWPV+jiRbayxaptTj0N1G+s21jan5lfdj7V87btYdayjbmNtc2o7UWPVcl/rUM37WodqrF6W1dqfqGWi5n3N+4nEqsehml+1DtVY3bBqmaixaqwaq8aqsWqsGmt/x7J7y/DOsOOJTt770bC85VN3kyX/2i7ouWRQtCFH+RdZ+ZOKlX+plT+5WPmX291lp8DLRvpp2KfC+75w7GMahOfS8vgO8ZtUl5z0Ru9tO5XocftMLqztzxB1aYk0lpFnCDrPEHQU1uqIWK2IWPMjYi2OiLUiItbCiFhzImLNjogVUyYWRcQ6MSLWgohYJ0XEmhERa1VErJi6vSYiVkxbGFMf50bEitmPayNixZSJmLyPqdsx2xhTJmZFxOpVOxGzXgeCz1SPaXuP9zH1cWZErJhtPLlH6xXTn4jZRhtr1Vw4+dd2Qc+tPNc0DMQ+Dd7nmPeubxCeS8vjO8Rvus52Fplnn0b0svhqbV8v6tISaTzPXi/orBd0FNbqiFitiFjze7SNcyJizY2ItSoiVkzer4mIVfdjPqy1EbFiysSiiFizImLFtF8LImLF5H1MWY3J+161XzFlNaZ8zY6IFbMfY8pXTB2KKV8zImIt7NE29qovF7ONMf2JXu3HXvXlTo6I1at+Tkwfs/Yn9g8dimknYtYrpnydFBHr1IhYMXkf0wewsdbiQCdBuUb6WTIGNtwgPKsnvkP8puvsy1gxMGyf8cXat74YvXZIP2B9jNfPFGmGNZL+PZCBZWX7Kf+2gac/W4LGUUTD0rC++M74M/kX/65OcaeL+rLOKb6fJnBbojzzCMuxPBbsr75QeTT8pisl/w2ffCi+KPmwsqpfmf+h/erD4riwpSfPoCiXgx/9ofw3/KYr1d8NH1+UnbS2j4i6tCgteTZBPk7rE+8mTTAW91fytJ33se7o4IXVDXFPh/c5+mVyqBwYftN19ksROTid6GXx1Nr+LFGXFqUlD/fdswSdZwk6+woWypDxBnnJcoHlcvTTzFC5MPymKyWHDR9fsH3sL5xRjN6MBpVHeohp9TFenynSDOus9O+BDCwr20/57yN/AWmwv2BpWF98h/7CO8hfUDpUVB6xvOXb3+gMiXKsXwXlL9juGn7TldLnhk/eFV+UvFtZJafM/1A53RexTP7O8NDx2RVFB8ufUdOJTmd9STrrA+mMlKQzIugMiXJsh1BOw+1C469C7ZDhN10pu9fw6aHii7XvrEL0Gt9pUHmkh5hWH+P12SLNsM5J/x7IwLKy/ZT/f9E4jzR4nLc0rC++w3H+qzTOY315XprX/mF55hGWY3ks1l+uFSqPht90ZeR/TB6VfCi+WPvOLkZvekj/Yn2M1+eINMM6N/17IAPLyvZT/r8ieTwH6sTzlXNEffEdyuP/TXEHM+rbdkHPhYrXOcr/9aDr5F2O8sdY+XOLld9l5TcUK3+olT+vWPlPWvnzi5U/y8pfUKz8x638xmLlX2PlLyxW/jlW/qJi5V9g5TcVK7/Gyj+7WPl1Vv7iYuV/YOU3Fyt/rpW/pFj5T1n5S4uVv8nKX1as/Fus/OXFyp9h5Z9TrPy/WvnnFiv/Nit/RbHyP7byz4fyedZUrPwLi5Xvs/q+AF+KOhm+jXXPg/yNjE/D4jSj1SSsnHVv+OqO9WN/6QVAD9uYhfWCnFiDIq1InzzfZbcL8Yc8dVH1PBS+l23zoohYZ0XEmhER6+yIWOdExDo3ItaGiFjnRcSaHhHr/IhYF0TE2tijWBdGxLooItamiFjPjoh1cUSszRGxDo6IdUlErEsjYl0WEevyiFgxx47nRMR6bkSsKyJiHdWDWMljsloy3rGhZLzilJLxio0l4xWbS8YbTi8ZbzinZLzgzJLxggvM1342vGyknyoWkMPvv7BBeM7p+ZPhN6kuOemNzp8uJnrcPl5v3Czq0hJprCObBZ3Ngo7CmhsRa0lErIURsVZExJoTEWtRRKz5EbFmR8RqRcRa0KNYMWV1XkSsmLw/NyJWTFmNqY+rerSNMfXx1IhYMXWoV3m/OiJWTDsRc6yNaSdi8j4mv3pVvmL6JjH7MSbvDwQ7sSYi1oaIWOdHxDqvR7EuiIi1MSJWTN6f2KP1ujAi1vSIWDFl4qyIWBdFxIrZjzHrFVNWe9UWnhARK6asxuzHmPXqVX7FlNVNEbFiympM+7U2IlZM/2tmRKyYMYWYPnnMuULM2KP59xbHvhDKNdLPkjH86Q3Cs3riO8RvUl1y0vPG8LF9vDd6czF600L6AetjvL5EpBmWrd0OZGBZ2X7K/9ODnv5sUb7kYRt3iagvvsO90T85aHzdkbcsJwX5uCRUTgy/6UrJZcPXb9g+Xuu5RNSlJdLYJw7lt8KaERFrVkSsxRGxWhGxFvQo1pyIWHMjYs2LiDU/ItalEbFi6lDMflwSEWthRKxVEbFi6nZM+YqpQzHt6oHA+9kRsWLaaLOFdi4R/ZmlRCev743lLV/J8y4XlzzvclnJ8yoXlTxvcrb5Vc+Fl430U50lyeHjvaZBeM5pn9Lwm1SXnPRGfcoriB63j33K54u6tEQa7x9S5yGeL+gorLkRsZZExFoYEWtFRKw5EbEWRcSaHxHr0ohYMyJixeR9r8rqqohYrYhYMeUrps2ZFRHrQOD97B5t44IexYqp2/MiYsXk/bkRsWLKaq/6ADGx6nE7H9aSiFj1uJ0Pqx639x7v63F77+l2r47bMfnVq7J6akSsmPyKaXNi8n51RKyYOrQkIlav2uhe9SditjGm7xuzH2Py/kCwE2siYk2PiLU5IlbMOPklEbEuiIh1QkSs8yNinRgR66yIWJdFxDoQeL8hItZ5EbE2RsSKya/LI2LFlNWYOtSrct+rbTwQbGHMetVjx/4xdjwnIlZMXy4mvzZFxLooIlbMsTamTMTkV6+OHWsjYsWc882MiBVzTSdmHCBmfCLm/hw+Y4N7wxrpZ8k7j6c1CM/qie8Qv0l1yUmv4eMLts/4UvL+36EGlUd66o5f4/ULRZphvSj9eyADy8r2U/7zmk9/tihf8rCNe6GoL74z/iRnbM5qjq878pblpCAfV4TKCd9HXVAuvfdRK/1R/WZlWyKN40+h/FZYMyJizYqItTgiVisi1oIexZoTEWtuRKx5EbHmR8S6NCLWwohYMfVxVUSsmPIVk18rImLFlK+YOhTTrsaUiZh2tVd1O6Y+xtShJRGxYurjgSBfsyNixfQB+AwX+st8hivvHdhYPuv3Riw9eUr+Hs1bGoRn9cR3iN90nW0u4rMr/iu+WNtfJOrSEmkcz3uRoPMiQUdhzY2ItSQi1sKIWCsiYs2JiLUoItb8iFiXRsSaERErJu97VVZXRcRqRcSKKV8xbc6siFgHAu9n92gbF/QoVkzdnhcRKybvz42IFVNWe9UHiInVq+N2TN7H9AFi2uiY/kSvymo9bu89u1r75Pmwap9878lX7RfuPfnqVb8wJr96VVZPjYgVk18xbU5M3q+OiBVTh2KOHb1qo3t1TIvZxpi+b8x+jMn7A8FOrImINT0i1gURsTZHxDohIlbM9aGY/NoUEevEiFhnRcS6LCJWTJk4PyJWTN7H1O2Y+hhThy6JiBVTHw8E+doQEeu8iFgbI2LF5NflEbFi2sKYNrpX5b5X23ggjLUx61X7JvvH2PGciFgx/YmY/Irpk18UESvmWBtTJmLyq1fHjrURsWLGFGZGxIq5bhUzzhQz/hVzfyGfwcS9rY30c1CUS+i0XdAz1CA8qye+Q/wm1SUnvYaPL2qftLXvxcXoTW1QeaSHmFYf4/UWkWZYV6Z/D2RgWdl+yv+VKU9/tihf8rCN2yLqi++MP8kZzC9MGV935C3LyYvhfQ4+Ph4qJy9OvzddKbls+PpN6Y+1b0sxentC+I71MXpXFqPXZ311tcC2umxN/x7IqIuV7af8f0HycJUo06K05GEZxLQ+8W7SXsK6WmAhH61PEt34RsoLJf/Jv7YLeo5lu2AYiF1QFi4P1S3Db7pSst5gO2b0smyMkiMr2xJpHC8r2vfJ91U9itWKiDU7ItalEbFi8mtORKy5EbHmRcSa36NtnNWj9VocESumPsbsx0URsWLq0IKIWDH7MaasLomIFVO+ZkTEOjgiVky571WbE7ONayJiHRoRa21ErJj8iumbxJSvXvULY8p9r/pyCyNirYiIdSD4cr0q9zF9k3pMy4fVq75cr9rCmL5cTFsYsx9j8qtX/a9zImL1qv81MyJWTN2OqUMx+RVzHIqpQ73K+5j2K2ZcrldjQzHlK6bv26s+Zq+OHS+OiGVjxxBhW3rylFxvOrhBeFZPfIf4TdfZzhz0vOtNL4Z3RdebeD97r9jDmHrUq7HymDYsJla93pQPK2ZsLqYOxezHmOsBMX2dXo3DxJSvmPXq1XWdXo1RxOzHmHsVYtp7vjsVfaOlREf5IVd66GB5yzckyjXSz0FRvxz+0h0NwrN64jvEb7rONhfxzxT/FV/U3jUr2xJpvA/ft38L6SisuRGxlkTEWhgRa0VErDkRsRZFxJofEevSiFgzImLF5H2vyuqqiFitiFgx5StmvWL2Y8x6xbSrMWUiZj/OjogVk/cLehQrpp2YFxErJu/PjYgVU1Z71Z+IiVX7AHtv7Kh9gL1Xr9oH2Hv9WPsAe89O9KoPEJNfvSqrp0bEismvXrUTqyNixdShXh07etX37VX5WhERK2Y/xuT9gWAn1kTEmh4Ra3NErJjx+0siYl0QEeuEiFjnR8Q6sUfrFbMfY9brrIhYMWUiZj9uiIh1XkSsjRGxYvLr8ohYl0XE6lVZrfVx77WxV+WrHodquWes50TEiuljxuzHPHcPdcO6KCJWzHE7pkzE5Fev6uPaiFgx56IzI2LFXLeKGZ9YEREr5n4mi3XY/kOcy68nOtMFnekeOlje8g2Kcm0X9Jxq+/dOgJcNwkV73BeO3d8gPJeWx3eI36S65KQ3unfxbKLH7TOeWtvPFXVpiTSOyZwr6Jwr6LRE2qYKsAYz6tl2Qc+lqr9zlL+e+WkYWDecr+bo2wWhsmT4TdfZf0VkaQPRy+oXa/t5oi4tkcZ9dJ6gc56go7DmRsQ6u0frNSsi1sqIWDHbOD8i1uyIWAsiYs2LiBWTX6siYh0cEevSiFitiFgxeT8nItaiHm3jmohYh0bEWpt+nyhfVdEZKUlnRNAZEuUa6WdJX+TwBuFZPfEd4jddZ5tj+SKKL3l9EY7d9Mo4fWpErJjjdK/amCURsRZGxFoREetAGCt61W+OWa/FEbFi+jUxfd2YMjEzIlZMmZgRESsmv2Lar16dZ8Tsx5j16tWxI2Y/xuR9TN0+kOYsvcavXh23Y+p2FWOtzVdwftNIPwdFuSrmaobfpLrkpNfw8QXbx3O1jaIuLZF2EXzHNKSzUdBRWHMiYi2IiLU4ItasiFhLImK1ImLN6NF6LYqINT8i1pqIWIdGxFobESsmv+ZGxIqpj6siYsWU+5i2MGY/zoyIFdPmxJSJ2RGxYvJ+YY/W69KIWDFlIqZvEnPcjtmPvWq/YspXTH3sVRsdEyumfM2LiGW8t/U7nI9dQXTyzgmx/HkTTEfNL5N/bRf0XMnzN8NAbNzrlWMueVWD8JzTc1fDb7rOfisyd91E9LLkxNq+WdSlJdJ4D+9mQWezoKOwTo6IdWlErFZErMURsVb1aBsXRcSaHxErpkwsjIgVUybOjoh1IMjE3IhYsyJi9apux+R9TH7N7NE2roiIFbMfY8r9vIhYMeV+dUSsmDKxJiJWTJmo/a/9w0bHHGtPjIh1INjCtRGxYtqc8yJinRoRK6YOxeRXzDGtV/3CXh3TenVuFZP3MXUoJr9i2uh67Ng/xo6Yc6uYtnBGRKw6prD3dCgm72O28eCIWL06H4rJ+zkRsXo1XhjTz6ntRD6smP5EbSf2Hu971U6Y/8V3ZiRP2wU9DVs/PR9fEm7BtePJDcJzLmzt+Pxi9Lxrx9i+omvHsdaqnOu8e6XXsGzvA2JfSHQUnzd56GB5H52NJelsFHSGRDmWc+zrHHI3ECrnht90pfSq4etnxRdr+yWiLi1Kc65Tni4RdC4RdA50LJNllCO+vyCvbmJ5yzcoyrWd9+m3LywLho24eOdnFfbe8JuuUy6L6MFlRC+r79TvuFvZFqUlD8vIVYLOVYLOvoKFMmS8QV6yXGC5HP10UKhcGH7TlZJD7+/HYvtYLq4WdWlRWvLEulOyxiqOxbps+Mkz6Dr7M4f8nBoqr4bfdKX0o+Hji9Jja/tWUZeWSOO7VbYKOlsFHYW1MCLWnIhYKyJitSJiLYqINT8i1qqIWLN6tI2Le7SNsyNiXRoR69SIWDHlK6Y+xpSvmLYwZr3mRsSKKfcHgkysjogVU74W9GgbY/J+ZkSsmHI/IyJWbSf2DzsRs40HR8SK6U/0Ku/XRMSqdSgf1ok92sYDQYdi8j7m3D3mHNnWRKeLNnMs/kRB50QPHSx/oofOSEk6I4F0LixJ50JBZ0iUa6SfJeNqgw3Cs3riO8Rvus42x4qrKb7kjavxenBRuU2eTTXWXscyHUP5ZpuRN3aN5a/20BkpSWckkE4V7RkU5drO+xxkX1jnDBtxXwLvq1iPNPym69TxIvbmJUQvSxat7deIurQoLXlY5q8RdK4RdPYVLCW72Pcsu4rPL/HQwfIv8dAZKUlnRNBRspz8a7ug5xVW/ppi5Y8wWbsWXrKebYP3OeT+glA9M/wm1aWonm0jetw+1rPrRF1aIu0s+I5pSOc6QUdhzYqItSoiVisi1vyIWKsjYi2MiLUgIlZMfsVsY8x6vSQiVkxZnRERK6Zux+T93B5tY22/9g/7FbONMXm/OCJWTLk/NSJWTN3uVX2MaaN7dayN2Y+LImIdCOPQgdDGmPWKaVd7ddy+pkfrFZNfJ0fEmhMRK6Zv0qtjWq2Pe6+NvTpuHwjztJgycV5ErF6V+0sjYvVqrGNJRKwqbLStCeB4eS3ROVnQOdlDB8uf7KFzfkk65wfSuawkncsC6awvSWd9IJ1LStK5JJDOiSXpnBhIZ6L4trUkna091p6RknRG6vbU7enB9lxRks4VgXRqOejt9tRyMJ7OSN2efa49g6Jc2wU9x9lejrPgZYNwC+4Xm94gPOfC9oudVYyed78Yto/3sWwTdWmJNOxHTEM62wSdlkjbVGPVWDVWFKyJ2ts4KMq1nfeZZl/Y1hg24mLsJIfdC96Xa/hN12nbithZFRtSfWdtv17UpUVpycMycr2gc72gs69goQyZ7GLfl90vieWv89BZX5LO+kA620rS2dZj7RkpSWfkAGjPoCjXduOeSX88+4W3Djz4gquOWD3trJ8smPX21z3z83e99pmrD2d7YdiIux3e57Bd/aG20vCbrlN3i9jK7UQvy1ZY23eIurREGp+Z2iHo7BB0FNZ1EbHWpd8PBD29viSd6wPp1Patbs9esddP3vLth79610c//8jO9zz0jpl/Nu2dUw+f8qo77vinxf+45N4f3/FgSZt8uZXfUaz8bCt/Q7Hys6z8jcXKz7TyNxUrf6aVf2mx8qdb+ZsLlW+M9v0t8LYdVHas7TtH0XLVfcTK31qs/FIrf1ux8v9t5V9WqHzjx1b+5YXKu/+y8rfDy7Z9Wf+Jviuu/ch/3jj1nNc9+rI/+9MLb522ZMvnlt750BVfeMvSH77o16zsK4rRHrLyryxWfqqV/6Vi5Rdb+V+Gl+2gom6Slf0VoD0pvPyglX9VsfInWPlXFyt/opV/DZTPwbu2lX9tsfKj7X9dofKN71j512Ol0s8V3/r9g/7tfW/q/93/78c3vuxf177tK+fc9dj7n/HWrx+x/tWbv/uOf9xoZe8oRNtNs/K/Kmh3qfeorfu10Tf5YtpW/s5i5Sdb+V+Hl2378oPfvO9VrUffuqt92Nf/deCcN/3oRf+yYfJJf/b1X1r4xGt//sMfv93K/oYq63/6rewbVNk/ueLnf/Gx1tte8fK7PvXKk9bM3vKBt337J3/3xa9+qPUvf/3Bl357VNZ/M82es81zrPxdxcoPWPk3Fit/kJV/U7HyTSv/5mLlp1j5t8DLdlBR17KybxVlZx/jvr30O8fffti8E2686LbXf+eSD/7KnAcO/X5rwT/e+ozb/uPPb7SybxNluzzHT/7Ff4elF8CZDzqYJibfh+F78q+Z/p2UMx+0DXmsbD/lf/nmsXJHpfSGqIxhODfmpzbhfY6+WNggPOf0/N/wm66z7UXm/02ix+3j+f9UUZeWSFsD3zEN6UwVdBTW2ohY8yNiXRoRqxURa25ErEURseb0aBvnRcTqVflaGBFrRkSsVRGxYspXTH6tiIgVU75i6tCsiFgxZSKmXbXzS0OiXCP9ND9gCN7nGJcnNQjP6onvEL8p6lnEDxgiell8Sd5ZX9+6c9v2bTtvv+DGLVefseWmW27dvnUSQrvx3hBzBVHxXcONbz2m9dG7KZTvbPp7gyjnBHYf0D0E0hQnDNO8T2zTIRnlkBdOvJsk8g8R1pAoZ3Xv85R3bkxim0Q/efaWxBb0lL0Si+1jz/UQUZeWSEMeZlkM5SHnrddUN2adUk06c+uVt15zwY14h9ZTTz/9fVZGFRdQvg0ZVWsI3Ab94/cL6F2f86uqb7IUIjLJw8YYJzttolMb49oY7xvGuE+UY4mZLt7zlvC8rswVgp6i88KSdF4o6AyKcm378poHH/mL0+/6+tHf/fmU39i45fUvX/eGb1z+D69Y8J6Vf3vdB5d8YFYSgnkrhXyQ/4NUX+t3DPmo/uqn/J+/eKzcO1J6SX3N5U417Fm3br/+4q07b9629batv7DVuDg1yiIH5FgtLqS/LxLl1BMyhhc0PMGGzvBjjeFKtLLGynBDxwKBXEFUfNdwxQ3dRfR3EUPXzWtgQ+czTtgrg4KuvZvksg2RMmIca/QZMufqobm4xB7IQ3OIxIYOzVkSmzU0c7nJLlvC+ynvR9Mho6Rkj/t1G65jPQY8/dRjwL4yBvSJciwxPqkOkUprR/K0XHb7B10nP9r25W92nvGWnfN3nPAPg3981zG7Fx/8nSff87Hv//T2rSf96Ps/+PjwkyW167KSVuHSxBJ9kZxgjFrw5G44/Ttr3dPK9lP+1nFj5b4KTvDKND3VvMu2bN929ZadW8+64aW3br1169UX3rhz6y2n33D1WbdtvWFnbpf4HPr7XFFOPcYIbPw0SpsCaazoU6iO/I6FqiHawFhZDDesfsr/jZTJyU35Z982HlMpEgr9Bk9bfTM85kPeGV4jkM4RJekcIej4nMqixkLVmeNX2J9JH//VzLH3qNjY/2hoNqaf/ZT/v9aNlfuuZ2NDVlgSBxEc1LJifwNujCeYZ1JG/X4A8rmB5HMStRnbqeo8BDSYbvJ9XUYd/oFcq2nU9rYLe5RrxfYC63M01R/5q3jOcoXlORyd5YDgp9Hhd0xH1dnoDEWkg4NXO/1ufMM+YedrGtHhd7447zRqT0PUIZG/n83UNFEfld3qp/xfAH38b48+TqL2Yx8MUVqWA8V2LMQmhtiE0DHI8g+kfnXoGIR2jcegSQH163edOpV8PwranIXlxDvLj+PfFMo7RHmnevJm2a3kuzk3VeuXTdGVfh1H9curX1g+VL/mztI0s/TLNr6zfn0Y9GvBrPFtxMV65ivyhvOeTXlnQLtDcSdT2eTZRHlbhIsy+Vw3vr2G+7pZY/hL0+9DglZZ2cFNOSw7OO4dD98xzejwO6aD5S0f6wLLzupZmmZWhJ5lx/LfALxcOyu7jTOoXjH4bO9nwXumO5Pyzqa8uEmmRXWcRWXVZ7c6tgSd2YQ7x1P/FuHMEOWGnG6r+gyt70xR3yGn668+Q+kg1hVEJ0t2n0GyOwfSlOzaoZN+yn8GyO4zSXaxPMsutnUdpeGYgHbsPVRn3OhlfHqeKGv551F+xEgenlvYClnW3MLK9lP+c8HvsLmFtW2OoJe07byMtmF/4EbAeUTb8l8L/bGR+gP5Zf0x3XXyhnVgPtSF856dwYNLoR4Xz8qmxXqh2phgXD4rO9/ZIh9jTBI8MAxlF6zcdEGPdXcu0ZjjoTFblFM02B4jz+YDfZONBV3S54u2OfFuksg/N6O9TtCe1wV3jsBR9n0epc0UaWy7sL3oD5meKZuIdu8ZHn3J0gklV3M9deeNrnNF3ed46q74h/bD5zfY3yFjfUP8bfXDw5dsY02+B5weR6xsP+XfKWwmY6ItxHrdloH5MsC8gDCVzBwP73j7m6+fsD7TXbaeq7qjLeF3Pl/GiTqgLVQym+XHMT9UHWYJHGU3Z1N9lB8eqpvoT68+QOcYb4g0x7gP5qdv3MfnGBwz74U5xlTCqecYzu2KNMe4CWT3gYJzjGMprdscw9KMv5NEuWlUX6P3NfB930d4DaCFcpM8fOHZLMB3ok28rmD5PwTj3kWpQZguyj+DcFkm+B3LBJd3nnaqMYz59uW03oOuUxdzrIec7pN/w55TEDtEf5TOq/lDU6T1B9Tlhn/bsm7LwCu+zHpldeF3Ib7MM0R+4xXPm9su6DkNN284oq3WzOZQ2mRIszokMr2W6je3YP1C+If4LZH2y/A9T18orGkRsaYWxJrpxsso6qGy9xy7UXHmpB//juw26sopVNeGqKvPDnF5J/5Wdkit2yTP98kOYZw9h3wd5/NPDHt2QexQO5TlE2C9miItxA5d+/PTb/rcxd84uOE67W2feMd2SMnkKSJ/ST0/WtkhtjVoh2ZTGtohq4OyQwXHlKND+If4KpbEdii0LxTWtIhYUwtimR3yrS2gHWL/boZoD9ohXs/6CfhsP6K5JuoT2zvlv7GPqdJaAvMpOQNmoL0aSD+fDWm8Hqjm6A7aYO9Q1rEMr6Nb/v8A3vyU/FnUaWwn1k/1F+6x+dms7HwzPPmwX7j/1Tq4z/cP7RceK/rS94NEK6cNkHt4DCtpi/k/6UbFc7bu3Hztlpu3Xr1561U3b93JOxEb9HfWrgEsx49h8GnKg+hv3rE2jf5uCZxuNNUOk5PgO9MN2WFykqjz3qRzWkk6pwk6yio1Mj6NDr/z7SI8jdqDmsTXcebdvYHlp3nojJSkMxJIZ19ujxqBrI9LerXDIXKE+E3X2eYiBypaRC+LL9a+GcXotRtUHukhJnsjKsJhWDZoDmRg4ciM+Q9NRxcV7TuKaIRGo5PRbMXs8XXHUbwN+Q6bPZ6G2g2MUd6LqR2W/7ePGSt3ZIrp21mndn6f7sbXJe8udyw/paYTnc6zStJ5lqAzJMo1Mj6NDr9jOqrOvnGz5BGXmaH2cm8d6Sy5+3xGyLiF9VGeNq8im20cyMDiCLLlv5DsJdJge6nGE3yH9nID2Sysb9auWsQdErjKv2IeoXy0oT6bA+wyyluWXd4Edvkyj12eEtBGdUpD2Qnu62ldsC4mLCzv86umBNDx+VVTAumEtMdHZ2+2x6cL2AeXeOrFvs6MLlibCQvL8660SZ465z21guV9pxxaJem0AulMVHsGS9IJPR0ytSSdqYLOkCjXyPg0OvyO6ag6d7O3v0T2Vp1IQZob008+kbIe7O2ryN7mbX/JeU6wX2L4TdfJvyJ+STf7wH7JzGL0Rv0S37wI68OrNczb5J/a3YZYuGKP+e8ivwRpsF8yS9QX36FfcifN46raFTVR+tgmOln6eDfpo9oV5dNHy78K9PEejz7OoDojb6ZmtAfp+myi8sl9utLy5FeyrnyCClcmg+0K74IouNtj1K6o1USlN1MhbxpNP33rLccce9KZvwil337TzqxVStat2YTLMqf60NrGO3omCRrJszEDi+3STHqvdgx1q1O3vN3SlU8wK6OdzoX5BGp1irGyToVa//RT/velCaGnQlGGQk6Fsl5zvj7RhikZ5V7rdP2szVgn1WbL/xFPm6d1aTPPv7B+06gc+qTqJD++H3SdMoAYisdnuPF1zytPWH6ixrQziE7WmPYZGtO6nUR9XfqdT6LOhjFtD41pypevuv08/xgU7Xod5OF5BO6yVJi8C9Lyf5lWZguud8iVWY79N0T9n7pqhvpUtd3Xp6P5oU//KKBPffrhu+RX2YIhT34VN1AxXp9/Ws7Pb/xViIwifpPqklMeRv0N5adj+4r6G4b7HWgQ1r+bv8HlfP4G583SPfYBWvS+m7+h6pSVt4y/MSOjnc6FjQ9qzsPXa+WUl7bVZQrUQ80ds27QmOQ6dUvlVz6G2u3Itqjf6XG4DemY/2/Al7iYdpdj+TMz6udcWF9g+Ykaq84kOlXf8q3i43iCGdOMTpaNbYnyvvW6GSXpzBB0QmX9Nen3bj7RkznibkiX/d/fO3qs3L/R+Il1D4mjqnGX249y4xt3VWw+y1/qpqfKP382YeXdY4TlfbfeqLqzX2b556WDYcl11U0V7nHZFKLjiK/WNK1eTZEWsrv6h81nfOXvP3rfHzeovNWF34XEjp4t8peMs25Uu6sxppo8KCMtSsPd1VYHtbu6oL+2MYR/iK/Wcfhn30P7oiXSNhTEsh3Rau1xb9mk0Bu5LP+SVPdDYy84/mzwtDXkalfnOm2Oc9ly9D/0GJ7x/yBBC+Ud8y6Hdl962/i6Dom6mo3o89Bw4l3DZfOGaUwSZV/vxtdtWkDd1Po1Ygxm1DPB2Jvr9heWpHOhoOMbk/jT6PA73zrvhUQHMdvp90Qnj58z9h7tSZbfdEf6vZ/yPwB+00kppjrBxWvZvAsebULysA208qG3eFr+00Cvut3iie30yVnoLZ6W/1nkz1QRZ+I29btO25o85zndpqx4MfNAyUnbk1+tN6Ess8327Xm1tj1//lgdNszJ1/7zMzCfPW8M84KcmBdkYL5gzhjmRR7dONeNp8f6z+9Y/7l88gyJcvZ90HXKbg45DL4w3/CbrrPNReJpKj6g+DIENLguLZHGY6Oic66g0yCsbvWa6sb0p+QPnxnkfMq3IaNqDYHbcFrk7O/59E41DbETMf9BetOTiTmayhcTPtalT7zjLsPylk/RWVqSzlJBx4f1YoFl+SeL/EtF/oiiYelLIA9baa4a43YTDcbOEg17+ohm8p1X/7hruI7TBUbD06Y+8Y67uiFoKTpXlqRzpaDDXsLryEtA+jms5a+Z9RuAl2z5C0aqfw35ZY+y/IY/JOhZvdQPuYdEPdY+9sv3n7r82osaVN7qwu9YJdUs8kqRv2T06fUq6oG7CZNHRcZU1MPeqahHwVMArw/hH+KrKDVHPfJGENR92nmxLOoxAOV9ujxRNqMKOj4sFQmx/MabAadXitgmWf67YPb0HIpKKH478W6S67RHz0k/pwus9Rl1V7QNP3nUqUrLV6FNnIz9hPXEd4jfdJ1tLuINK/1QfFHn3a0s76xOnk2QL8te+lYEeh0LZXPIdcpvI+PT6PA75nOMFcGYp7T5zoQyWCpKdgJ8xzTD4nfcL1h+GqVNFnTUODRAaci3DZSm7iZSdojtd1471BD163aa9qNzNE11mhZtONvtv5s7Vu7jc7LbmHUyqV/UHfnFvuunyXedDmVy2DYZ4TKsbrz7TA7eJc8l1BbL/3Xg3R4P73jsV5Hw6a6TH3yCWa0INijNubBVJHXqakiU47Gv4MpZ8NjHJ0QKRkC9J0R8J/0Lrlz2Gz21k0v1wwyneZp1AsQ5bevYnqGta1EajmvTKU3df+SzZ2oVcrqnfhNlNxWdK0rSuULQ8fmJIbKu6Kg6d7Nl3yFbplZTsewr0u8cnf402LK/IVuG5bn/2DfFsSZ5suZqWaszUzLq933P6oxq8ys8dUYaznXqDY9dlv9HNHYVnE/LsYtPD6pbCkrSLfzztQXvofL+fK3aDZbk652fr21SvnPp71g/X+vbl6DW6tWsfFDQ5bV59cuXvj0OVvc+T3nEyNov0pdRLvn7DaJMzHs6Ys5oQvaIFfRmZ4dqpuHHugdpOtHj9nHbW6Iuao8T/9Ru0T1Oyff+SFjJs6nGqrFqrBprL2D59pTxLCx5+Kxk1l4iTMP6+RausbzlGxLleHwrON5MDx3feJ9zfzF6o+ObijAqvpQcv6f5xlPE5L19voiOurcKsaws31t1cjqTiynXyczquLnj617VvkTfho0q5R7r3k6/J+0+fa6mmbX/kWfYlv8DMMM+c+74OqsZdhYPUIYMg9uE5zwsLY++JrPs59GvDWK9eJVRyT3Ouu9Iv7dcpxz7ZIGjLVl9dBH1kdqv2RD14X14d0MfXZx+V/vwQvaBKXosQwMZ+XmPquW/PK0TrrKq+k3JoJcVFbohg97zgN4FIA/WTke0S8rdbCV3qM8sdyqSp/TfNx6gnPpkkWk3BJZvX7KVH3C6Dwyvn/K/RPR5qJxzv1r+bYH9GsmeyH5FXoXsWsD8zDclB2qHhYq0shz3CSzsa+7XbrpseKxbOz39auWxX7Ge3K+W/2WB/Yp+j+Fgfdsu6JH9irziPlDjNeYP2RTJdU0etTJyEKWxTcTvyn6jHIT0ueIv9/nrRJ+z76/sQuh+5iS+Zve2pBHUzTtvvHlrGkJ19PhCng2XfQ3fLFHeUdkGvePre5T59G3yMtoDTocc2Xxa/t8QLPeZ3+QJ2RKP3V1FEN7exdoS382scajPp2Y+l3wviGrynJtRjYYo7wirId4lj9qmjrjsBfqsm2IVn1Ti/IbHeyju9YwcPg/HiTr4IsBYH9X+6ZTmO3lneXFEQzHiEc3y7w4c0Yx2FSMa8ohHNDWDxvzMb98tfMiTFuVH3qsRbTrR6aaG/Fu5Sk7VzErJi88z8/FHyZc63a32xvhmwZavilkwtodlIcYNi+rGmhblV3Liu0W5m9flkwWcOXIkRO0r9c2A1I0bOITzrNzyf1bYAMMc6tK2kBmgOjXtu6FO3R6OkQrDdpSvpDxOU/KI7QmJyqjVvVBd9a3S8d5/nGFx1BPp4t6N70zwHrqsXwrIipIYLkdcvwlRo++TjoTeomr51f4x1HveX4v2YlYAls8XUL+nN8tDO+u355k21xN/r9xoWVqkcXyy0hW0z6wrPlucPCG8Uv3UovzIm7z7+fhWkdD9fC1oM8unipwoG650F/fNfoZ0V/mQPhvs2/eN5XHfMdbhn2CM4NtAuu2NviMD8589445qQ0O0IcQWK91C2+fzs9kuou1ju6jstbIjbBfVbz1ift4vZ/n/K+WfTZkL3sos98uxrcPbA5XvxXu4Lf9sOM1vP4zoGw9CMPtSnAmas/RXbeu6jUnGk5br7Jus/aKIpfYSs54NOD1fMjyeI0+HPuBIG/KDbSraW7apUwVdZW/xtz6PSevB/lryvQ355pLsqfky2hyWPct/HMjzgvR7TLvBt0ShHeB5ne9X75KH7TyW519SiH/ba/iZhNi3vSr9UzGDknZz9EyC8lVUP+CZBHUOAbFw9dxwLU+Vds0Xi+nGVz7fhW1kfUZstgMhPpmil+WTHUO6H8sn+yj5ZKhfrP+o46z/6hcq1ByA/YZZUBfl8+CYjflPBRt2IfFGybIvxqJ+yUH9Pvl01ynrcwKwfLG+uSL/HA9trBeWZdpZOql00XhTxXwK/QLWRd9cMnlCeKX6qUX5kTd5dZfnYb5faUHZxl+IuTBj3MZ24LjNujtN1BX9AZMN7NPnu/E01dIOvuNxFstbPkVnaUk6SwUdH9bzBZblVzHMiq/HsSouhzzJ+7anaozboH/8nrHVVBIf1U2NjHo7F9ZNDaKvsCbD94shD18KjeblBYSVd7MeluelMKvLbamaDAr6Oczb23zH+w274DUMb0P+2qPczKyjhVgvdSVEyFU4v//Is6d943MnjV7lEnoE0vKrUP8LRP6SV+G8WQ1hfN2NOnKe9yqcgld4vDmEf4ivwuFnw/c8fdESaRcXxLKrcJBfvPG2ahtjumzm+pUwZT/7tr1TFxuOXy3q4rNjDXjHG/ex7r7NzdyuvPayEUjnhSXpvFDQ8R0eCLF/io6qc7fj0HeROzYZ0lTo95Xpd950uQEuDn0zuWJqE3nD6fEHx8jkYX3lTaGcZ0pG/e4G+eTj0KrNr/TUGUNoznXaBQ7vWv57aewtaFNleJevhavgOqbgnVh76zqmfMeheQKGXEFUfNdw41uPaX30jjdcnU1/FzkOrX4mZEBg+q6kV6NvnkvGEFdtSphMdfeN9oihFvUMQ5VL/r5dlIl50cREHa0ueVws+Gc/+bhYQa/Te1xM/WQZByOxrApms/fiOyaGdHyB8RhYUyNhJc+mGqvGqrF6DkvNQIcoDccDW1hUsxeOCuSdeWF5yzckyvE4UvDCm2mh4whfeNNXjJ73whvFl5LRkqEGlUd6iMmXC2X9tC7K0EAGFm/AsfzfTWcDvCE1eViuQzcAJT7UX9ICeoyLLlXA3/JPtNxj3dvp96Tdfz9P08w66sczWct/Csxk/3He+DqrmWwWD/hCataR5Klig6vv+KeSe6RtR7F9R6yULIQeDf8P6qNuxzH5aLjlXw599HOKNmB5PlTR7djxKyi/9VPosePRPk7r1+3Y8UAGPRV9SZ6NGfQmA70JOHY8U8kd6nPIMUal/77xQJ2hUrLIxxh9R1cbgo5vQ746xsh1d67zGONMIQ/sS7BsZNVP8S3yMcbBjGrMEOUdlW3QuxkZWIaT/I3hh5BjjOqkMpuIBYLlvi5LnvoY4z53jPHsjGo0RHlHWA3xLnm6HWNkjfWxWLHKrFXoAXjLv0aIdIjFdKIOyhNgzzar/bylUW3zZDrqYH7y8Ihm+Y8KHNGMdhUjGvKITU5o5Mvyd9vOzqrmO0akZqahahh6jJE9NSUvvmOM3Y6NsXxhn/qOjfm86v3l2JjxRh0bYzlRx+1CTb9PFtAT/fuMNULERVnIWmNHG4A8vCP9zutlG4UNMMzBLm0LsXdq1UIdJ2F7p/YAKHm0fCXlcUjJI7Y/ZJbn+9mmbrrK9kddOKVcBHYju8mNb5surtHeRTM+pMOyl/dnky4W9Vd0lpaks1TQ8WFdLLB8/V3xVj+r4mLIk7xve6rGuA36x+8ZW6k5Pqqb+jPq7VxYNylxVnQaJek0Auk8tySd5wo6vJXndanZLbld4HUhC54FT6K8Dvllj5pN4clZpmf1aoq0kC2C/9i69Avbn3z4fQ0qb3XhdyGnxJ4r8huvcHd3Dl69Wg1NRlttEeTTxji8WB3UFsGCp25eHcI/xFenUXgaGNoXLZG2oSCWbRH03Y5Qtc3gLYJ3ggvFWwSrrotyVVj/Cy7kBC9UsY4XtGUN31Cr+FJyQ8foQpVv4Qfrw7etMG9RZgcysKwsn0q+J5Uhno4kT5n7cd82f3zd1TgR0s+IqxYuWB6ztkL+9vzxbVG/koJls34Z5i1Hj5XblWL6wihMrwH0fL8MY+VDfxnG8j8ENoG3Qk4RbcZFkcGMOvQLusn3dRl1eB/5GAX1RG6F5PAB1ofHYLWhTv3SilqYnOKh86KSdF4k6MTcjNby1LlqfWyn39Up6y3wHdOMDr9jOlh+modOf0k6/YKOsqk45WUbbXmSp6Q/3B/SL4gf69filG+k7D2fgMSy6hYEDmUpX1mdjlRYzYhYvJql5GaLwMrLr4hTdaviZZTvkoyq9QncBv3j95fRu6ypumErlQyJSvlUEstPtOorOutL0lkfSGekJJ2RQDobS9LZGEjn/JJ0zu+x9hTdy9US5XtB3i4pSeeSQDqXlaRzWSCdq0rSuSqQzv5mD04sSefEQDr7G98mqj1bS9LZ2mPtGSlJZySQzrUl6VzbY3QmajydKHu9v41z+5sdre3OeDojdXvq9uzl9qhdTI3000JPBUNBwUsxhh/rp3jVUoPiS8nQ2uhSTLflSauPCnUhb5N/tow64PxLnf2U/7x0VyqHppKH55mhYa4kRHkW7XbF+rLchy7xKLm3fIrOSEk6I4F09rf2TCtJZ1ognVoO6vZMZHvOKknnrEA6E8W3bSXpbAukU/NtPJ1QvtX2oLfbc31JOtcH0qn5Np7Ogcq3uj29055u58rfu0DTzDpXbtsyeLvktxaOlfsAzYlw3ZdP6+S9ERDL+24e5C1G6rZOdWIl68Y6rJ/vxkx1Y2ifoKO2t6jtSSXvJQk+PMv3kkwpRs97L4natsVbprBsS6SF/MiHurcmb70ibiOxKh5G+bJ+s64hcBv0j98fRu/6RF7EnijRV3Q2lKSzIZDORLVnSkk6UwQdH9YGgVWL9zhs1U2TMurtXFg3YfmJFruQu0kLWuzpoSOE4ce6m7TbjZwchS5zM1eWaiAmbxYeEmmGZZG/gQws3NyN+f+aotC4UZij0L6btpIHo9B/vmB8PqwvHrLo5g1+j7xBtZEfy7I3aPl/uGCs3Pfhu90NkdRP3YEQYs6mCh4oHeWfj1G3LhWl0y/oMFYWz3am3/mOin9OeaPObE+FeijbF7Li7rvTotsdC8xL1I3pAbTVTxVZ/lbOuvo2AiP96aJ+M3PW9eIJrutUUdcKN78Hzw721ub3fPdS83oOH3Hh/JjXibQ+esc36JxDfxe5l1qtNbYEpkmIWuv0SZYT7yaJ/DMJa6YoZ3Xv85RHDLU+ZhiqXPL3r4syPg0IkeDk4fnmrIhYswWWaSb+CFcOTZkbqpmG36S6FNVM34+YJQ+33ffjWJjGR0nUj3DNFXQU1oyIWEORsJJnU41VY9VYNdY+jmVpOGbPpjQcP/keb3UDUoPSsH5Dnvph+SEPnYGSdNStVVUf5+UoEo7dzDf1I5ezPXSw/GxqDx5Fb6ffk9nqxoWaJs5ksSwf47f8X4S1oE0Ls9uIfLZ2cZ1L3gA2Xd0Ahj4O3wDW7YdU70i/K19iCqVhXxtGtz64gvpA3QI5KOrD1wR8GPrgBdQH6odJfXqj6LGMDGTk50iY5b8yrZO65xnLtzLoIT+Qz7+ZQe8lQM93K6bRLil3c5Xcob6y3IX63aFyam1TcsoRG3VlDcoBR2ysfNa9/XyljuV/qejzUDnnfrX8OwP7NZI9mZv3tlMVWVPjkE8OsL/41x6xz7MikYiFfR3Sr4MCn/v1VZ5+VRFkrCf3q+V/bWC/Rrq5dG7emyJVv/puilTjN/Yrr3nzPB6xfDcQJ09Iv/pWKyz/XZ5+VVFunx22/G/uATuMvArpV7USENqvbIexX/m+fRzrWJcnyka/S/Q5+/xsF7Lqp/gW+b79mRnVmCPKOyrboHdzMrAMJ3mHYdWsBe6sW8KY5Zb/AcFypaZqIa+CG+KCFwX21g1xfCRLqZlavOJ+6kYnoqgmzzkZ1WiI8o6wGuIdpilRxTK++6pxhP4e7dxDEeKZgrJ8yvO3/OaBZnkXhtdP+X/PMwr5vODkYWs9T+RHz5gvncQ2zKM0LNfKoIOjI1p+Hh0t/x8Ejo5Gu4rREXnEo+N8SOsT+ZnfC0T++ZCHo0oLII1VGnk8j+h0Mx0s/0pO1exbeeOTPO3tNitj+UKZmEtpajanZMHyVREpwfawLPh0KXmYNz7ZQd60XHc5Qb2cS3R8dil5fLKA0YWNFDVBVyNknd93aS6Wt3yKTn9JOupyYsYK3adi+b8jbJSVVavZvv0Rqq94nEkexRuOasZY0VWebshqb1E6qP982eqciHTQlswgOnMj0kFd5F+CnBeRDtqNJtGZH5EO2iDeH7ggIh017pk+LIQ0xLB6LBL1sCnAYnifYywIvhTT8JtUl5z0RqcAi4ket491cYmoS0uk/TJ8xzSks0TQUVgDEbGsb6e7zr7mU0cLBZ2FHjrrA+mMlKQzIugMiXJldUTxxugsjkgHdWaE6CyJSAfloE10Do5I52DIs47otEQdEn9g/qKx98m/QyCNd38lj60A91P+Y+FC70Uppskg2gqsI5ZH/2WRaAfTW5pmMvuHvxWTwx7Jy7ENqxvvhol3iyAthHeWfy7wbgXxDtvFuj0MaYspbRmkLaG05ZCGGJjmoA34jmUOy1u+IVGOx6sV8D5Hf00O0Q3Eb7rONhcZr1YQPWx78vAZhpXF6PUbvVWCnuqHGU7zFOkblumYsrNLKQ1t43JKQ3u2jNJQv4+F74iZ1SbeAYv1Y/nG+s2iNPTpZ1Ma+uFzKA19Z56jY5vZv7U2Tyac5NlEeZdS3oUibz/hfmn5WJnTF43HW55BO/l+NuFZ3nMXjZU5M/3O45EaQ4ZdZ10tbZlIS/DnpQbb+Igyin2YpWP4zjd+Wz5FZ2NJOhsFHcbqd3peeyekY/5rafwqaC+uMf6jvWBbu7ogdqitNfwhQc/q1RRpIT8g1f/FBx7//eue3NSg8lYXfsdxhzUi/0aR33h1KJTPwasrVbzOaOOqq3OdPEsejLlZHdQPSK0pWL8Q/iF+S+Q/A/Ll6YuWoHNnRKxZEbHmFMSyH7ZaBeVNp9W4VPQmupYojz9UxuUaGZ9Gh9/54mNs89GnaqffEzm+ifziOZDWJ8qyjbT8n4Jx7xbyi9X43yBsB/TQ92A/A8svJ6wVXbAuJiwsz2PFyi5YvLs2y59DOcvC2kxYyh/0yTjy907CwvJs+9X8vOQ4NJB3HGqKNhTx+X18SR6OUa0RdWmJNJZXNUatEXQU1vKIWCsiYq2MiGXypnSMb9TOO3/F8iHz1xBZVHRUnTn+z3b0brKjKyBNrTlm+ZrvAzt6D9lR7HNsP7fL8pVcezxIrT2iXeS1R2XnULbuSr+3XKdt4rVE7APDiNnXiqd8c3neuQeWX+Fpz4nUniyZeiSnTBl/WabuAZl6f4BMKd3luHde3V0fSGdrSTpbBZ2qbQTHvVdGpIP6s5XorIpIB3WxTXRWR6SDfgXHLLL0YA/pwRpIU3rwxvR7P+U/GfTgCY8eYB2xPNrRFaIdTO9LFDcoOF+VcW/D6sa7r+SwIcnDcW/LvwR493XiHdJm3VZ+saX5/AbkFfs6luagDfiOZQ7LM9+wnPHX+mstvK8i7m34TVdKPkZ94LVED9uePBw/OawYvdG49+GCnuoHjHsjT5G+YXHcG+0sn2RH23gopaE9y4qTJN857r28S5t4Pqpk33RnNH4MuvNdiuEuBWz2NbHtFntOMP4f6R/ygeO0ah6L73xxWtZXpHNZSTqXCTpVj5/MX7QL7fR7wt+fkM1cBWl9oiz78pb/p8vGyj3pGW+w/dyuKn159B/Yl1fzadQp9uVRp9iXV/GMmPu2JtqXny3ocEyFZap/sa4PyhSWzfLlvwcyddDi7Pb71tLYl897inl9IJ2tJelsFXSq3u9X+/LhdHy+fJYeLCE9UL48ls3y5e8APVjq0YNYvvyKlMZE+PJZvFuVw4YkT5Yvfy3w7tAcNkTFDJW/zr48+nyIgWkO2oDvfLFGyzckyhl/S/q6wb684TddZ5uL+PKHET1se/KwL394MXqjvvwRgp7qB/Tllf+OWOzLo53lMRVt41pKQ3vGfr7Pl1/RpU3sy6v6MVY/vFO+O+vas1L9SnRtJP2u9BzPOHyJ8qkxyPoAeZO33xHPOS3XvCeg4N6HUbn2xYiTh9dp1P4E1fe/Ad8xDemErisviYjVC37YSEk6I4LORPthVflHI0SnKv+oTXTWRKSDYyL7YVlz3C3kSxwKaWp+xL6E5W+CL3E1+RJoK3jcPxTwnMi/LoPeNvLDCo6z0g9jfyKLd9cT71ZCWgjvLP+PhsfK3eDhHet2qK+1mtJwvEYMTHPQBnzHMoflLd+QKMfjVUE/JdgPM/ym62xzkfEqNMZp7TuiGL1RP+xIQU/1A/phyvdCLJ8ftpLS0DYeRmloz9hHQ/1mP2xllzb5/LCVGVihfpjl/1WyGwX9Jmk3OKZV+2vjy1a9P3F5RKzaXxujw+9qfy0OnSL+2kOR/LW7hsfKPTIB/toHe8BfezSSv3YT8O53c8TN1PqH8uXYX0Ne8TiYN26m4isHStxMjVf7S9wMbSP7ZGjPOG7m89dixM1CY1xMM8uvu5zSLf/XIb72VYqbYb0WA+3NS8bnq/218WX3pfia76wh+2vqTONiD531gXRGStIZEXSqPkPP/lpVZ+hHiM7+ts6Z5XP8KGCd0+dzWP6Zw2Pl/snjr4Wsc/r8Ncv/5ASuc2bx7qeR/LUn22Pl/sPDO9ZtHBv5PH69zvn0U69zZvtrag+dso2x1jmXdGkT+2tYvyUZWKF+mOWfmX4peUZa2g3eH6jGqpJ3iwT7a4bfdJ38KyL/S4ket4/9tZWiLjzHS54zIB+n+fxCNV9cHhGr9tfG6PC7PP7a0oh0UGdGiM7yiHRQjtpEp6p9dqH+2tFLxt6jLQ71OSz/3e2xcutSzDxnhEP3pVn+k8juFjy3K+0unxdWd2Ml7TyFeKf2paFNy9qX9vL2WLnTiHfqTjnF16WUhmPqckpDXvF+n7xzUrXn0DcXKXlHRLC/ZvjqTo8i45U6G+w7Y1Jw/jDqrym/WfUD+mvIU6RvWD5/bQmloW3kc+Jozzh2gvod4q9hm0L8tbwxrgp8puDfKN9bPlNy16n1Q3pV/Dlbd2669crt2646f+vtt5x+w9Wbtty8c9uW7adfffXNW2+5BSuNhPDeekzHh/PY91niPWIs79IYFgbsLHbMVnTBKnsBhjLivsGN/57sOutpF5VMCsBBRcuq12aql1p88Rl5FM47CUtdpuEzjIh1F2Gpi3z478mus57MLx9OlgHFer2R6qUMpmEd1gXrtYSVddgv+Xd4F6w3EZaahPPfk11nPZlfPpzk3xFd6vVmqlfW5pvk35FdsF5JWGrzjmEd1QXrFYSF5bEs/j3ZddaT+eXDSf4d3aVed1C9joK0oykNy/HPhue90BfL86BZVbB7GtE5OiKdoyFPG8olfx8DaWhbh8Q7o2GD/3HwvoqAieE3qS456Y0O/scRPW4fB0yOF3VpiTQcVzEN6Rwv6Cis5RGxjqH2ZB0OeitNwvDyShXU4EmY5d/SHit3N03CkEdHUxuVH7NU0GtQuwZEfsTrp/z3pnU6yHX+FNbRorzCxvE05AJc1K8qdMTwY12AewzR4/axjhwn6tISaRy0ULp4nKCjsFZFxOJLoLN05L2RdOS89li5D/Sgjnwkgo6gDxWiI2Uuk0A8qw++Q/xYOqJ8WZ+OHCPq0hJpvLFe6eIxgo7CWhsRK1RH9kTSkXXtsXJPVKgjxu9QHbH8X4qgI+g3h+hImWAY4ll98B3ix9IRddGOT0fWirq0RBrOmTAN6fgWxxHriIhYoTry7Ug6sqQ9Vu7PelBHvpNTR1Tdq5h7qfjVWfA9i0dKdlui/HJKWyLodJORHy7R9cm66MDm7/2Uf0p7rNyPPDLCG1WwzrywmncuvT6QzraSdLYJOlXP2XlhdXlEOiif24jOoRHp4LjSJjprI9JBWxl64Ufj4LH3yb/DIE3pgcWL+in/+5eOletPMZUeZMUscWF1qWgH02umNEpuPJILq4bVjXdTiXdFx5k3Au+me3jHuo0+Pdt45MehlIZjMsd9VXwV37HMYXnLNyTKGX+tvzBuWcXCquE3XWebi/haoQc/rX1HF6M3urCq5hKqH3BhFXmK9A2LF1bRzvJmJbSNR1Aa2rPDKQ31mxdWl3ZpE6+lqfr5NtgMirpX4ccbftN16mgR2ermL7Iff6ioi+qbt8B3TEM6vos5EWtJRCxbY9ibvtBISTojgs7+4guNEJ0DxRc6PYcvlDw8nlv+o2A8P3MCfKENPeALnR/JF5oFvLuw9oV8zz7jCx1VjN6oL6TWsPP4QmpNe3/whfpE/TAf6p6KJznxruGhxzQmibJvpXpj2vVEI28M6HpR3wrjun2h+rWvxHV5Db1MLDbE59mfDn1cD+8ibaLt8/XDcg+9gmt5k4yeb28X0kvs6YDr7MOsPWhq7xb2V5bOF91PeWgXLN9+Sl4HXNsFi/dTZm1cxrS3p/5LYodff/D4PLYX8E7I86vpd7WhH/2pt1I+dflJyQs9gnWPfySh4IZ5748kqAOHiWwe5Pwygn2Utc9UXZoVIrNYpxCZzdunalN5ku8dnnwrRT5FK/kb9z0bBvvi70wxEj7fdNv4NmJ53puc9wcYsbzvB4jXl6SzPpDOSEk6I4LOkCjXyPg0OvyO6SjeVH3QbYToVHXQrU10qop1cGwg6xDVh2l+qw69+w5RWf6PHjJW7qM0v0U94LEOL9ZzIv+6DHqfpNhAlRfrZfHu94l3RQ+gvQN49xkP71i3fQdckR98OA3HBt5bl/cAmroM4kA5gKYOH+9LB9DUWKdsIx9AQ3vGB9BQvzk2sLhLm3w/umtlk8NVqbrA4arzt95+2Zbt267esnPbjTdcvPWlt269ZWc/IKuRgy08W2K8GirradDfkyhtFqVvEvnw8Y2mJa84CPZ8Db/pOnuhiOaoE13Ky+CrerCsuqribfAd05DOKkFHYc2OiGVyU1/l2fkuz1WeKyLSwVF0hOhUdQVAm+hUdQVVqKf3E/JW8NhuiLdi+U8Eb+VJ8lZw1OCd9njFixP52dOz/P9Bnl7BqJv09Hj1HW1dO/2etPNnAbxDm5bFu0XAu/8m3iFt1m3kE9sX7O+VlIa8QgxMc86/Oq88ggnYtRDs6U3ErgV1LUvJqy9GPT3lWap+QE8PeapO4vqu8pxFaeoaC2XP+IoC1G/29GZ3aZPP0+Px5mBBx9KGIW0OpS0TbU70bt4h4/O1IN/BhLEI0oYp7RBIWwb4f7l6fNvUVaRKd1mvUY5Zr7H/s06XK9uEuP2Ufxhs03GHjMf0nTJPnklUBxXBxtkJz2TVlbE+rMUe2mrmdKiHtrryjuviXLauDQEtSzPeDKafOOblsYHq5zNxxjQZcLP6Sc0afbxS/aRWynhFTl0J4rumRtkYtj/qGh0ln2pmieOx2Rs1zuNY/rOM3R5ZuMxPNXb4dncsFu1T+s92A/Wf7YaK7ihZZ7uhrlpXV8bzatCz0r4ouTLjvWqd5bvfafnOus70OWDbzsqwbZNzYp6b4iQ6egHoqHPjbYH1Y0lb0K9sAeo72wKfDU6evHaT9Rb7hn3L0EgP69mAyI94vJKzGfqATwqhPeKf4lYRad+1gb55V8L328inUBH/JN8VJHto05SfxLJn+W8HeX5B+j2m3eArZtEOcARfjTlKzlSEEMdQLmd2oGRENXgewbtdyq74hu52ibGinfwLvdIW5xHddjyYrZpou4Z8CrFrmN9si9rJxvqMNoLtANoIth8rPfTUKjzaCJ+NVDtGVFwHfZafUBwB9Yv1X109qHSc/QZ1/TSPG1m78nDMxvyvBhv2NuKNkmWfH6t2/uCuHV4B850KVljLPbTVbtrDPbTVblqui3PZOql00XhTxXwD/QLWRdVPaqedj1eqn1qUH3mTV3f5umsc31mv1VXYSj59fn7ysO6qnTPoD0zUam/W2K1iwIjLvu9vg+5+mHij7LNaKWX7gfnVCR3ffN2HtcJD2ye/irb6+UmuixP1xJ8gMFqWZrypQndjzg8Ur1Q/qVMDrIOhK8+sn6Erzzjusnx2u63SN+7iDg/e/aHWDH2yp3ZaoB6z7KmdFkr/fbE1309OsN1Qp/FYz1BWMT/HCiz/YxQrKLjjV8YK+JQLxjOUfGf9VN03wbY9nmHbJufE/HxgrMD6sQqfGvWdbYHPBidPXrvJeot9wzuO1P4AtQuV9WzA6Zgl7ijD/H/siRWgPeK4ZuhOGN6rgDqDsYJ/pliB+jmhJN+3SPZUXB9tDsue5f9XkOc/JX8jht3guKWKGfnGHN/pWrUu4Du9WXIuHRwr4N3hBWMT3t3har4T49az5J+a46h+wFhBtxMRvlhBlXbNtx7Sja88d1c/falsBNsBtBFsP5Z66KlYGNoIn40M9VlwR++HKVaA+uVbF2P9R3n3za3Zb1Anj9Wci08C/xxsWGvpeEwlyz4/ttt8nWOfar7uw/LFKY4U+Y/w0MZ6YVmmnaWTSheNN1XMN9AvYF30xWiSJ4RXqp9alB95k1d3+YZFdTpM6S7GwFg+fX5+8rDuZsUPv+WJ81dxapzn1kdCXXgdnscBzL8QTr4fTrw5yo09ITKhTkzjKWi2U1k3x2RhLfXQVjfXHO2hjfXCskyb62nllO4ab6rQXdQ31l3VT5g/hFeqn9SNoUdTWugJ9iMpLfQE+xHQZpZPtf6PcXvWXbVHTt0ioWyhT/a6jVkse2rMUvrPdgP1n+0GyijbDexbtht8MwHn51iB5T8lZUjJ27BlrOAYquNRUAcl3zy3svybwLadlmHbJufEHElxusUKrB+r8KlR39kW+Gxw8uS1m6y36sbjBv2NWMhTjhUYjwZEfsTrp/znQx9wrADt0VFUd7RHvhs12M9Qt/okfL8hrceQ69TdNuS7mGQPbRrbi+Rh2bP8LwV5vjT9HtNurKU0tAPsW6sxR8mZWivCMZTLmR0oeaNdcKzA8Juus81FYgWht8bE+BWB5J+6IV/1A8YK1C19iOWLFVRp15BPIXZN3VzTcp1tZH1GG8F2AG0E249DPfTQRqAvfgPpvrKRoT4Lzs9Pp1gB6hfrP+o46z/KO/sNyMOsW+eVDeMxG/O/HGzYG4g3SpZ9fqz6BRX8BYjDqT0o68cHYB3hoX2CyH+8hzbWC8sy7SydVLpovKlivoF+Aeui6if1iwM+Xql+alF+5E1e3eVfLFE3QSrdPRra/IaMcRvbgeM26+7hoq7oD+xrsYK7QXcfId4o++yLFeSdr6MNOyYAyzdf88mvoo31wrJMm+tp5XopVqD6yWdjFa9UP7Vcp16zDk5krOCRimIFU/fzWEHImI+yivk5VmD5P06xgoK/LidjBcdRHTGeETKvt/xfA9v2qQzbFhorsPx/0AOxAtR3tgU+G5w8ee0m6y32zd6KFXwxMFbAcc3YsYK/C4wV/FGkWME/gDz/7wmIFaAd4FiBGnOUnKlYAY6hXM7sQMm5dHCsgH+Rr2BswvuLfL5YQZlf5Uz+qTmO6geMFai5CGL1YqygG1957u77FbfQ+QbbjyKxgr+rKFbQiBQrQHlnv8H3C3XHQV2Uz4NjNuZ/EmzYQe3xmEqWfX5sjPm6D8sXKzhJ5D/BQxvrhWWZdpZOTnSsAP0C1kVfjCZ5Qnil+qlF+ZE3eXWXfwEYx3fWa5RtjIGxfMaKFbA/sFzgKpvQoPpift/8pNveUd9eo8MoTe3VZzpoE7BP7ki/816jWe2nP7v51Ea7pLxPr3ofTbf5oPFE+Ua85wV5jOeReGxYDnX/YY5fGPTd9cBlsQ8GMvLzfjLLP9x++hN9dp88o06UlWdsQ1l5Rt3gX/Kz/GvaY22dAHmetrflmWUW5ZljQkqeG67ThpWJ53y7B+X/pPbTnweC/D+zPdbWXpR/NZfwyX+3GAnLv/rF8omU/z055P8YD00l/9a2LPnHeCLmv6j99KeSf8Vfn/x3WyP0yf/xlIbllmTQQfnHfmf5t/yXtcfa6pN/o12F/COPWP5986bkyTvX4TUB9N998s/rtbHk/70lf2HZJ//W1iz5NzyOl7+k/fSnkn+lgyvgXdm1LmzDcZSG5ZZk0Mny51n+Lf+O9lhbffJvtKuQ/5jz125xBvbnUTd88s/rHLHk/60k/3jGvew5dt/dFdYOdWYT2224fGbzVW1oQ3s8pvKR1P3Alj/GOXMflk8/ff61oq3uxuC6OFFPK1fh+a/JVZ9rVbxS/dSi/Mgbda6Ez7iHnivx3ZWH58VYPmOdcT+Ffk1+dRdc5qfvPkKkpfR/DaXFPMeuZJ3thvrVSrX2xvONXe2nP6v81UqWb1yLRvnmtTvL//H2059JHz/Q1piTc2I+nOJ0G2cj3VXTX/VdNd3sJuutOpvWoL8RS63fsJ4NOD3X5XtZLP9H2k9/qrVotEd8H4e6r0nZIz5zhzqDa9HfbD/9nc/oJt/bkO+T7fHtLnoX47fbY+U+nX6PaTf4Pix114FvzPH9+qC6z0bJs9mBkmfAg9eiDb/pOttcZC069H66knZzdC1axQlVP+BatDpDi1i+tegq7ZrvHp9ufOW1YWwj63Po3TtsP5Z76KGNQF/cbITPRq4QuEOUhmUT3KNpvhHzHLvaM8d+w+FQF+Xz8K8qWv6/bI+V+0l7PKaSZZ8fe6TIj3Fwvj9InTP3YfnO1x8l8h/poa3O7XBdnMvWSaWLxpsq5hvoF7AudluTDeGV6qcW5Ufe5NVdXt/G8d13Vx7G31k+fX5+8rDuqnvU0R+YLuj7xm7f/JnvVEC95vtp1BoD2pms+yl+1h4rN314PKbyI8vcT8Fzprz3U6z00O5mN5i2shtcF+eyx1alu/vL/RQ850cbyHtF1K+d+tZoLE3dnaLuTsI5HcunulsmdNzFu2V+ung8bux7IH331fJeUXXnr2+NUemS7y4WthvsH3J+jhVY/iVpX5j/iTJSNlbA4zieuVHyzXMry39sWsekj5dm2LbJOTGXpTjdYgWRxvH+qsfxbnaT9Rb7huePaixFnnKswHg04HScgu9ftvxHQB/4YgXsL6A9Yn9Bxe+UPcJYwaa0HhzPTb63Id9xJHtF41SbQZ5PTL/HtBs+35r3raoxR8mZ2huIYyiXMztgdgVlsYpYgeE3XWebi8QKQufuJe3maKxA+eGqHzBWgDxF+nguOXkm2q75YqDd+Mpzd2wj67Mvnog2gu3HKg89tBHoi28i3Vc2MtRnwfnGj9JGKB33nZNj/VexXzW/Zb9BnZNVZxH5nOwVYMN2EG+ULJe5U4v34avzpz4sX4y92xld3z1D9Z1aup/UmRPeYx6quxxjwPGd9RplG/eX78gYt7Edai1E+QM45h9HYzfGCvh3L/LGA5TOs5+mfF/1uwPs+74MdPc3iDex43wh83Uflm++1i3Ox7TrON/4/KqfQuJ8+LsXHCsI1U/WeZRtHHdZPmPFCh6lWIGyCT7Z67afhmUv9AwJ24288QAl62w3rD9RVjE/xwos/z1pX5j/WfAeKRkrOIrqiPEMJd9ZZ4I/BLbtvgzblvec8btTnAnav537LKjPBidPXrvJeqvG+Ab9jVjqDBjr2YDTMcus8wLvhT7w/c4exzXRHnEMRN3truwRxgq+ltaD5zrJ9zbk+zDJnorro81h2bP8fwzy/NH0e0y7wXucVMzIN+YoOVPrvDiGcjmzAyXn0sGxAsNvus42F4kVKP1T852SdnM0VhB6/x7GCtRcBLF8sYIq7ZpvPaQbX3nujm1kfUYb4VvDYPvhu6sfbQT64l8j3Vc2MtRnwf0KD1GsAPWL9T9vPEDNrdlvOArqonweHLMx/7fAhv2QeKNk2efHdpuv++73DLlTq8y5J999Id3u1FI6qXTReFPFfAP9gpA7tTB/3ju12P/33akVqrtHUZqKByjdxRjYDzPGbWyHilcqfwDH/A/T2L2vxAr+BXR3YNl4zDpW0FnPOlYwPm0iYwUsn7FiBdfXsYLcsYI5aV/0cqxgbVrHpI/nZ9i2vLGCRSlOHSvYe7GCldAHezNWcG5aj26xgsNJ9orGCs4HeT4q/V7HCuRTxwqIXh0r2DuxgnNJ92PFCrbso7GCi8GGbSXe1LGCbJ2sYwX5dDdGrGBrxriN7SgSKzicxm7UcdZdde9A0ThCQ9TF2uG708ny3wi6+1riTewzCCF3iPuwfPcVdItTMO36DML4/KqfQs4goO5yjEGdAypzBoHlU91XEHrXCN5XsCrgDIJP9rqdQfCdQfKdQWC7oe4dKBpHYD3LewbhzRQrKOjTV3oG4WGwbW/LsG15zyC8IzBWUJ9B6ORprDMIuwNjBRznQHsU4wzC5ylWkHUG4RGSvaJnEL4I8vx+8jdi2I36DEJ9BuEp8PRzfz2DgDbCd3Y5xhmEz5PuKxsZ6rPgGYQlnjMIvlgh6/9En0H4I7Bhf028UbJcn0F4+qnPIOTT3RhnEP46Y9zGdhQ5g/BIwXlMg+qL+X33CHa7T43nJ8hH331qszPoZO1XeGP6ne9h+lGgTx3prpzBvHflqPmgLw4SeiZd+Ua83o48Nprd5rP9NJ9V8rLYU/+q7t9bCfU3bOei9u1Bvdy3vnvQeC4V616jnyx6+vt0wLZ81xLNhqCJ79in5/IKC/txHXw/FtIx/5LlT3+ar4r8zyEHG4egjAMMxC4oYxuxrfaouQX60Ype8jRFWn9AXZ44ac/59/9s3bQGlbe68DuW48ki/7Uiv/FqgOredkHP+UrXjbalcdsxDfXV6pDo+Fqq3+SC9QvhH+K3RP5NkC9PX8x042UB5V2tIyyntIlaR5gDebLWEZYvHyt3wvLxmLHXEeZQeyZyHYFp1+sI4/OrfgpZR1gOaVWvI7B8Kv97DrzjsXaOqGuC+5VF43FjryOw7IWuI7Dd6KV1hDNpvO/FdYQrwLadk2Hb8q4jnJfi1OsIe28d4VLoA15HQHtU9TrCy1Ni3dYRnk+yV3Qd4ZUgzy9Kv8e0G/U6Qr2O8BR4+rm/riOgjah6HeHlpPvKRob6LBin20Pxgbz3F++tdYTXgg27m3hTryNk62S9jpBPd2OsI9ydMW5jO4qsIzy/4DymQfXF/CvhXd64MM9PQuPCyzPo5F1H2BXoUx8I6wgca0Ye8zpC1nz2EZrPqrN5vnUEFcNG3WJ5UTFstSa1HOpv2I7yVbGOgO3hvo29JsexE5wjcb9j3/JvyMSKbdy9qDuuTxZ85zqxDdNFPdjXwHKzoP6GzfUvKQsDShawPSwLPrlPHuaNT3aQN2qcYTmZBWkric4cQWc5vGNZWC7oJG29iXzGYci3mGgOC5r4jud3WN7yKTobS9LZKOgwFsaJZgEWz6st/w8olrUMcHPI2zXMf8NA7BUFsRuE55yezxq+Wl+0ejVFWsjaVf8XH3j89697cpPPlvjipMqWbBT5jVeoSzl4daVvfFFrVysoDe2C1UGtXa0sWL8Q/iF+S+Q/A/Ll6QuFdUkkLLZjZbHmFMSy9Tm0g8sIS9lUtXdnumgX12u4C9bFhIXl2YYt64J1CWENizb2uc42Y76ss0ZIe8h1to1tWUE72R9qywy/KdpQJDaneKvGGjWOWlnlu7HMLxd0lgs6CmtORKzZ1J7ZUK6R8Wl0+B2vb2M9z6c6K92a46kzlme/aLagY+05GNLa6fenZHuFrg/K/cFQH/YLLH/f0WPlBlaMbz/S5n27WOf1bnxdsA/6xDvmzfpAOpeUpHOJoBNTblR/ric6yyLSQdt0CdFZHpEO6lub6KyISAfHxXVEZ46oQyKzi0kP8J4dpZeb089+yv/gUWPlDvHoAdYRy6OvdbBoB9NbngKV9APl2rJhdePdSuLdwZCmeMc2xPL/GvBuTQ4bgr7lMkpTc0zfvs0GpTnXGbtIHpY5LG/5hkQ546/1F8Y8qlizM/ym62xzEb9AxXTUvN/ad2gxeqNrdio+qPoB1+yQpyqubDqm7OzBlIa2kX9zUMWklA06Fr4jjaw2sT+t6jcksFi2JtrnPLgYPa/Pie0r6nOeDd8xDenk9RNjYPGZhL3hC42UpDMi6OwvvtAI0TlQfKHn5fSFeDy3/GtgPH/hBPhCV/WAL7Q1ki80FXh3LfEOabNuI5/YF1LrS8pPQgxMc86/7tMS5ZlvWI7Hq4K+SbAvZPhNV0o+Rscr5SOq8aqkrzfqC6m1VdUP6Aup3xNGLJ8vxPEFtI2+tdesWGzynX2hOV3a5POF5kAbkr/tt5yfTDc0JLrzKynxIUHvMjc+DeV2oRvDeA3pX1asENOwPfiOdQXLL6P6xBjXrM7YPxyDyuvDYHlet1sm6Fh78Le22+n3hL+/uULXB23mUqgP20zL/zfQ72+iPlN8Vv3Jflfe/lwfSOeSknQuEXSq9ofY76rKH+IYVFX+UJvorIxIB8da9ruy9OBB0gM846j0gGNQlv91oAfv8egBxzxWAZ4T+ddl0PsA+V0Fx3Hpd3EsJYt3HyLeDUNaiA2x/C8B3n0khw0JjTOtoDQck3lfi4q1qL1Uvn35as+W8bdkjCbY7zL8putscxG/K9QPsvatLUZv1O9S9yeqfkC/S8WdEIv9LuVT+Pa1KXvG8SnUb/a7lnVpE/tdSvZ9482gqHsVMSjDb7pOPhaRLeULqXHYt2dE9Q3HoMqs9Q9HxOIYFK5xsy+0WNBZ7KGzPpDOSEk6I4LOkCjXyPg0OvzOt2+LfaHhiHSwf0eIzv4Wg8oaz78XEIPyjeeW/yAYz7/vmceFxKCWiXYwvR9NYAwqi3f/SLxbBmkhvLP8f3fEWLmfeHjnu1tnmNLq9binn3o9Lns9Tu2zUrYx1nqcYWa1iX0htX+XsfrhnYo58bxjStppia4Npt+VnhvtJN+bKV/th40vq/r+N+A7piGdUN9pSUSs2g8bo8Pv8vhhVflHI0Rnf4tJDYs6JDbm0JVj79Guoi8xDDTZl7D8bwBf4vAUU/kSITEpnx9m+Y9JgSYiJpXFu3XEO+WH+Xhn+W8A3p3g4R3rdh2TGqsnvkP8OiaVHZPy+WG9EJNS9WOsUD/M8l9IdqOg3yTthmHV/lqYv5Y8Z0A+TsvrYx0cEav218bo8LvaX4tDp4i/tiOSv9YCn+OmCfDXbu0Bf+1lkfy1fz58rNwriHdIm3Ub+cT+GvpR7K8hr3gczBs3w/IHWtxMjVf7atxsmNLQNrJPhvbMd39zFXGz0BgX08zy6y6ndMt/N8TX3kZxM6zXUqC9eNX4fLW/Nr7svhRfs36dLrDZX1si6Czx0Fkv6qzojJSkMyLoDIlyjYxPo8PvmI7iDetpDDqo8yNEZ39b5xwWdUhszMfIvql1zmGgmbXO+TbwOT7h8ddirXP+AflrVa5zZvHusUj+2m3Au8c9vGPdxrGR7Uu9zvn0U69zZvtraGc5voa2MdY659IubWJ/Deu3NAMr1A+z/H9KdqOgHyPtBu9Lw/qw/C8tRjfYXzP8JtWlqPyrvlP3RLCvimV5jpc8Z0A+TvP5hWq+eHBELJ8fVftr4+n4/LWDI9LB/h0hOlX5hW2isywiHeXndPM5/p18juWQFuJzWP754HP8zBMj4njOcsBzIv+6DHo2UJS8W03aXcPqdjZy0qrxbRmGNGXTsvbo/+dhY+Ump5jqbCTrNvLpYErDMZV9uZh7b7E8803NRUrenxbsrxm+uu+uyHi1kuixXrC/VnD+MOqvKb9Z9QP6a8hTpG9YPn+Nz0aq88zKnnHsBPWb/bUlXdrE/pqSfRXjwjueOMalxqVB0cYcfTQ9VAYNv+k6+V1EBtU9G2q8nurGZOHWndu2b9t5+zlbd2669crt2646f+vtt5x+w9Wbtty8c9uW7adfffXNW2+5BSuNhKbBe0zHh/PY91niPWIs7dIYFgbsLHbeh7tg8SV8WJ4N4LIuWCGX8PHfk11nPe0HyCYF4KCiZdVrM9VLLb74jDwK552EheWzAi5ZWHcRFpbnxUUMFnE9mV8+nCwDivV6I9VLGUzDWtMF67WElXVIPfl3aBesNxGWmoTz35NdZz2ZXz6c5N/aLvV6M9Ura/NN8u+wLlivJCy1ecewDu+C9QrCUj/Yxn9Pdp31ZH75cJJ/R3Sp1x1UL/yxjSMoDctNIzp5J2lYfqImadOIzhER6eAPkbShXPL3kZA2DBi+Q0w2+B8F76sImBh+rAtMjyJ63D4OmBwt6tISaRzkUD+GcrSgo7CWRsQ6ktqTNQm7giZhRS+o+S5Mwl5AkzDkEf9YpfJj1AWjDWrXgMiPeP2U/8q0Tge5zh8+O0KUV9g4nvoCHTF+oArxrD74DvGbrlN+iujIkUSP28c6cpSoS0ukcdBC6eJRgo7CWh4Riy/Py9KRl0bSka+BjuzsQR25PYKOoA8VoiNlLkFCPKsPvkP8WDqifFmfjhwp6tISabyxXumi+qEohbU6IlaojtwZSUd+D3TkDRXqiPE7VEcs/5sj6Aj6zSE6UiYYhnhWH3yH+LF0RF0Q59OR1aIuLZGGcyZMQzq+xXH148gxsEJ15Hci6ci7QUfu70EdeU9OHVF1r2LupeJXZ8H3LB4p2W2J8rywukTQ6SYjH1ml66NkJPlu83deWP9NkJGPeWSkFxZWt5Wks03Q2V82wm0jOqsi0sFxpU10Vkeko34EupsefJn0QP1AIpa1eFE/5T8C9OBrHj3Iilniwqrv0lnL/79pYbXgxiO5sGpY3Xj3jUjjzAzg3bdy2BD06dnGIz/4Bw9xTOa4r4qvqh+ZbYnylm9IlDP+Wn9h3LKKhVXDb7rONhfxtUIPflr7Cv4o+OjCqppLqH7AhVXkqfoBbd/CKl/Aj7bR90P0/MO4qN8hF/CrH8ie7qlfyAX8E73JrOwF/N38RfbjV4m6qL55C3zHNKTju1AasZZExLI1hnqTWee7XjwUcKD4Qs3VY+/RvoeO55b/I2vHyg2lmFX6QjNToL3pC80m3hX1hd4OvJvn4V3tC+07vtDhxeiN+kJqDTuPL6TWtPcHX6hP1A/zoe6peJIT7xoeekxjkij7Vqo3pl1PNPLGgK4X9a0wrtsXql/7SlyX19DLxGJDfJ6SGxiD/fGJ2MB4PbyLtIm2z9cPSz30Cq7lTTJ6vr1dSC+xpwOusw+z9qCpvVvYX1k6X3Q/5aouWL79lLwOuLoLFu+nzNq4jGnPTxMSO3zB6vF5bC/gJshzYfqddQr58NReEsrH+wqTp+SFHsG6xz/uU3DDvPfHfdSBw0Q2D3J+GcE+wr0Ry+G7ujQrRGaxTiEym7dP1abyJN8LPfmWiXyKVvK3+rFw9sW3pBgJn2+6bXwbsfwwfMe05OkT73yHMyyforO+JJ31gXRGStIZEXSGRLlGxqfR4XdMR/HGdwizKB2UsRGiU9VBtzbRqSrWwbGBJaIOic68nOa36tC7Gi/40PvxML99Jc1vh4E2j3XLAM+J/Osy6L2aYgNo+8rGBgyrG+9eS7wbhrQQ3ln+BcC7Ozy8Y91G2z+H0pAffDgNxwbEwDQHbfAdQFOXQRwoB9DU4eN96QCaGuuUbeQDaGjPllMa6nfIj/P5DqCpsTw5XHVI+n3scNX5W2+/bMv2bVdv2bntxhsu3vrSW7fesrMfkJk6tsI5bYmNI4jDT4P+nkRpsyh9k8iHj2803Vs/wzyrGD3vzzArL4Ov6sGy6qqKt8F3TEM6ywUdhbU4IpbJTX2VZ+c7ptMLP4GzLCId1M020VkekQ7KW6in9ynyVvDYboi3Yvk/dehYuT8gbwVHDawjYqOnN0e0o5/yP06eXsGom/T0ePUdbV07/Z6084kA3qFNy+Ldu4B3f0i8Q9qs28inYUpT1/6oGTtiYJpz/tV55RFMwK6FYE9vInYtqKtxSl59MerpKc9S9QN6eshTdRLXd5XnLEobhjReIUJ7toTSUL9DPD1sU4inZ7LVEnQsbRGkzaa0Q0SbE737S9I7/Anoq6gdlobtwHesI1eJ+ig6c9Pv/dTGfyNbV/Cap9OGiI5hIPbigtihepnlN2C9miKtP6Au/zZ75Ih/3vWT+xpU3urC7yYBPsoy5r9K5C855pwyBDQc0bY0HA8XU9pkSLM6JFHLtVS/gitDp4TwT+k+pp0N3/P0hcKaXRBrphsvV6g7pn9oR+al34dcp06znhTUweD5luE3XScPioxfyvYqm8U2Asu2RBpfxTtX0Jkr6CisVkQsGwNUP/N8qyXotDx01os6KzojJemMCDpDolwj49Po8Dum04I8eyuyPjciHZSDNtGZF5HOPMjD862sOcP8NWPv0W6Fzhks/2kwZ1iUYiqfAuuI5XF8mS3awfSWpjRKji1yvsW7K7J4N0y8mw1pIbyz/G3g3QoP70wvVCyFxxHkx1xKQz+BY0p551tY/kCbb6kx3to3XIze6HxLxSPzzLeQPq9eWd+hnZ1NaWoerewZ+1yo3zzfmt2lTTzfUvWrfaEwXyh5zoB8nJbXf1kYEYvtmBrvG5SGdFoeOrUvVIxO7Qs5d3kkX+jxNWPlrpgAX+hFPeALbYnkCz0IvLuaeIe0WbeRT+wLqZiO8pN4Xp/3VBKWn4AdusG+0ETs0FXjVYwTgcm/YUEva8es4qnyi3y+EMee1W5AZc8WU5rPF5rVpU0+X4jX3TFuzHlnQnsx7ytBz3avyaY1n+qBNmIBpYXqJ2Igf9FWYP6d1AbL/9q03kms8ZbbNOYkp2XU7I+KfVo7BoGupeWQ38eTej3vtjE6KC/Jg3FTlBfn/D6V5Z8v8qPMsW84H9LYn1PyiP6FyaPil9WxCn5hHUL4pdbAQvnFeo/8WkRYyv9FHvr4ZXWsgl9YhxB+qT0uofwyHih+HUJY3eY4Gyi/YQ84bRN417TlfzfYBL6Vx2fjZwpstI0NwsB2NEQ7higNyya4702N50TFedjXVDfuoP3GfRCY//0wbjxGvBl2Y0/I+paKcQxDHt5JiuP4sgCs2R7ay0X+ZR7aWC/eI8N7c5S/oeyA8aakHZis7ADGq9gOqH5SJ558vFL91KL8yJu8MSe+WSE05oQnLR7LmJNgO7JsNusDzmd4rqPmCT7Z813Rr2RPxViV/rPdUPtqlC6x3cC+ZbtRdCf812iOijJSdo7Ke7iGoQ5KvrN2uP8N2LY/zrBtk3Ni/gmMRxeAjjqn19tL2oJ+ZQuGIQPbAp8NTp68dpP1FvuG1xrUujnylH0C49GAyI94vDfvLwJ9gmGqe2gM3DfvM314iu/pOk+3PZDfI9lTtzn49kCOnlCHdaXv0xwvht2YR2loB/i0M8qUT85aorzl8+25LbnvPDiWwvvOh4vR8+47V+s8Je3maCxFnZxR/YCxlG6nN81WTbRdQz6F2DW11tRynW1kfUYbwXZA7XlVazFMD20E+uJmI3w2MtRnwfj15aT/qF+s/6jjrP8o7+w3IA/Zb1gOdVE+j+HyT7hNARt2MPFGybLPj1V7WHFfKt9qg7K+MgDrYA9tdVp+pYe2+nl6rotz2TqpdNF4U8V8A/0C1kXVT5g/hFeqn1qUH3mTV3eXUxqO78OUhrKNJ1FZPn1+fvKw7madTv/eBO8JiRUrWA26ewrxxnjqXB0rcFSujhV06m7VsQKWz1ixguE6VpA7VnBu2he9HCt4Idi28zNsW95YwYUpTh0r2HuxgudCH+zNWMEvBcYKXpzhc+SNFbwK5Pmq9HsdK5BPHSsgenWsYO/ECn6poljB/H00VvCrYMPeWccKOmhn6WQdK8inuzFiBe+sKFbwYhq7sd58Xl/plNJ5Pq+vftqd+y8rVmC4/ZT/AdDdjxNvlP6o/X+h+sNzJqU/PizfHiN1I9IqD22sF9/AzrqsztBXOI5K3UX9ZN312czkCeGV6qcW5UfeqHNIvO9tGNL4ligch1jnUbZx3GX5VHubQsdd3Gv0RMYt7lm4zE/fL1mocUPFUHxnxJT+s91Qt7YpWWe7Yf2Jsor5OVZg+T9PsYKCN67KWAH/QgDeW6Hkm+dWlv/PwLZ9McO2Tc6J+ZXAWIH1YxU+Neo72wKfDU6evHaT9Rb7hu+MCb3BjfVswGkfIuuG1v/jiRWgPWI/YxjSOAayTNBV9ghjBf9OsQJ1k2eS789J9lRcX/1SIsf1fwby/B3yN2LYjeWUhnaAb+ZUY46Ss5Yoj2MolzM7UPKmxOBYAd9iX/Dmydy32Me4qTr5t0bQU/2AsYJuN5n7YgVV2jXfekg3vvLcHdvI+ow2gu3AMKSx/Vjmoafmd2gjfDYydL6BPsun6J4iFWNVOs76j/LOfgPykP2G1VAX5fPgmI35J8FttnPXjsdUsuzzYw8V+fE2fl6H8f3ar8LyxSnUr+Qc6qGtfiWH6+Jctk4qXTTeVDHfQL+AdVH1k/oFDR+vVD+1KD/yJq/urqY0HN9Zr1G2V0GbWT67/WId6646C4f+wETd4pw1dmfF+QyXfd+loLvHEm+UfUZ7mdfv5DmTmq/7sIY9tH3yq2hjvbAs0+Z6Wjmlu8abKnQ35vxA8Ur1U8t16jXrYOiN0qyfoTdK47jL8jks2hE67g4DLt/qrtZafbLni7Mq2Vsm2qf03xdbY7uBMsp2Q/3KJusZyirm51iB5R9J+6LkL/nIWAH/eh3GM5R889zK8l8Gtu2MDNs2OSfm2SlOt1iB9WMVPjXqO9sCnw1Onrx2k/UW+yZkLxjylGMFxqMBp2OWuOcF8z8b+oBjBWiPOK4ZesM9751Sv7KR8H1nWg9ei0m+tyHfc0j2VFwfbQ7LnuV/Gcjz89LvMe0Gxy1VzMg35vh+NVetCyh5NjtQci4dHCvgX30qGJvw/uqTmu+UtJujsQI1x1H9gLGCbr905osVVGnXfOsh3fjKc3dsI+sz2gi2A2gj2H749jGoWBjaCJ+NDPVZcM3z5RQrQP3yrYux/qO8++bW7DesgboonwfHbMz/K2DD3kK8UbLs82O7zdc59qnm6z4sX5xC/XLsWg9trBeWZdpZOql00XhTxXwD/QLWRV+MJnlCeKX6qUX5kTd5dXcNpalffVS6izGwt2SM29gOHLdZd7Pih8+hsbvqX4PmufVhUBdeh+dxAPPfB7r7IeLN4W7sCZEJ9UvI+OvGbKdQJo4IwPLtCTpS5D/CQxvrhWWZNtfTyindNd5Uobuob6y7qp8wfwivVD+1KD/yxtJCf5n6MEoL/WXqtdBmlk+1/p91Jw/rA+4J4l+HV7bQJ3vdxiyWPTVmKf1nu4H6z3YDZZTtBvYt2w3+xXHOz7ECy/8HFCtAGckh6zJWcCTV8XCog5JvnltZ/j8B2/bZDNs2OSfm5wJjBdaPVfjUqO9sC3w2OHny2k3WW+wbjumouAPylGMFxqMBkR/x+in/1z2xArRHh1Pd0R6xD6Jix8oeYazgxxQrQN1tQ75vkuyhTWN7kTwse5b/X0Cev03+Rgy7sZrS0A6wb63GHCVnaq0Ix1AuZ3bA7ArKYhWxAsNvus42F4kVKP3D8YFjBQXt5mis4ChBT/UDxgqQp0jfsHyxgirtGvIpxK5hfp67YxtZn9FGsB1AG8H2Y5WHHtoI9MV/HLB2Huqz4Py8SbEC1C/Wf9Rx1n+Ud/YbkIfsNxwJdVE+D47ZmP8/wYZNO2w8ppJlnx97tMh/FOQ5lNqDsn50ANZaD+1jRP6jPbSxXliWaWfppNJF400V8w30C1gXVT9h/hBeqX5qUX7kTV7dPZLScHxnvUbZPgLazPLp8/OTh3X3UFFX9Af2tVjB/MPGyq0l3ij77IsV5J2vow07MgDLN1/zya+ijfXCskyb62nleilWoPrJZ2MVr1Q/tVynXrMOTmSsgOUzVqzgG6vG4+5vsYKQMR9lFfNzrMDyn5QSNP8TZaRsrOAoqiPGM0Lm9Zb/QrBtp2bYttBYgeVfn2bam7EC1He2BT4bnDx57SbrLfbN3ooVbIA+8MUKOK4ZO1awPa1Ht1jBpgyfI2+s4EaQ583p9ypjBWgHOFagxhwlZypWgGMolzM7UHIuHRwrMPym62xzkViB0j9frKCg3RyNFag5juoHjBWouQhi9WKsoBtfee6uYpp55xtsP4rECraT7seKFXw5rUzZWAHKO/sNyEP2G46CuiifB8dszH8b2LBfJ94oWfb5sTHm6z4sX6zgOJH/GA9trBeWZdpZOjnRsQL0C1gXfTGa5AnhleqnFuVH3uTV3aMoDcd31muUbYyB/XpFsQL2B7r9rj37TWqPlW9+0m3vqG+v0RpKU3v1mQ7aBOyTO9LvvNfo7YE+tdEuKe/Tq95H020+yGdn0HbznhfkMZ5H4rEBz7h8hMYGjEXxngzfXQ9cFvtgICM/7yez/A8In90nz77zX3nlGdtQVp5RN15BbbX875tYeZ62t+WZZRblmWNCSp4brtOGlYnn/E4Pyv/vH0Dy/3iPy7+aS/jkv1uMhOUf/be9If935pD/Iz00lfxb27LkH+OJmP9/e+Rf8dcn/93WCH3yfzSlYbklGXRQ/rHfWf4t//8XKP9Guwr5Rx6x/PvmTcmTd67DawLov/vkn9drY8n/S3PIv8/3VvJvbc2Sf8PjePkPPPKvdHAY3pVd68I2HEVpWG5JBp0sf57l3/L/U6D8G+0q5D/m/LVbnIH9edQNn/zzOkcs+b+C5H8Y8vnucAw5x67OqvD5QnVmU53p4zObjcPHys05fDym8pGWw7sq5rw+rGEP7W53YzBtdTcG18WJelq5Cs9/Ta76XKvileqnFuVH3ijdGqa00HMlvrvy8LwYy+ewaEeo7g4D7iRai17RBTfvHa5GS+n/Skrz3f2a9xy7knW2G7je50R+Xou2/MvSvrD1DZSRHLIu16IPpTriOXwl37x2Z/lPAtu2MsO2Tc6JuSbF6TbORrqrpr/qu2q62U3WW3U2rUF/I5Zav2E9G3B6rmt4fNZ7HfSBby2a7+NQ9zUpe7Sc0lBncC36srQefEY3+d6GfKeQ7Kn7aELuYnwuyPNp6feYdoPvw1J3HfjGHCVnLVEex1AuZ3ag5Bnw4LVow2+6zjYXWYsOvZ+upN0cXYtWcULVD7gWrc7QIpZvLbpKu+a7x6cbX3ltGNvI+ow2wnf3DtsP3/17aCPQF7+MdF/ZyGGBy78rgWUT3H9PK6503HefU8g5drVnjv2GQ6EuyufBMRvzvxhs2C3EGyXLPj+22zlzvj9InTP3YfnO1x8u8h/moa3O7XBdnMvWSaWLxpsq5hvoF7AudluTDeGV6qcW5Ufe5NVdXt9W59iV7mL8/ZaMcRvboe7ZUP4Ajvmn0NiN9H1jt+8OmuWUhnrN99OoNYZhyJN1P8Uvg+6+mXgT+36KYWpP3vspfHfxdbMbTFvZDa6Lc9lj6/58P4XxKuR+CnVfi9JPjjHgPIPnI2rMUfLZ7TfFfOMu3i3z2MrxuLHvgWTZU36z0n+2G6HjOtsN7Fu2G+wfcn6OFVj+d1OsAGWkbKyAx3E8c6Pkm+dWlv9jYNt2Z9i2yTkxHwyMFUQax/urHse72U3WW+wbnj+qsRR5yrEC49GA03EKw+P49qOBsYI8/oKK3yl7hLGCP6FYAepuG/J9PFKc6v+APH+K/I0YdsPnW/O+VTXmKDlTewNxDOVyZgfMrqAsVhErMPym62xzkVhB6Ny9pN0cjRUoP1z1A8YKkKfq/h5frKBKu+aLgXbjK8/dsY2sz754ItoIth/LPfTQRqAv/icB841hgat8FpxvfIxiBWr/Ud5zsuw3qPkcjxtZe5qyzsn+OdiwfyLeKFkuc6cW78PPe6eWL8Z+pMjvOwOA9eJzsQf6nVrs/+NeCt+dWj7d5RgDju+s1yjbuL/8nwLWztVaiPIHcMz/uCdWwL97kTceoHSe/TTl+w6LurLv+x+gu0NHjMeMHecbpvbkjfP55mvd4nxMu47zjc+v+ikkzoe/e8GxglD9ZJ1H2cZxl+UzVqzgZRQrUDbBJ3vd9tOw7IWeIWG7kTceoGSd7Yb1J8oq5udYgeVflPaF+Z8oI2VjBYdTHTGeoeQ760zw0Wkdkz4+OMO25T1n3E5xJmj/du6zoD4bnDx57SbrrRrjG/Q3YqkzYKxnA07HLLPOCxwGfeD7nT2Oa6I94hjICkFX2SOMFVyY1oPnOsn3NuQ7lmRPxfXR5rDsWf5ngzwfn36PaTd4j5OKGfnGHCVnap0Xx1AuZ3ag5Fw6OFZg+E3X2eYisQKlf2q+U9JujsYKQu/fw1iBmosgli9WUKVd862HdOMrz93VnS/KRvjWMNh+rPDQQxuBvviFpPvKRg4LXOWz4H6FHRQrQP1i/c8bD1Bza/YbDoe6KJ8Hx2zM/xywYdcTb5Qs+/zYbvN1XodR83UfVplzT777QrrdqaV0UulipPsm5HwD/QLWxbx37ipeqX5SZ8T4/Eyo7h5OaSoeoHQXY2DXZ4zb2A4Vr1T+AI75x9LYva/ECm4F3b2zjhV00OZ61rGC8WkTGSu4s6JYwbo6VpA7VvCOfSBW8AGwbe+MFCt4Vx0rGE3bW7GC9/RIrOArgbGCD0WKFXwd5PkjdazA99SxAqJXxwr2TqzgKxXFCg7dR2MF3wQb9v06VtBBO0sn61hBPt2NESv4fkWxgg/liBVg3YYpLeYZBNyTkXUG4Segu/1HjseMfQbBt/+x6jMIvr1X9RkE/91+vjMIvljBMKTFOIPA8qliBepM4ZDr1AeMFfzjivG4sc8g+O4d8Z1BYLvhiz9M9BmEWWlflPTpKz2DsCatY9LHczNsW94zCAtSnPoMwt47g7Ac+sAXK+A4xzCkxTiDcHZaj25nENaS7BU9g7AB5PmI9HtMu1GfQajPIDwFnn7ur2cQ0EawHRiGtBhnEM4m3Vc2MtRnwTMI30sJ5o0Vsv5P9BmETWDDriLe1GcQsnWyPoOQT3djnEG4KmPcxnYUOYOwlsZurDffGTRR+wrU+Uz2fXeA7r6aeBN7X0HIfN2HNeyh3W19jGnX+wrG51f9FLKvAGNiw5QWe18By+ewaEfouDsMuB+iWIGyCT7Z67avwHcniW9fAduNXtpX8EaKFfTivoIHwba9JcO25d1X8PbAWEG9r6CTp7H2FfyOJ1aA9qjqfQWfo1hB1r6Ch0n2iu4r+ALI83vJ34hhN+p9BfW+gqfA08/9dV+Bususqn0FnyPdVzYy1GfBfQUPUqwA9Yv1v5f2FXwNbNh3iDf1voJsnaz3FeTT3Rj7Cr6TMW5jO4rsK2B/YLnAVTahQfXF/MPwjvmvbA62mecnyhdS65zLMuigTcC2bU4/ee3n7wJ96irX4mP+dkC3+aDxRPlGfM+nujNXjQ3Loe6/SWNDA/JdS3VtuM66NkTbWhnlFRb2yzr4fiykY/6pqcKbf4L8zNGvG4egjAMMxC4oMxuxrfYofxJ9J0UveZoirT+gLk+ctOf8+3+2blqDyltd+B3L5WSR/1qR33g1QHVvu6DnfKW7RtvSuO2YhvpndUh0di3Vb3LB+oXwD/FbIv8myJenL2a68bKA8m76inf0zqY0ZX+r2Gfm++1Ayz/rqLFyK48ajxl7nxn/Nk3efWa+36HtFrdm2vU+s/H5VT+F7DObDWn8e1Shfl7oPjOWz1i/abU1YJ+ZT/a67TNj2QvdZ8Z2I2ZcmfUs7z6zdTTe9+I+sw1g207IsG1595mdnOLU+8z23j6zM6EPOHaM9ojj3miPYuwzuyatR7d9ZueT7BXdZ3YdyPOF6feYdqPeZ1bvM3sKPP3cX/eZoY1gO4A2IsY+s2tI95WNDPVZcJ/Z8zz7zFj/Y8aVedzIu8/spWDDXk+8qfeZZetkvc8sn+7G2Gf2+oxxG9tRZJ/Z+TR27yuxgjeC7u6uYwUdtLmedaxgfNpExgp2VxQrWFnHCnLHCh7dB2IFXwDb9ruRYgW/V8cKRtP2VqxgT4/ECr4bGCv4YqRYwf8Def5KHSvwPXWsgOjVsYK9Eyv4bkWxgsX7aKzgH8CGuaPHY9axgmydrGMF+XQ3RqyA5TNWrID9gTkC92CB23CddsjyD8M75v8KkR/5wb+rjXxknwDLzc6go2IQycP7zCz/1JTP3Xxqo12FvCOPWN6Vzcb8eff18fwa5YTvdUEeG02r88EC8yne09iwCPItdOPTDoE0PsuM+9j4t9aGIQ3rgW1AOWhBHsPtp/xLjh4rdxTpnpL5Q+BdXplvUXuUzPuwFnlo++RF0VZzD66LE/W0ckpXjDdV6Arez8O6ovrJd5+P4pXqJ7UnmPdkLoS0RZTmuzsJf2uNz1iibA+7sTazfC4S7WjBOx4bWqKuCe7wovG4SwWuT/aGRX7UY5a9Q0T7lP6z3UD9Z7uBMsp2Q407rGcoq5ifY1GW/7S0L2x+gzKSQ9ZlLIpjHMuhDkq+ee5u+TeDbRvJsG2Tc2KeEThuWj9WMWdDfWdb4LPByZPXbrLeYt8cQliHCCzkKftUxqMBkR/x+in/hdAHHItCe7Sc6o72aJjSlgi6yh5hLOqlaT3UHvQ25LuUZA9tGtuL5GHZs/w7QZ6fk36PaTfYJ0U7gBgsUz45U3dX4BjK5cwOmF1BWawiFmX4TdfZ5iKxKKV/w/COY1EF7eZoLEr5vaofMBaFPEX6uF6ZPBNt15BPIXYN8/tiQ6zPaCPYDqCNYPuxxEMPbQT64i8l3Vc2MtRnOQRw56cOidJx1n/fXa0o7+w3IA/Zb8C4mPJ5cMzG/K8EG/ZG4s3euJfShzXsoR3jnguui3PZOql00XhTxXwD/QLWRd9cO3lCeKX6SZ0B43hTqO5y/BnHd9ZrlG2Mp7wxY9zGdhS5Y4X9gUGBO0ngWv5pgNVHGMn3O9Lv/ZT/buG7GmZL1KEB77hPZ4r8aKusPtOpDlh2uihncq7k3fKVlPdpSt6xPSzvsyCtT+Rn3swW+WdBHvaNMN40jdKGIM1oDhEO8jup+2/PH1+fbn3L8jUDsFTf/lr6vZ/yv8cjX0pepsA75qGP51if6VQHLDtdlDP+KvmyfCXla7qSL2wPy5dPXpKHeaNi1xwXTp4W5Uc+WRrqpdEcIhzkd1L34+eMzzcE9WlkfFpd+R3rAmJtovpMi0gH272O6EyFtHb6PWn3Z8huI0/6RNnXpN/7Kf+fgg+0h+ZxWH4albe0J0DPbrstu7zxcrrrtCV8zhL5gWNJVjsx/69ltPPLUM9bPLESe1dS71pK79D2hdh1zJ/XrrPtRp2cSlhTBRbKN9tk49GA031geP2U/5ueWAm2j2O+gznrrsYTZUesbNIXT6YMUn7ADKKpxjDVVy1RvpWBNUnUH/WW+73P6fGQ85tMYLxS2ed+yv/X0Fe336YxXUYdpmbUeSAj/yyqg+X/WyEvPjuA8j+TMC3/DwDz7JyYr8vA/HuPr6H0dAa8yzuesj+BfOR9plh3HhdnA33O+6tEH9NQzpmu89RX+ZC++vJ4Y2mTjnn6M+mjn1LcH32LHLa6z9dXzxP1De2rqZ72MZaV63ed8ujTEeTHfx2tMSfnxHQpJo7pylc5FvCtHj4bibaa7TLaDNTDz5BPgvQnUf1tnBiE+vvWRQyr3Fjf+Cs11uM8msd6xRvMzzZhhsjP44hzerw5itLUPK0h6pB3LMU531dnj8ed5sFNPm+kenTz8V6Wfmc7PF/0u4+HPp6rOSLy1eqj7DDHFJTMTrQ8YvtZHn1tdS7/fJjlUY0fSh7Zz/LJTfL45BHjUp8h326moKlsdF6fu0HfzcYPZORnm2/5Dwc5Zr9nrqgD2lWu8zyRfy7lwfbjuDTPadqol8iTjdQey39soD2OFPOYqeQf+cby7+NR8jBP54v8yCvjSYvyI3+VrZ5LaUiX5UzpbKhuWNmED3eTrQ6dT7FdzYo7sK22/M/y2GrVNp+t7maP2A8Ljc/5bHWVstqr8Tklj93m1b9E8qV8n0me+of6PmqsZduO5aa57vXyzemxfMtDZ2pJOsovVvGkRsan0eF3TEfVWekLt0f1z4zA9syg9syI2B5VZ44RJ9/b6fdEVq+mOQzayT4qmzw83ln+X4E52TXpdxX3ZLkJld0pbnw9ZwAPlM2+2I2137lK1rEm7+11LLZVaOOGCGtIYKHs4dhpeZyLavcn540P++xg8oSMiagT1jblo3PsGOWNba/iJcqezw/BeyU3z+5e/2me9naTD15/wHGez0up+YqSBctXhQ+A7WFZ8I3pycO8UXMGHOdZFnB+MJPSsP/Zj1B+m7KX3MdoX7FfXpN+5xjgGz2+o5IDn9x08494Lq9ieL555UT7jr0iNxz3RduTV27Yhqh9CDh+K3s3ib4rXxLz92XgtAinQe+nwHss9yvUZvaRGPtVlN/aOZCR3/DYF3nIE0uY2aUOr6Y6zOpSB15zsfzvFXXw8T95fD7hoOvUxRx6049jkD3sUyJ+02n5aLugp8H8M3pKDpKHdVnpE6bxmKxsoNJzhdWIiGV+g/Jh1xOdvPMiLO+bf42UpDMi6FQ9/1pPdGZFpIM6M0J0Zkekg3LQJjpzItLB8Wgd0cma532Z5nkqronjD5+BsPwz142V+xrN89BW8FrfXMBzIv+6DHr/O6Vh9g9jjjnskTznZFjdePcN4p2K//l4Z/mfPHas3Lc8vGPdVj7GdNfJD/bpMQbL8W8Vz8V3LHNY3vINiXI8Xi2A93nmiiG6gfhN19nmIuPVAqKHbU8ePj+ysBi90fMj6gyl6gc8P4I8Vec/TceUneWYAdrG+ZSG9mwepaF+HwvfkUZWm8y39e07Un4o+m4q3sKyN9G+0sxi9Ly+kooP5fWVeI2xV30lrCf7Snljrlh+hofOSEk6I4JO1bHd2lcKp1PEV5py7Nh7tP95faW7Ybyfln5XcZMQX2mmaAfTm5XS2Ju+0hziXbf1BOad5X858G6+h3es27WvNFZPfIf4ta+U7Sspf6NKX2lmlzaxr6Tqp/yd5Gm7sCfEl8L25ei74VDZNPxYvpTyS5QvVXIfbTvpjylpOfRjb4bvyDukM4vqULb/VGxmb/Vfqxg9b/+pmFXM/kPdytN/Sjd5r0Vev1Kti1ftV04jOllj/Bk0xqs1Ld+eAcu/Gcb4s2mMR9q+fQG4z4HbHGmdv29v7y31+ei8HqX2mjRcZ5+ofUi85jRJ0EnaeljGunUDcF8jyrJuY/5Zoh6Wn/eUch7e02/5n5PKVNJ/GzLO86h9nVh/ltnnASavw6q1Rt/+jm5rjb41+rmUpvawKZ2wfCV1Ynhv7zdluUdflveNsn4lz0aB5atrq0RduR+xr+YTFp5fUXs6WC4t/w4hl6r/jedV9L9vHV7x1LcO342nHO8K3W/MsSxle0PX4dGGnDHBc1SOGSyAuvSJuhpuP+V/FYzBb6Vx3eZLzoXprJqf4ZyL9yPh3GxRAJbPli4W+Rd5aGO9sCzT5npauQp1S+6Tw7k265bqJ8wfwivVTy3Kj7zJO19eQGmh8+X50Oa3ZsSWsB1F9tBwzErZKp/shY5VSv/nUxqWY7uhxjilS2w3sG/ZbnAchPNzrNHy76JYI8pIDlmXscbFVMeFUAcl3xxDtPwfB9v2QIZtm5wT8+HAcdb6sYp72lDf2Rb4bHDy5LWbrLfYNxwnVf4s8pT9euPRgMiPeP2U/yPQB3ynAtqjhVT30Pgdn0lSawgJ37+Z1mPIdepuG/J9kmQPbRrbi+Rh2bP83wZ5/jT5GzHsBu/tRDvAfqoac5ScKf8Mx1AuZ3bA7ArKYhUxccNvus42F4lbhcaoS9rN0Zj4EkFP9QPGxJGnSN+wfPdPVmnXkE8hdk3FyVuus42sz2gj2A6gjWD7MdtDD20E+uLfzFhLxHaE+iy4DjmF9B/1i/UfdZz1H+Wd/QbkIfsNi6EuyufBMRvz/yXYsJ8Qb5Qs+/xY9Vt4eM/gPGoPyvrBAVjzPbTVPaIHe2ir+425Ls5l66TSReNNFfMN9AtYF1U/Yf4QXql+alF+5E1e3V1MaTi+s16jbOO99D/JGLexHThus+7OE3VFf2Ci9v7FihX8DHR3+rrxmL0WK/DF2+tYwVh9utnYmLGC0H2IMWIFLJ9q/S103MX9vrwXWMUKfLJXVayA7UYvxQqWpAm9HCs4Fva1L82wbXljBctSnDpWsPdiBUdAH3CsAO1R1bGCTekf3WIFx5HsFY0VbAZ5PjH9HtNu1LGCOlbwFHj6ub/GCtBGVB0r2ES6HytW8GU6a4T6xfrfS7GCK8CG7SDe1LGCbJ2sYwX5dDdGrGBHxriN7SgSKzguwyZYvyUP3teatZel4fS8nP0so52114r9LMt/K/hZG0g+1G89J217WUbb0E6ou/k6zlmAnXgF+TrIL46LIm947zP2Aec922kevBbq8SqPz2XyNeRpY4Lx+nXZ+c4W+RhjkuCBb28M2yG1F80R5iSRl2kof1nRmEWYSieSR/n/vjMarHv8bpLIPzejvU7QntcFd47AUXaIbdtMkdZwnTqV1zfA383dlVZA6UuWTii5muupO88HfPseVd0V/9B++PZc2d8sWzNFOxvib6vfy+Fd1n5WnJtiHivLe/Z2C5vJmFn3BN2WgfmgiDn4ZOZ4eJd3fyrfE6T0XNUdbQm/U/0zlfKyf3m2qFPW32ovf1YdZgmcibzb5w2km3gmYIjq3qK6Y14+i4B/K/lu0HdrK8o35mH5tvwf98i3ukMB63VbBuanPPKt+H4cvMu7757vu1Z3qKq6o+3hd6p/WL7ZHp0t6pT1d9Z5eVWHlsAx+R7KwGSaLA/JE3pH9VySb6TD97TnPT8zKOrPv8f2FZAl/l0M9Rtv2MaNGZhf98hn7PvYrT6+33hT5bD/BgWttn35H/9jeKYLB7lsGeRzFP8H+HTpbbouDa5Pl6fC+7PaKMP2qBjh3ro/q+Q5v6V4Dg7l6Gb4jrxT9wXyOcQG0E/06Ds031M6hmVvTb+zjv0tzLP+JgPTuXK26Wczx+PGPtPFcTf1O3C++7l9v3djdeh2luRl6Xf2If8BdPOWyu+ub/xkb9/pyGdJcF6T5Tshlu/sGt5hqPqAf/PH8v+7Z90K2zeb6j6Us+4tUXelx6gbrMfqXOGgwPXpPdb7xvQ7630jdeZi/H5qtzvWeR0+9J7qCTiPOnNvn0e1+qsYBvuRvrvP0UfD86V/Rbb3bshn9cE4McvXO9K/s2KYVraf8s8G+dpAOteE8ndTO94BdTGZs/H4t6jubRf0TMJxyR7lbxh+k+qSk96ov/FbRI/bZ7KS9Kv1+607t23ftvP2C27ccvUZW2665dbtW/FUMXKcqTQIFd+xBmNaH72bQvkuor83iHJOYKPluAfSFCf4Zg5s0z0Z5Vhy+d0kkf+3COu3RDmre5+nPGJgOZYY1iK00ncL2qxFK0CLfum2bLp3u04+sCYNCnqmdfdQXufGtO6d1Ka2C3ouD9U6w29SXYpq3TuJHrevmNahpCCVywjV8mBefC6DmmH+KfQ3995UUY4f41g/1fm0VIoS6Tsy/a407XCqt5J2fMdxAixv+RSd5SXpLBd0TJKHIW0dpR3mSTsS0g6ntOsgrU1p26Gemyhth+tss6Xd5MF8u8BM+u7Pjxsrk/zbBfmUpLNV/R2giWXx78kiL6/RWd5NIFfPIrlCLWa5uqdLvX1ydY/LprO8JJ3lgo71Ccovy847RVst7V5Ia1PafVAXlp13iXZZ2m97MN8tMJ/aa3vc+Hy7IB9b/N3wPocFvizU4ht+k+pS1OLvJnrcPo7r3F+M3qUNKo/0ENPqY7x+QKQZ1oPp3wMZWFa2n/K/IO3PFuVLnk1E4wFRX3xn/Enk5DkkJ8jbRsan4fI71i9s+y43ng7amzbU58oMm4eeFJa1uQ/bqo9cPFZuK9kqLM99Z+UtXX06F9b+Xa6zjdNdJ2+Wwfcs+d7tobPM056q+nMZ0blHtDXh/UupP++HtD5R9ob0ez/lvxf6cyf1p9JFxWcel/Ly+XBBp2o+8/jyQEQ6aKfa8D359xBhMZ+tn4zPD0LaQ1TuYUjDfDjregjePyxoK3zD6CaDdxyn25Ylg0arn/K/CmTwzoIy+AClYR/scuPrafVAPmD+G5xu10BG/qx2vQlmnfybL1YeeYV9wfbX8r/VE29UsvU78I5jakoeHhLtUjx92HWnjXzekEF7wPllsZ/yv1PwVI0LD1HdEfsYqsuDXerO+o3lLd+QKFfWjqg6d9PJ+3Pq5EvT7yy714JOPkQ66ZMRrPNyN74uefm8XNCpms88R3g4Ih3UmTZ8T/49QljMZ+sn4/N7IO0RKvdeSMN8OC48Au/fK2gr/NBx4ePH6bZlyaDR6qf8G0EGP+WZF/tk8GFKQ57ucuPr2c0evpTyW70HnH+87af8ezzjgtJXlBseFyz/E55xwehiu3zjgpLF94h2KZ4+Qli/I7CQzzwuKJ5i+3+H2m/5vxI4Llh5FY84ltIwHnE/pWE8Yjel3QdpD1AaxiM4NoLxCLZ374Y0lBGORwx72oNxO473YdzunZSGcbt7KW07pN1HaRi3exelYdzutynt7ZD2bmirxe36qa3fSd+XXN+SZ3mz4qKcDz+dCxsPsK+mEJ3fikgHsc4mOvdEpHOPpz33CjrWX6gvVaxHGn7TdepukTjZfUSP21dsZQStDXMFUfFdw41vPab5VkaSJ8Z65LsgTXGCI+fYpndllENeOPFuksh/H2HdJ8pZ3fs85REDy7HENOh91nqkYfRT/n+H0epVNForWsgPHjGt7lk7C7gOlv/nYmcBY/ZntOveDMzW8WP8+J/jNKYTmKpd76J2cR3uozqMytPxY+3iXzl9lyjvMt4lf+Na77sy6qf6ieuKo1xWe7ifLH8T2sP99E5RB9TJDV3qwHnelVGHaaIOwrqdceNNt6fWzdHTD9/ZGinO87rtOwVO1mPcSKTQJJLXM9hSqXcsAVY2abnt1UtbfubW7Vt3bs1oO1vuKRk0Jzn9hIyhu+F9FWOo4ccaQ3cTvawx1Nqu4oAtkbYLvuPf3egkfWr7FtM+3bzzxpuzujR0cG2IanF5R1gN8S55KlxyLCwGu4rRy73kmM+VQuFkriAqvvNxvltvn01/F3Gl1GLoLoGpgt/3Z5TrZuQmify7CWu3KGd17/OURwwst4swWEOyXCl2OSz/YTA02dYuLmN/3w7feevWbsqbPCUXumeGapXhN10pLW74ZAnbV0yrdsF3pDKDUC0P5sUHf04V82cNi/ZsFOX4MY6FDJkFe3WoaK+WHTJVr6qhzNr3QDF6UxtUHukhJofEHhRphlV0Ce2ZqXZzqD55eHtG6PJCYmFOOX48vV1p2gUwgTk9/T7dZVtVtl5Ie5eg3XLZFpG3biffs7ZIJQ9vdQrZBqXSflu0S4Ud25T2OwIz4ds9x4/Ph3LbyPhMHl+IydfHu+Edj5JKxlgms7AuJqyspfLk38NdsC4hLLVMwO4slvMtR5m+81JP2wU900LtmeE3qS5F7ZlalsD2sT17pBi9oQaVR3qIafUxXmctoyX/3pf+PeD8S2r9lP9Ksme49Mb2TC3L4Tu0Zy8gnUPeFtW5lutsu/UPz0XQPiT1ueb48W15GNKU1/iK9Dsv958AS4DXkT1G+bM6quVRttVK7t7jaf+9gk7VfGY7fG9EOmorrU/mkM/WT8ZnJfNW7n2QxrrL8oz5EUPhG0Y3GXzl8bptWTJotPop/2KQwV/x+AQsg8i3eykN+4B9JSWfmP8VlN/qPZCRP2t5/Q4RKG1QeeQV1ouvGrD8dwImL0Mr+7sb3vFYr2RR2WvF0/cS1m6Bhe3hQKniKernbmq/5X+T4KkKU1l55fP5lqEfoDRc6OAlYwxQP0Rp6PPtojT0+dje4xZflJF7yJ+29tyXvh90nX2UYwyXS7OsU8hDXM7GNOfG+lMdIWyJ8u/w0NlRks4OQWdIlLN2l+RjcJzP8GMd4byX6GXxRdl0K6u2c/CiiW1xaJ/w9Gcim+8j34ivr0we4+swvM/RzhNC+Wr4TapLUb4OEz1uH/P1MFGXlkh7DnzHNKRzmKCjsGZFxDo1ItbciFiLImLN79E2xuzHmG1c3KNtnB0R69KIWCsiYrUiYq2KiDUnIlZMmYipjzF1KKZMxOTXvIhYCyJixeT9zIhYMXk/IyJWTH7FtIULI2LF5Fev2sKY/Ippcw4EnymmTMQct2PyfmVErJhyH5P3qyNixeR9zDbGtBMxfYCY/FoTEWtt+t1iTMOQ9g6iMyzoDHvoYPnhACwVP/C1MesqLrMxo1skr7z1mgtuvMbRwzs6z8qo4vGUb0NG1RoCt0H/+P3x9K5P5EXsJKz0xdRvq3Bb3rENwnNOh5UMf6K35eXdnXk5fMc0pHO/oKOwZkXEmh0R69KIWCsiYrUiYq2KiDUnIlZMmZgbEWt+RKyYMhGTX/MiYsXk18yIWDH5dWpErJiyuigi1oHQjzMiYsXkV8xxaGFErJj86tVxKCa/Ytr7mPIV0+bE1MeYMhHTZ4rJ+5URsWLKfUzer46IFZP3MdsY0070qv+1JiIWh0l2QxqHSXYLOrs9dLD87gCsXQLL18aKwyRWxWMo34aMqjUEboP+8ftj6F23MAnvynlzuivHwiIFdxXJ3WC8SwvDQbjbDdOcC4vUYfnDPHSOLEnnSEFnSJSzdpfkY/DOf8Nvus42FwkvqV1yii/Wvl3F6I3u/N8l6CEm77zbLdJYfwYysKwsX7T5QCr7LddpUnjnf6jpSsKQ7z5hfN3VrsGQfkZcZRJD5LEoHZSndvpd7bBmPd5FdLLMstLjXRlYuOMZd1q/m/JjPyvMdZCO+T+c9leyQ/i16Q5h3yXXSX1+94Tudb1X1JVPt/3Xs8fK/V6Kqfhs/a7kYBelHSboKky2jZbmXFjfHSnq4MPC/rqO8ltfDGTkNzzuu89C3/GOebyoSsnProw6oPxgHbLk54kC8vOFE7rXFcteR7Qt/3dAfr5E8oPlffLDu3lRfna58ZiYxjut846tWN43hvPF+KruDUrDOvh2eysehez2RrnIMf49HmKPET/Wbu93E70svpRcHtvDuoT0EPPdRO/+YvT61ElnHhfUSWesS9ZJ57+lcfwBUaZFaclT9JL6icbync7GPklsy/8lXqA8NTI+DZffcR2xv0J0sCgd1KF2+l1NW7fA926yrOhg+d0eOjtK0tkh6Cj5vgkwfCfAS95S0B9q2wy/6UrpfsOnEyp8oWyFlW2JNORhN31BOgrrsIhY9xGWkpstAisvvyoIhVxG+S7JqFqfwG3QP35/Gb3LCoUYtlLJrGuKnAtTSXUH7USpfoXX5gSrtuFP9LU5aoi2svviEF2hmZ68P5np5Cl66cy+gpV8f2b6XV2ispHo5JU/LG/5fL/BMijqV4X8GX7TlZL3ho//ii/W9odEXVoi7Wz4jmlI5yFBpyXSNvU4lrp4h+Uvr5xj+ZDflBh0nX2QQx4GQuXP8JuulLw3fPxXfOGLhbBsi9KSh/tZXXykLvE50LHUxU+7iU5encHyfMEDlmNZLnhxU7AtNfymK6U7DR//FV/4Uh4s26K05OF+znsxUK9jJd83p98rvEDsoFC52FsXiFnb1eUxLUpLHua/7+IwpFNjxcNSF3ldRXTy6gWW910Ytrsknd2BdO4vSed+Qcd3MVnJi/QGQ/Xc8JuulF1p+ORJ8UVd3GdlWyKNfenQC/daIq3o5X01VjwsdSndbqKT1zZh+Uc8dO4vSef+QDpVtGdIlGObwZfvtV3QE+wzGn7TlbJRDZ88Kb5Y298n6tKitORhuVWXFr5P0NlXsJLvV6ffTf6w71n+8uotln+vh879JencH0jn2pJ0ru0xOg+UpPNAIJ2HS9J5OJDORMnbQyXpPBRI5z0l6bwnkM5E8e2RknQe6bH2TJTdqdtTt6eq9gyJco300/w5HO9z+FfBW8YNv+k621zEn1P+jOKLte/9xeiNbhl/v6CHmFYf4/UHRJphfTD9eyADy8r2U/4/PfHpzxblSx729z4g6ovvcMv4N1Pc6aK+uwk3rx+J5S2fonN/STr3B9LZ39rz3pJ03htIp5aDuj1VtWdIlLOxo6T9nt4gPKsnvkP8putsc5HxSY0Xii9qvLCyLZF2MnzHNKSj7HzMMaPGqrFqrPFYZivRTu0mOj4fUtHB8pZvSJRjW4n2oorYrOE3XSnb3PDxX/HF2v5BUZcWpSUP9/MHBZ0PCjr7Clby/SXpd5M/37wjr5xj+Q946OwuSWd3IJ33l6Tz/h5rz/0l6dx/gLbn+pJ0rg+kU/NtPJ0DlW91e3qnPUPp39dBWjv9nsSyXniSpolHm7HsTen3fsq/4tSxcltOGt9GPE41ndqY9xgylvcdQ+aj9NgGvurkJoHZoDSs302e+mH5mzLKYX2Sx/ro7fCukX6WvKIk+Aer+IqStxej572iBNvHPuq7RF1aIg15mEVnuqDTIKxu9Yp4nM6qeBjl25BRtYbAbdA/fs+3ifSJvIhtoo/dzKKPbPGxSon+2yeYDmP1O22+2pCO+c8+5enPxHz9cmq+TDR9Nwtgn+VQk3Whamn4sW4WUOLv+x25d4u6tETaRfAd05DOuwUdhTUnItaCiFiLI2LNioi1JCJWKyLWjB6t16KIWPMjYq2JiHVoRKy1EbFi8mtuRKyY+rgqIlZMuY9pC2P248yIWDH7Mab9ismvSyNiLYyIFZNfMXUopj8Rk18rImLVdnXv2dWYvF8ZESum3Mfk/eqIWDF5H7ONMe3EvIhYveqvnhMRiy+5xjk6xx7UfPhdHjpY3vINiXKN9LPkDYR9DcKzeuI7xG+6zjYXiRMo/iu+WNt3i7qo8DeH73YLOrsFHYX1TsJSoVoV22hQ+W5tjBgKtCoeS/kuzqjaJIHboH/8/lh6lxUKNGwVBf/tjHo7FxYFx/I3eejcW5LOvYF0jixJ58hAOjtK0tkRSMd3ySqbuLyXrGL5PJes3gPvq9hxaPixQqH3EL0svlj73lmM3jSfuUFMq49aEUHeookdyMCysnwB8ax0OySvrCQP77IJHRqTkPm0k8fnw/rugjK80pV8bwPO3JPH1+GdkNYnyvJFy5Z/08lj5Rak39Uq4bAbnzYMab9FdcYVO5b97fC+itU5w29SXYrK/naix+3Doc+mcOnQd8GNW64+Y8tNt9y6feskhHadVha5gqj4ruHGtx7T+ugdL3INU7kNopwT2Dgi7oA0xQnDNAnBNu3IKIe8cOLdJJF/O2FtF+Ws7n2e8oiB5VhiGvQeNexuQbuf8q9NtSq5Rv1VdJW7ooX84IVPq7tZM87DdbD8R0IdNtymMfsz2sXavIP+HobvZ2fQPwOszLEna/pO0Of2Jf9sdB/IqO92qoPlPwF4YFfqq/0GWB/1DnmAZbP+xryHUFvwbyWLd1P+t3dpO/e/5T/N0/9HijpYvZJnQ5c6cJ5DMupwuqiDsJpn3HjT7anVdPSwb89WjnuJe+JIgZP1GDcSiT2DxmzstetEuSPpbyUBScst7DQ6Vdq+defWjLbziHBYBs1JTj9DTtcteQZdqbEyeGw2/KbTktd2QU+DrafR4/bx1Hu7qEtLpGVpaTc6SZ/a7zunfbp55403Z3Vp6KCtjAWXd1S2Id4lD/6cuIr68HQ2b9QHy1s+RefeknTuDaRzZEk6RwbS2VGSzo5AOlVE5RgrawqxM/3eT/mvBMN+wW0ac5LATB6+KH2XaI/a5Gj5d4v8u0QbjZcYXdwdQBt5yQPh/Tnr+oDIjxtRd1FdsX4P5KzrxRNc13eJug4J2jzkYLuqGHIMvynaUGTI8fHlqYqln/mmg7vgO3MFUfFdw41vPabxyHIT5TuH/i4yHVTXId8vMNXV3g9mlGPJ5neTRP4HCOsBUc7q3ucpjxhYjiVGlUv+/nVRxqcBIRKcPOzEPBgRq4Kre+eGaua+cHUv6k6D0pBO6BW590XEenckrOTZ368nrrFqrBpr/8dSx7v4JwZw/LTZh5od8Aw17z4L9Supis47StJ5h6AzJMoV9RVanjqrnxpgvuX9qQEszz81gAt37fR7Mlv9zMmaJs5ksaz9Wir/MuKJcLZlz8nZbUQ+W7u4zoNAw9LyLPYe9Iv/nke/uoo+zmTAzdIf9OHuSL8rX+IeSsO+NoxuffAV6oN3Q5rqA6sPL7y2oQ++Tn2A5fFnS7L0RtFjGclaGH431c/y/4lYRlD1uz+DHvID+fybGfS+JaIrSu6Mdkm5m6vkDvWV5S7U7w6VU94T5bsuX20UQDngiI2Vz/o1ZsPjX0L+a9HnoXLO/Wr5vxfYr5HsiexX5BX3625I841DPjnA/jKetFxnn2dFIhEL+zqkX32bPCz/P3n6VW2owHpyv1r+fw7sV+NlFf2KvArpV8zP/arGb+xXPuuI4+R2wuq2VzKkX7EP2EZb/v/y9KuKcvvs8Gj9ThnD3Ft2GHkV0q9qJSC0X9kOY7/+DqXhWMe6PFE2egj6x/qcfX62C1n1y9rbWmJxj9eiH8ioxhxR3lHZBr2bk4FlOMm7XfAu6zj9gNMhUGa55Z8tWK7UFOujTJS1p+QW8OBFAd4CXnC/oncLuDKp1vZdoi4tkZZ3WKxAVJPnnIxqNER5R1gN8Q7TlKji+qCJqtoOiSP0XJopoAjxTEFZPuX5W37zQLO8C8Prp/wrhXowJtZB/aCY5ff9MBHWR7Wff+TF98NQlhdHR7T8PDpa/sMDR0ejXcXoiDzi0VFddq5+pMXyq8tn1Y84tCi/UmnkMf+IQTfTwfKv5FTNvpU3fq/Lbm+3WRnLF8oE//CYms0pWbB8VURKsD0sC6E/8hUiO8iblusuJ6iX/AMdPruUPD5ZwOiCRcMGARvptF3Qs9roqNVnw8b+zNFnV2Gd7FFDtb1rUl2KDtV9RI/bx0M1y2TytETaBfAd05BOv6CjsOZHxLo0ItbCiFgzImKtiog1JyJWTH6tiIgVU77mRsSaFRErpky0ImI1ImItiIgVUyYWR8SKKROzI2LFtKsxdTumrPaqXY0pEzHtV0wdiikTMfk1LyJWTH4tiogVU1Zj1qset/cev2L6qzFtdEwf4NSIWCsiYvWqTMS0E706DsWcw8Rs48ERsWq7un/Yr5j9eF5ErJj86lWb06t+4cyIWDH1MeZYG7Mfe9VfvaZH6xXTrq6OiBXTTvSqjY5Zr5i871U7sSIi1oEwr405bi/p0XrFnNfG7MeY+hhzDhMz7hsTK6ZMsA410r8xzzr4fiykY377oaOSa8VX81qsYSD25ILYDcJzbnw9HeEPCXpWr2ZGWtv5n1//yBP3XfAPX/5hg8pbXfgd708YEPnVmrbx6iAon4NXV6o9HEbb0lBGJlMa8sXqkHyupfoNFKxfCP8QvyXy86m00L6Y6Tr1yPhk+2LwxzX5lFTeH+rE8h/00NlRks4OQYexsn4Aje8LsfxHpHZB3RfyIVG/HaJ+lv9Rkf9DkMfqo3hjZYcE7UbGp9Hhd8w3rMO9ROfRiHQehTy7iM6HI9L5MOS5j+h8JCKdj0AevjX6dyPS+V3IcxjR+WhEOh+FPHw682MR6XwM8rwDyiV//x6kqR/T+7ioh9niT8D7HLa4P6QdiN+kuuSkN7q/6xNEj9vH+7s+KerSEmm/DN8xDel8UtBRWG+PiGV9O9119vVuovN7gs7veejsDqRzf0k69ws6Q6JcWR1RvDE6n4hIB3XmfqLzyYh0UA7aROdTEel8CvKsIzofEHVI/IGtp469T/79PqT1UdnksZP4/ZT/1c8eK3dtimkyiLYC64jl0R/7uGgH09tBc5ZPQ5kc9mhc3NkRVjfe3Ui8+zikhfDO8l8FvLuZeIftYt3+A0j7BKV9BtI+SWmPQRpiYJqDNuA7ljksb/mGRDkerz4L73P01+QQ3UD8putsc5Hx6rNED9uePDx321OMXr/Re1zQU/0ww2me7oHvhmU6puzspykNbeNjlIb27DOUhvp9LHxHzKw28U1kWD+Wb6zfhygNffpHKQ398A9TGvrOH6E0bDP7t9bmyYSTPJso76cp7++JvP2EO++ssTJvOnU83mMZtJPvfMmz5X0H/LD1W9PvPB6pMeQPRF0t7TMiLcG/+plPfzc+ooxiH2bpGL7zjd+WT9HZWJLORkGHsfqdntfeCemY/+M0fu2BMjnsxTXG/8fhJdvazxXEDrW1hj8k6Fm9miItJObW/8UHHv/9657c1KDyVhd+x3GHJ0T+jSK/8erzUL5szM1oq5jb5ygN415WBxVze6Jg/UL4h/gtkf8MyJenL1qCzp0RsT4UEevDBbEsrvg4lN+Tflfj0oNER8XTPuSpM5a3fFXHxx4kOuhTtdPviRw/Rn7xhyGtT5RlG2n5D4Jx73Hyi9X43yBsB/TQ92A/A8s/Rlif7YJ1MWFheR4r9nTB4lvOsvw5lLMsrM2EheUfJ6zPebCwf6aL8mz71fy85Dg0kHccaoo2FPH5fXxJHo5RPSHq0hJpLK9qjHpC0FFYj0XE+mxErD0RsUzelI49THTyzl+xfMj8NUQWFR1VZ47/sx39LtnRz0Janyib5Wv++5lj5f4f2VHsc2w/t8vylTwDfpA6A74HMvAZ8Mchrc91ytZd6feW67RNj1Ia9oFhxOxrxVM+O5537oHlP+tpz3uoPVky9dOcMmX8ZZn6fyBT/xEgU0p3d7vxdcmru7sD6TxSks4jgk7VNmI30dkTkc4eyPMI0Xk8Ih3UxTbR+VxEOuhXcMwiSw+mP2PsPY43WXrwxvR7P+X/NdCDmSmm0gOsI5ZHO/pZ0Q6mNy+lUXK+KuPehtWNdwuIdz4bkjwc97b81wHvFhPvkDbrtvKLLc3nNyCv2NexNAdtwHcsc1ie+YbljL/WX1+A91XEvQ2/6UrJx6gP/AWih21PHo6f/GExeqNx7y8KeqofMO6NPEX6hsVxb7SzH6a0PZD2eUp7HNKy4iTJd457P9alTTwfVbJvumPx482gO8ekujNEeZLnMjc+DdtusecE4zjSvz2Qj+O0e1xne/CdL067x2XTebgknYcFnarHT/bl0S600+8Jf59JNvNxSOsTZdmXt/xnQr8/yzPe7IF6cbuq9OUfhwzsy6v5NOoU+/KoU+zL74E0w4i5b2uifflHBR2OqbBMXRwwDmPZLF/+WJCpSz0y5VtL2+3G10Xt98N3Pl/eR+eRknQeEXSq3u+3m+jsiUhnD+TZ3335LD24LsCXx7JZvvw3zhgrt2MCfPmbJ9CXz+Ldzhw2JHmyfPmPA+9elsOGqJih8tcfpzT0+RAD0xy0Ad/5Yo2Wb0iUM/6W9HWDfXnDb7rONhfx5f+Q6GHbk4d9+S8Wozfqy39J0FP9gL688t8Ri315tLM8pu6BtC9Q2uOQxn6+z5f/bJc2sS+v6sdYeB5H+e6sa29O9SvRtTeS7496brSTfPNOG59vD9BhuUbe5O13xHNOy7XhN11nPxWR68eJHreP12nU/gTV978B3zEN6YSuK38yIlYv+GH3l6Rzv6Az0X7Y4xHpoM7wXuKq/KM20XkiIh0cE9kPy5rjPkq+xOchTc2P2Jew/JeDL/G7nrgEj/ufBzwn8q/LoPcJ8sMKjrPSD2N/Iot3nyLe7YG0EN5Z/lOAd3/g4R3rdqiv9TlKw/EaMTDNQRvwHcsclrd8Q6Icj1cF/ZRgP8zwm66zzUXGq9AYp7XvS8XojfphXxb0VD+gH6Z8L8Ty+WF7KO1xSPtDSkN7xj4a6jf7YXucv00+P2xPBlaoH2b5v0l2A9tZ1m4YVu2vhflryXMG5OO0vD7WYxGxan9tjA6/q/21OHSK+Gv/Eslf+7/PGiv30wnw137WA/7af0Xy1x4D3rl0jh4SN9sDaY9TGvpR7K8hrxAD05wLi5th+QMtbrYH3u1vcbPHIY19MrRnHDfz+Wsx4mahMS6mmeXXXU7pln/xaWOYCyluhvX6BNDeXcfX9pv4mu+s4W6io840fsJDZ3cgnftL0rlf0Kn6DP1uolPVGXr21x6PSAd1s010JmqdM8vnOIXsm1rn9Pkclv9F4HOcRj7HHqCNdcTyof6a5X9WSmMi1jmzeHcm8W4PpOXx154FvDvHwzvWbRwb+Tx+vc759FOvc2b7a2oPnbKNsdY5P9mlTeyvYf0+mYEV6odZ/heR3dgDuGXtxp70u2+sKnm3SLC/ZvhN18m/IvL/aaLH7WN/bY+oC8/xkucMyMdpPr9QzRcfi4hV+2tjdPhdHn/t0xHpoM6wv1bVmZk20dkTkc4eyBPqr/0K+RyPQ1qIz2H5v3v6WLnXeGJEe5ymF7ovzfL/KtldHCfK2l3DYrvLvLszYy6PvEOblrUv7Q+Bd28g3qk75RRfP01pj0Man01BXvF+n7xzUrXn0DcXKXlHRLC/ZvjqTo8i49UTRI/1gv21gvOHUX9N+c2qH9BfQ54ifcPy+WufpDS0jZ+jNLRnj1PaHkgL8dewTSH+Wt4YVwU+0/RQGdxbPtPUX/xbmX6/dee27dt23n7O1p2bbr1y+7arzt96+y2n33D1pi0379y2ZfvpV19989ZbbsFKI6Fp8B7T8eE89v1D4j1iPNalMSwM2FkhF2AgVtkLMJQR9w1u/Pdk11lPu4BqUgAOKlpWvcpepoHCeSdhYfmsgEsW1l2EheV5cRGDRVxP5pcPJ8uAYr3eSPVSBtOw/rAL1msJK+uwX/Lvi12w3kRYahLOf092nfVkfvlwkn9f6lKvN1O9sjbfJP++3AXrlYSlNu8Y1le6YL2CsLA8lsW/J7vOejK/fDjJv692qdcdVK+vQNpXKQ3LvZfo5L3QF8vzoFlVsPu9ROerEel8FfK0oVzy99cgDW3rkHhnNGzw/zq8ryJgYvhNqktOeqOD/9eJHrePAyZ/JOrSEmk4rmIa0vkjQUdhPRYR62vUnqzDQX9FkzC8vFIFNXgSZvkfPX2s3HdpEoY8+iq1Ufkxnxb0GtSuAZEf8fop/w/SOiUHWp+THmhVOvJYRl1wzEyekAtwUb+q0BHDj3UB7teIHrePdeTroi4tkbYHvmfp4tcFHYX1eEQsvgQ6S0f+LZKO3HP6WLn/7EEd+Z8IOoI+VIiOlLlMAvGsPvgO8WPpiPJlfTryNVGXlkjjjfVKF78m6CisL0TECtWR6evH0yyqI685fazczBSzCh0xfofqiOWfl9apjI6g3xyiI2WCYYhn9cF3iB9LR9RFOz4d+YKoS0uk4ZwJ05COb3Ecsb4UEStUR1ZG0pHrTh8rt6YHdeSInDqi6l7F3EvFr94H37N45Ls47n2iPWqO9z5qT5aMnLhe1yfrogObv/MF8M8BGTnFIyO8UQXrvNuNr0veufTuQDrvL0nn/YJO1XP23USnqgXP9xOdz0ekg+NKm+h8ISIdtJWhF35cRHrwh5Cm9MDiRf2U/z9Gxspd7NGDrJglLqx+WrSD6V2e0ii58UgurBpWN949N9I48+cjY+Wen8OGoE/PNh758XlKwzGZ474qvorvWOawvOUbEuWMv9ZfGLesYmHV8Juus81FfK3Qg5/Wvq8Woze6sKrmEqofcGEVeYr0DYsXVtHO8mYltI1fojS0Z1+kNNRvXlj9dJc28Vqaqp9vg82gqHsVfrzhN12njhaRrW7+Ivvxnxd1UX3zFviOaUjHdzEnYn0yIpatMexNX+j+knTuF3T2F1+IN5kdKL7Qm3L4QsnD47nl/+WRsXJvnQBf6Ld6wBd6ZyRf6MUjY+XeVftCvmef8YW+UozeqC+k1rDz+EJqTXt/8IX6RP0wH+qeiic58a7hocc0Jomyb6V6Y9r1RCNvDOh6Ud8K47p9ofq1r8R1eQ29TCw2xOfZnw59XA/vIm2i7fP1w2MeegXX8iYZPd/eLqSX2NMB19mHWXvQ1N4t7K8snS+6n/LzXbB8+yl5HfALXbB4P2XWxmVM+5vUf0ns8J+sH5/niTTPtyDPN9PvakM/+lN/RfkMy/ImT8kLPYJ1z/CbVJeiuqf6AduHsnmQ88sI9tEe+P44fP+caEuIzGKdQmQ2b5+qTeVJvu958u0R+RSt5O8PQZphsC/+fVhfuum28W3E8rw3+UNjpEf5he98hzMsn6KzuySd3YF07i9J535BZ0iUa2R8Gh1+x3QUb6o+6MaxgaoOurWJTlWxDo4NZB2i+m+a3+6BNN94wYfeGyNj5RrPfPq72qOfdagz9ACa5R9IaUzExXpZvBt85vi2FD2A9r1njpWb6uEd6/YeSOPDacgPPpyGYwNiYJqDNvgOoGH5A+0A2h54ty8eQFNjnbKNn6M0tGePUxrqN8cGPtGlTb4f3bWyyeGqQ9LvY4erzt96+2Vbtm+7esvObTfecPHWl9669Zad/YDM1LEVzmlLjFdDZT0N+nsSpX2I0jeJfPj4RtOSVxwEe7570u9N19kLRTRnD9Hj9vGs/3FRF3VVxdvgO6YhnccFHYX1aESs/7+9P4GzrKruxfFzuwYoKLrE4R+jRkpNfC9ijIIDTliIDC00ttAg4NQNtNDM0IACMc8hRBKj0SigyHCrqweGnqCZupumb3WDAg4xL/mpMT7zzDxofPIj8ZfE6P8d+qyq7/3e715nn3PPqapu7vl8+tO3zl57rbXXXmvttdcejulN7yrPzndMx7vKc0eFdHAU5UivVSGdFsCMEp3JCumgvsVGem+haAWP7cZEKwZ/DUQrb6VoBUcN5BFxY6R3v2gHX/FyDEV6JbNuMtLj1Xf0daPZ77SdCyJkhz4tJLtzQHbHk+yQNts2yon9C/Z3i8pQVvyJPpUNVKvzKiKYgV0L0ZHeTOxaUNeydHn1xVSkpyJL1Q8Y6aFM1Ulc7yrPDVSmrrFQ/oyvKJiEMo70Nua0yYv0eLzZIuhY2YNQtonKtos2p3Z31lva4dYB3BbCcR+UPUhlW6FsO+B/+YL2tqmrSJXtsl2jHreoTF0BYbLfCbywb0K8/QR/Efimj5G/UzqqMusGrzLYODvhmSzq8MMRuO53aKuZ08MObeSLd2rwDhFla8NAy8pMNvtm/+OYV8QHqs9n4oxpAPCG+knNGj1ZqX5SK2W8IqeuBPGuqVE+hv3PJJThTvaPBcZjbAeOx+Zv1DiPYzmP89ty8LI8vR1vqBfKN3inGdhvqBs0vOyO0vVJ4l1dtY7woavWP0PxWcmVGfeqddbv/kTrd+g60zXg2z4X8G0DBXFen+FJbfR4sNEkafcF1o9d+oJ+5QvQ3tkXeD44fYr6TbZb7BuOLWMzPWxngwIe8fFKzjj0AZ8UQn+0i3hXGWnv2kBv3pXK/WGKKVTGP4W7jXRPnc5RJ6r4dM5XQJ/vpHlEFX5jksrQD3AGX405Ss9UhhDHUK5nfqDLjGr0PIJ3u3S74hu726WKFe30X+yVtjiPyNvxYL5qpv0ayinGryG8+Ra1k43tGX0E+wH0Eew/Wg69SaiHsfjDETGL2jGi8joYs7yF7B/ti+0fbZztH/W9RWXq+mkeN0K78nDMRvhvgA/7AclG6bIXx6qdP7hrh1fAvFPBCtdDDm21m/YrDm21m5Z5SZKwTSpbNNnUMd/AuIBtUfWT2mnnyUr10wjBo2yK2u4jVNaCMrbrSSh7GNr8g8C4je1Q+Q0VD+CYf9sMr/aGxm6VA0a8HPv+M9juz0k2yj+34F3RuJPnTGq+7uHa4dD29FfRRr6wLtNmPvETBEbLylrZ7zpst8r5gZKV6id1aoBtMHblme0zduUZx92fB3ZpYDtix13c4cG7PyYFXk/31E4LtGPWvZZon7J/L7fmfXKC/YY6jcd2hrqK8JwrMPjhsd3/d7njV+YK+JQL5jOUfoc+Vffisd3/p308MqZxDhTE+cwMT16uwPqxjpga7Z19geeD06eo32S7xb5pEa6WwIUy5VyByWgw0TlLw9dP8L8ytvt/lStAf8R5zdidMC0qU7vxUrmPje3+rfY7jALcr44lbe1WeX2rmz6sewZ/5Nh0vf+W/a7Sb3DeUuWM2H6SxNezEVEfx1CuZ36gy7l0dK6Ad4eXzE24u8PVfKeKW8/Sf7Gfl8ZcQd6JCC9XMAn8I2wVfs1bD8mTK8/dsY0tKkMfwX4AfQT7j20OPZULQx/h+cjYmKUFeH9OJ0/Rvrx1MbZ/1Hdvbs1xgzp5PAkwOGYj/NvHpuu9d6wdp9JlL47Nm69PUnvUfN3D5eUp1AnTRx3ayBfWZdohm1S2aLKpY76BcQHbopejSZ8YWal+GiF4lE1R2+UbFtXpMGW7mANj/fTi/PRh250UvGI8MFOnxnlu/RjwwuvwPA4g/Nlj0/WuGmvHqW4X93RCnZjGU9Dsp0I3x4RwbXNof03Af9WhjXxhXabNfFo9ZbsmmzpsF+2NbVf1E8LHyEr1k7ox9KtUFnuC/TEqiz3B/ii0mfVTrf9j3p5tV+2RU7dIKF/o6V7emMW6p8YsZf/sN9D+2W+gjrLfwL5lv8E3EzA85woM/tqx3f93eRu2zBV8jXh8HHhQ+s1zK4O/ZWz3/2kff3JM4xwoiPPTGZ68XIH1Yx0xNdo7+wLPB6dPUb/JdqtuPG7Q34gLZcq5ApPRoIBHfP0E/8Wx3f+rXAH6o8eJ99gbNTjOQJvBXMGDY7t/DyedtjsKcM2x9najT2N/kT6sewa/Y2y63kT2u0q/8QiVoR/g2FqNOUrP1FoRjqFcz/xAlzfaRecKDP9Q0tnmMrmC2FtjqviKQPpP3ZCv+gFzBeqWPsTl5Qrq9Gsopxi/pm6uGUk628j2jD6C/QD6CPYfDzv00EdgLG4+wvORsTELzs//kHIFaF9s/2jjbP+o7xw3oAw5bvga8KJiHhyzEf7LY9P1/nysHafSZS+O/YaAxy9AfIXag7r+jQhcjzq0/1jAf8OhjXxhXaYdsklliyabOuYbGBewLap+Ul8c8GSl+mmE4FE2RW2Xv1iC4zvbNer2V6HNrJ9enJ8+bLvqK2AYD+xpuYK/Hpuu929j7TiVf/ZyBUXn6+jDvhaBy5uvefqraCNfWJdpM59Wby7lClQ/eT5WyUr100jSaddsgzOZK2D9rCpXcNpeniuIGfNRVxGecwVT8Efs/r/Lr8vJXMHXiUfMZ8TM6w3+eRmPaR/vc4TGGZsrMPj9MjyzmStAe2df4Png9CnqN9lusW9mK1fwHOgDL1fAec2qcwWHZXzk5QpeQLpXNlfwRtDng7LfdeYK0A9wrkCNOUrPVK4Ax1CuZ36gy7l0dK7A8A8lnW0ukyuIvW2/S785lStQcxzVD5grUHMRxDUXcwV5cuW5u8ppFp1vsP8okys4jGy/qlzBOyrKFaC+c9yAMuS44evAi4p5cMxG+LeCDzuZZKN02Ytjq5ive7i8XME3BfwfO7SRL6zLtEM2OdO5AowL2Ba9HE36xMhK9dMIwaNsitoufwEYx3e2a9RtzIGdHBi3sR1lcgUcD+Tdf8Fxk9pj5c1P8vaOenuNvkxlaq8+00GfgH1yTfab9xotyeSRF1Mb7S71fX7d+2jy5oN8dgZ9N+95QRnjeSQeG/CMy+ucrx3wngy1P1TNk1n3BgPwvJ/M4C+CPraY3dNn7/xXUX1WX7stq89oG/wlP4O/Ymb1+YDZ1mfWWdRnzgkpfW4knT6sm3zOr81B/f/dp5H+f2qO67+aS3j6n5cjYf1XXyyfSf2fX0D/v+bQVPpvbQvpP+YTEf5mR/+VfD39z1sj9PT/G1SG9R4I0EH9x35n/Tf4VZH6b7Tr0H+UEeu/N29Kn6JzHV4TwPjd039er61K/3/65t2/Y/Tfi72V/ltbQ/pv+Dhffo+j/8oGvXOMRde6sA1fpzKs90CATiieZ/03+G2R+m+069D/KueveXkGjufRNjz953WOqvT/f5P+4xn3bs+xe3dXWDvUmU1st+HlM5tfPwLacEQ7ThUjTcK7Os6Ze7g8+8y7G4NpI198HwWfeVf3x9R4/mug7nOtSlaqn0YIHmWjzpXwGffYcyXeXXm7oM2sn1Wdcb/2ze14d+bgZXnuEvDeHTSTon11nGNXut4i3vkOJIYPfbXyX7K+qPOrlazfuBaN+s1rd1Pwb939f9rHPwn4toGCOJ/M8OSNsxXdVdNf9101eX6T7VadTWvQ34hLrd+wnQ0meq5r+Pis9y+gD3gtGv3RI8S7uq9J+aNJKmtBGa5FvzjTLz6jm/4eBbjBt7a3G30a+4v0Cd3F+Gugz0PZ7yr9RovK0A8gDtYpT89GRH0cQ7me+YEuz4BHr0Ub/qGks81l1qJj76fr0m9OrUWrPKHqB1yLVmdoEZe3Fl2nX0M5xfg1hOe1YWzjJJXF3r3D/sO7f68F9TAWfzHZ/qRoxw6Bd5jKsG6K97dpvoH21e05drVnrpW0t+MrwIuKeXDMRviXgw97C8lG6bIXx+adM+f7g9Q5cw/XLoe2d1ZU0VbndpiXJAnbpLJFk00d8w2MC9gW89ZkY2Sl+mmE4FE2RW2X17fVOXZlu5h/f0tg3MZ2qHs2VDyAY/4gjd0tgPPGbm/+PEllaNfIB7eRfRDi5Zh/Adjue0g2Vd9PwXOmovdTtBzaeX6Daffup2iHV/0Ucz+F+tqpt0bj3Vep7k7COR3rZyvpbEfsuNsCvG+jXIFay2zBu6L3QHr31fJeUazHfsPLu6nYSOk6+w2ODxmecwUGf27WFxZ/oo4U0HWZK+BxHM/cKP3muZXBfwR82wUB3zZQEOfFGZ68XEFF43h/3eN4nt9ku8W+4fmjGktRppwrMBkNJjpPYfg4v3019IGXK+B4Af0RxwuTgq7yR5gruIVyBWi7owD3MdK9snmqcdDnayjeqMJveLE14mCd8vRM7Q3EMZTrmR8wv4K6WEeuwPAPJZ1tLpMriJ27d+k3p3IFKg5X/YC5ApSpur/HyxXU6de8HGieXHnujm1ke/byiegj2H9MOvTQR2AsfkvEfCM2ZsH5xhsoV+DtW/LWzFTuV81vOW5Q52TVWUQ+J3sb+LBtJJuq79TiffhF79Tycuze+TBFu3enVju86qeYO7VibZdzDJNQxnaNuo37y7cFxm1sh1oLUfEAjvkfc3IFG5P2sqL5AGXzHKep2Fd9d4Bj30fAdr9Tc54vZr7u4Wo5tPPyfEy7l+drh1f9FJPn2whlLSqbhDLPPtnmUbdx3P1OTbmC/3pTO17lE1rwruh+Gta92DMk7DeK5gOUrrPfsP5EXUV4zhUY/N9RrqDkPVIyV/A48Yj5DKXfoTPBPwPf9o8B3zZQEOcPI3MFFe3fLnwW1PPB6VPUb7LdqjG+QX8jLnUGjO1sMNE5y9B5gZ86uQL0R5zXnIQyzoHsFHSVP8JcwfOO3P2b5zrp71GA+znpnsrro89h3TP4Xzlyul4j+12l39hFZSpn5I05Ss/UOi+OoVzP/ECXc+noXIHhH0o621wmV6DsT813uvSbU7mC2Pv3MFeg5iKIy8sV1OnXvPWQPLny3F3d+aJ8hLeGwf5jp0MPfQTG4uYjPB8ZG7PgfoX/N4tZlI2z/RfNB6i5NccN6j5Z9EE4ZiP8r4IPex3JRumyF8fmzdd5HUbN1z1c3Zx7YtpF7tRSNlnjfRNyvlHlnbt5d2px/O/dqRVru3znncoHKNvFHBjrZ96eTbbdRwSvGA/sabmCI8B2F5NsermCTj57uYL2spnMFbB+tpLOdpTJFWzp5QoK5wrOyPpiLucKPgS+bVnAtxXNFZyT4enlCmYvV7AC+mA2cwXXR+YKrgrEHEVzBV8Eff5wL1fgPb1cAdHr5QpmJ1dwfU25go17aK6gCT5scy9X0EE7ZJO9XEEx260iV7C5plzBVTR2o42z7SJvLSqr8gyCd6eTwW8H2/0myabqMwgxd4h7uLz7CvLyFEy7dwahHV71U8wZBLRdzjG0oKyKMwisn+q+gti7RvC+gssoV5A3nhc9g+CdQfLOILDfQPtvUdlMn0H4PuUKSsb0tZ5BeBJ82w8Cvq3oGYS/icwV9M4gdMq0qjMIP47MFXCeowVlVZxBeObbdv/OO4Pwb6R76NPYX6RP6AzCc942Xe/fKd6owm/0ziD0ziA8hTz7f289g4A+gv1AC8qqOINgPsLzkbExyy7Aey7lCmJzhS0qm+kzCC8AH/abJJveGYSwTfbOIBSz3SrOILB+enF++sSeQfi3kvOYBvGL8JPwjuWvfI53v1ELynj9AOttDNAJ7Vf4dPa7n+DfkMk5L6au6K6cfYvelaPmg14eJG8+yPNkFZ8pfTeaefPZE2k+q/Tlfof/PH0pe/9eC/g33ElSad/uM5f7dpLKWlDGc6lJQafMvUZvoTihAXDnEM2GoInvOKbn+goX9uOh8PsQKEf4czNfYLEqyr+AHiwchjoJ4EDcJXVsIbbVHjW3wDha0UufIVHWH8HLrsNax638z0MPaFB944XfsR4PCPhzBLzJapB4H02inuOUrRttK+O2Yxnaq/GQ2vjLiL+BkvzFyA/xjwj4RQBXpC8OTNp1AfVdrSPE3F9cxzrCJoAJrSNcAnH971DcVPU6wiZqz0yuIzDt3jpCO7zqp5h1BLxPrO51BNZPFX9vgnc81m4SvKZ4n1vzOgLrXuw6Qsz9xbO1jvBHNN7PxXWE28C3XRfwbUXXEb4QOefprSN0yrSqdYQJ6ANeR0B/VPc6wpcj1xHuCOQjiq4jPAb6vD77XaXf6K0j9NYRnkKe/b+3riPE3oFaxTrClyPWEWJjFszTzXfWEWLuL56tdYRvgg/76946QgftkE321hGK2W4V6wh/HRi3sR1l1hHuKDmPaRC/CN+Cd0Xzwjw/QVl5eeGHAnSKriP8S28dYapskspQxryOEJrP/tsb2/lpCX68dYRJAd8CGNYXlcNWa1IPAf+GOyG4OtYRsD3ct1WvyXHuBOdI3O/qWytFfUKeLvz1G/PxerrQEvBebhP5aFEZ1tsA/Btu5r9LXRhUutACANYFT+/Th2Xj6Q7KRo0zrCcboKxFdDYJOuobHMNJp15tgrY+lOmC9ceDAHc/0XxQ0MR3PL/D+gan6Czsks5CQYdxYZ5oA+DiebXBv/ao3f/b/Gg74C2gb2ez/A0H4t5REneD8CWJns8afrW+aHwNibKYtav+r0xMbj33yUWeL/HypC0Bv1DAm6wmoX4BWZ3hjS9q7WoHlaFfMB7U2lWrJH8x8kP8IwL+SIAr0hcK1+KKcLEf6xbXppK4bH0O/eB2wqV8qtq7M1+0i/l6MAfXiYQL67MP256DazHhelC0sS/pbDPChc4aIe3hpLNt7MtK+sn+WF9m+IdEG8rk5pRs1VijxlGrq2I31nn1XWf1TXGFa1OFuDZSezZCvUbgf6PD73h9G/mcIJ6VbW1yeMb6HBdtFHSsPVugbDT7ner2O4/S/KDebwF+OC4w+He+c7re4qPa24+0ed8u8jyetPOCfdAn3rFsxiPprO6SzmpBp0q9Uf05TnS2V0gHfdNqovNQhXTQ3kaJzo4K6eC4eCjR2SR4SHV2OdlBC8qUXZ6U/d9P8E8smq53vmMHyCPWx1hri2gH07uE4vFJqFPA78u1ZcOVJ7sVJLstUKZkxz7E4P8fkN0VBXxIC8q2UxnKg+ffat9mg8qSpDN3kT6sc1jf4IZFPZOv9dcueF/Hmp3hH0o621wmLlA5nRa843nJw+XoTa3Zqfyg6gdcs0OZqryy2Zjys1uoDH3jTirzvv+L9n0I/EYaoTZxPK34Gxa4WLdmOubcUo6eG3Ni+8rGnEfDbyxDOkXjxCpw8ZmE2YiFVnZJZ6Wgs7fEQiuJztMlFrq9YCzE47nBXwHj+boZiIXumgOx0OaKYqHTQHb3keyQNts2yoljoRaUcSyEskIcWJYk/rrPiKjPcsN6Jl/rr5KxSXQsZPiHkq70Y2q8UjGiGq+6jPWmYiG1tqr6AWMhlKmKi7xYiPML6BsnqQz9WYvKvFhoU06bvFhoE7Qh/du+5fxWsJ2vZbYzLOidkrSXod7em0zj+GOyv1CuEMuwPfiObUXlJKsc14xn7J8J4rloDIP1ed1uu6Bj7cFvbY9mv1P5fvcozQ/6zG3AD/tMg38l9Pv/oj5Tclb9OZ6081K0P8cj6azuks5qQafueGic6NQVD3EOqq54aJTotCqk0wIYjrtCdvAE2cEklCk74ByUwf/JO6br/atjB61E08O460HRDqb3HxR3lRzHZdzFuZSQ7H5GsnsQymJ8iMHfA7L7RQEfMgllXp7J+1Y34sCyJPH3Unn78tWeLZNvlzma6LjL8A8lnW0uE3fFxkHWvkfK0ZuKu9T9iaofMO5SeSfExXGXiim8fW3Kn3F+qgVlHHdtz2kTx11F45R9Be915KB4n0bJnNeUbqlYSI3D3p4R1Tecg+pmrf/BCnFxDgrXuMeJzv2Czv0OnfFIOiu7pLNS0BkW9RqB/40Ov/P2bY0TnQcrpIP9u7fnoELj+SFHT79HXxY7nhv8yTCevybDqeLxmBzUdtEOpveGjMZM5KBCsnsTyW47lMXIzuAPA9m9xZGdd7cO729EefTW43rrcU8hz/5XfpbXddA3VrUe92BOmzgWUvt3GVc/vFM5J553nJrZV2prp2S/lZ0b7RTu+wTXi8Pa66q+/334jWVIJzZ2eqBCXL04bJoOvysSh9UVH3EctrflpB4UPKQ+5oMUS0xCWR/VTR+OJQz+z0+YrneVE0u0Ek0vNg4z+P9BcVidOamQ7D4aEYd5sjP4B0F2v1MgDpuEsl5Oqr0Pezmp6d+hnJQXh82FnJTij3HFxmEGfxP5jZJxk/QbeKaT28v634vXdj9HAhyXFY2xtlSIqxevTdPhd714rRo6LYCJjde2VRSvvRdijodmIF7bNQfitUcqitfGQHaPkuzUOWIlV29/FsdrKCseB4vmzdR+56dL3kyNV3tq3sxbQ+SYTN1JEROvVZE3i81xMc1QXPcuKjf4v4b82g8ob4Z8bQPay49ph+vFa+1196T8mvXrfIF7nOg8IOg84NAZFzwrOiu7pLNS0BkW9RqB/40Ov2M6SjZsp1XQQZvf29c5QzHHvGOm36O/jY05DP4HC6frDWQ461zn3C+jMRPrnCHZDZPsysZrD4PsRhzZsW23oIz9C8qjt87ZW+d8Cnn2v/KznF9D31jVOue2nDZxvIb8bQvgio3DDP6/kd8oGcdIv8H70pAf1v9t5ehGx2uGf4h4Kav/qu/UPREcq2JdnuOlz5EAx2VeXKjmi1sqxOXFUeNEpxevTcOME50tFdLB/uV4ra64cJTo1HW2ITZeO5piDnVWxYs5DH4ZxBwLKOZQe22ZXuwefYM/gfxuybvVpN/le9RCZyMXkezUHn3vbKTBHwuyO4lkh7TZtlFOW6gMx1SO5arce4v1Q/fPWXn6dHl/WnS81sp+q/vuyoxXLaLHdsHx2mQ5elPxmoqbVT9gvNYCmkjfcHnxGp+NVOeZlT/zzstxvPZATps4XlO6r3JceMcT57jUuLSvaGOBPpofq4OGfyjplHcZHVT3bKjxev//++/Xst+XX7b8/OWXXXnMsssWXX7G+cvPPG7ZlSuOuPCsRUsvvWz50vOPOOusS5etWIFMI6ED4D2W48Mw9nuDeI84tuU0hpUBO4uD9wdzcPElfFg/5sAr4oq5hI//Hkg6+czOdj7VaXl40NBCfJ1EfKnFF8/Jo3JeS7jUh548x4i4PkW41CWX/PdA0skny8vDE3KgyNenia9JKNtJuHbl4PoY4cL6uwjXwzm4/pBwqUk4/z2QdPLJ8vLwpP8eyeHrM8RXaPNN+u/LObiuJlxq847h+koOrqsIl/pgG/89kHTyyfLy8KT/Hs3h6xriCz+28SiVYb3biU7RSRrWn6lJ2u1E59EK6eCHSEahXvo3fiwDfat3iMkGf/wIRR0JE8Nf1QWm6sMb3gWmXxW8jIgyTnKoj6F8VdBRuLZViOsxak9oEnYbTcLKXlDzKpiE3UmTMJQRf6xSxTHqgtEGtWtQwCM+/njOpown9eGzR0V9hRvHUy/RUcUHqhCf8YPvEP9Q0qk/ZWxEfdAO28c28rjgZUSUcdJC2eLjgo7C9VCFuPjyvJCN7KjIRp4HNrJzDtrIVyqwEYyhYmyk5MJTtI3wwlO3NqJiWc9G1EcfR0TZJPwO2aL6UJTCtbNCXLE28q2KbKQPbOTPa7QRk3esjRj89yuwEYybY2wEdaMOGzH8VdnIJNHLs5GdgpcRUYZzJixDOt7iOOJ6pEJcsTbyo4ps5IfHT9f7P3PQRv61oI0o3uuYe6n81R3wOyQjpbsjoj4vrD4g6OTpyC+O0fwoHUl/2/ydF9a/Czoy79j29is5z+bC6p1d0rlT0NlbNsLdSXQmK6QzCTCjRGdnhXTQV8ZeOvtLx06/T//tgjJlB5Yv4g8kXg128DzHDkI5y9hLZw3+oIxGlxuP5MKq4cqT3YtIdmXHmfeB7H61gA/BmJ59PMpjkspwTOa8r8qv4jvWOaxvcMOinsnX+gvzlnUsrBr+oaSzzWVirdiDn11+FHxqYVXNJVQ/4MIqylR9QNtbWOUL+NE3PkJlk1DGH8ZF+465gB/b5G2EK3IB/0xvMuv2Av68eJHj+EnBi+qbz8JvLEM6k4KOwvVAhbhsjaG3yazz3Vw8FDBZIR3Ug1GiM9ux0LsKxELpw+O5wf/iuOl6p89ALPT+ORALLa0oFvorkN1ZvVjIe/aYWOgr5ehNxUJqDbtILKTWtPeGWKhP8IdwaHsqn5SIdw2HHtOYJ+r+EfGNZecRjaI5oPMEvzXmdfti7cvwz/W8Lq+hd5OLjYl5utzAGB2Pz8QGxvPgXUWbaPu8ftjm0NtVjt48o+ft7UJ6qT8dTDr7ENsb2kP2MOC3dyGbL7ufcjIHl7efcpJw7czBxfsplQw4P39HFr+kfvjGY9thWhnMLQBzU/abbQrl8NReEoIzXAabPl1e6BFte4Z/iHgpa3uqH1rwDnVzn8TXEeyj0D5TdWlWjM624F2MzhbtU7WpPIVb58BtF3CKVvr3BijjD/oY7MYMRyrni69obyPW573JG6ZJT8kL33mHMwxO0Rnvks54JJ2VXdJZKegMi3qNwP9Gh98xHSUb7xBmWTqoY5wbqOug2yjRqSvXwbmBBwQPqc18mea36tC7Gi/40PvHYX77GM1v0Q54rMOL9RIBf2iA3jcoN1DnxXoh2X2TZKcOoHmyM/gPgOz+1JEd2zb6/k1UhvLgw2k4NvDeuqIH0NRlEE+XA2jeBU+T5ejN6AE0NdYp38gH0NCf8QE0tO+Yj/N5B9DUWJ4ernph9nv6cNVxy648Zen5y89aetnyiy48cdklly9bcVk/YGbq2Iok0Z4Yr4YKPQ36ex6VbaDyRQIOH280na3PMG8oR8/9DLOKMviqHqyrrqr4HPzGMqRT9NPJVeDiT1T0rvIM05kLn8Cp6wqAUaJT1xVUsZHePgum36M/jI1WDH4fiFb2y3CqI8O80/4BwJcIeI70DH4ko9Fl1k1Gerz6jr5uNPudtvPACNmhTwvJ7p/ePl3v2SQ7pM22jXJi/6Ku/VEzdsSBZUnir86riGAGdi1ER3ozsWtBXY3T5dUXU5FeS9BT/YCRHspUncT1rvLcQGXqGgvvCh3lg2IiPWxTTKRnurVO0LGy+6BsI5VtFW1O7e7lZHcbAe5MaoeVYTvwHdvImYIfReeu7Hc/tfEo8nUlr3l68zDRMRyI+/6SuGPtMhQ3IF9Doqw/gpefPmvsN55o/uRLDapvvPC7eYAfdRnhzxTwXY45bxgGGgnRtjIcD++nsgEoMx7SrOXLiL+SK0NviJGfsn0sOxp+F+kLhWtjSVwHJu16hbZj9od+5O7s93DSadNsJyVtMHq+ZfiHkk4ZlBm/lO9VPot9BNYdEWV8Fe9dgs5dgo7Cta5CXDYGqH4eJzrrBJ11Dp1xwbOis7JLOisFnWFRrxH43+jwO6ajZDPTmfW7KqSDejBKdO6ukM7dAMPzrdCcYRnNGfAa8pg5g8F/EuYM5zixC/KI9XF82SjawfQuoBik5Ngi51u8uyIku4tIdhuhLEZ2Bn8hyO5SR3Zs2+p6KzXfuovKME7gnFLR+RbWf7rNt9QYb+0reZPH1HxL5SOLzLfUTVE830I/u5HK1Dxa+TOOudC+eb61MadNPN9S/PViobhYKH2OBDguKxq/3FshLi9GGSc6vVhoGmac6PRioTCdMrHQ6opioREYz2+bgVho/RyIhTZWFAs9sWC63t1O7pltG+XEsZDK6ag4ief1RU8lYf0Z2KEbHQvNxA5dNV5VcSIw/Zd3c6eKhUK7Enm9XPlZzj2r3YDKn91PZV4stCGnTV4sxOvumDdm2PXQXoR9DOzsxwvCtDYTH+uh7B4qi7VPxIHyRV+B8JdRGwz+mxnfaa5xxRUa57xE66j5H5X7tHbsC3StrID+TqZ8vfuKaTqoL+mDeVPUlyTxYyqD3yzgUec4NtwMZRzPKX3E+ML0UcnLeKxDXshDjLzUGlisvNjuUV73ES4V/6IMPXkZj3XIC3mIkZfa4xIrL5OBktdWwpU3x1lA8IZ7MNE+gXdNG/wPwSfwrTyej18vcKNvbBAObMe5oh3DVIZ1U7zvO2z375nK83CsqW7cQf+N+yAQ/t9h3Bh+eztONU5761sqx+HtJMVxfHsEro0Obe9TgIo28sV7ZHhvjoo3lB8w2XTpBwaUH8B8FfsB1U/qxJMnK9VPas2d98bF5pz4ZoXYnBOetGD9VPmnkM9me8D5DM911DzB0z3vin6leyrHquyf/YbaV6Nsif0G9i37jbI74Z+X9UWdO+FZv/sTrd+hHe6vhHn7rwR820BBnKMZntRGjwcbTRK93t6lL+hXvgDtnX2B54PTp6jfZLv19q+qdXOUKccEJqNBAY/4eG/ewdAHXkzg7S73cuDevM/sIZX7CRkfeXsgDyHdU7c5eHsgDf6doM+vyX5X6TfupjK1R8sbc5Seqd37/Nlk78b2kvvOo3MpvO+82xvbY9d5qvjkcvpPnZxR/YC5lLzTm+arZtqvoZxi/Jpaa1J7CNme0UewH1B7XtVaDNNDH4Gx+Alk+8pHxsYsmL9eTTketC+2f7Rxtn/Ud44bUIYcN6hPxqEP4k+cG/yp4MPOI9koXfbi2JaAV5/eVqfTWhG4tji0JwV8y6GtPk/PvCRJ2CaVLZps6phvYFzAtqj6SZ1T8WSl+kndAtOisljb5RNiOL6zXaNu40nU8wLjNrZD5XjzTqcfQmP3npIruBxs99perqCDNvPZyxW0l81kruDamnIFF/VyBYVzBdfvAbmCdeDbvlhRruCmXq5gqmy2cgVr50iu4PHIXMGGinIFXwd9vquXK/CeXq6A6PVyBbOTK3i8plzBsj00V/Bn4MP+vpcr6KAdsslerqCY7VaRK/j7mnIFG2jsRr75vL6yKWXzfF5ffdqd+y+UKzC8/QT/E7Dd/uPacbaS6UfJpqj98JxJ2Y+Hy9tjtFPATzq0W1CGdZUtqzP0NY6j0nbRPtl2W1DWJ+BjZNUCGM4V7ISySSpTeS8rw3GIb4nCcYhtHnUbx13WT7W3KXbcxb1GfH/Hlhy8LE/vSxZq3FA5FO+MmLJ/9hvq1jal6+w3rD9RVxGecwUG/8ysL7q8cVXmCnYSjy3gQek3z60M/r/DXTTPCfi2gYI4n5vhycsVWD/WEVO3AIB9wSSU9Qn4on6T7Rb7hu+Mib3Bje1sMNExROiG1pdAH3CuAP1Ri3hXN00qf8R+TN2nlMr96IwPnuukv0cB7mWkeyqvr76UyHn9BaDPv5H9rtJvPERlLSjjmzmtLEl8PRsR9Q1O6bP5gS5vSozOFRj+qm5yniR62Pb04VxBNzdVp/92CXotQQ9zBShTdZO5lyuo06956yF5cuW5O7aR7Rl9BPsB9BEtKtvu0FPzO/QRno+MnW9gzLIP5QpUjlXZONt/C8o4bkAZctywE3hRMY/h7Sf4ReDDziTZKF324tiHBfwugOF1GNT1hyNweXmKRwT8ww5t5AvrMu2QTSpbNNnUMd/AuIBtUfUTwsfISvXTCMGjbIra7k4qw/G9RWWo25PJdJvPDIzb2A6Vr1TxAI75L6Oxu+5bnENjdyjPZ3g59r0AbPcjJBuTW5J0rjmlT9G4k+dMLSjbGYHLWx/z9FfRRr6wLtNmPq2esl2TTR2220IAwBvqJ4SPkZXqp5Gk067ZBnH+7a3jtags9kZpHHdZP/POsnrjLq4r863u3r6L9GF5enlWpXvqBnVl/15ujf1GC8rYb2Dfst/gm8IZnnMFBv9pyhWgjhTQdZkr2EU8TgIPSr95bmXwq8C3fTbg2wYK4vx8ZK7A+rGOmHoSANgXeD44fYr6zVb2W/mCmL1gLXjHuQKT0WCic5a45wXhb3VyBeiPJon32Bvuee+U+spGKvedlCtA2x0FuDWkeyqvjz6Hdc/gHwF9vp3ijSr8Buct0Q8gDtYpT89GRH2DU/psfqDLuXR0rsDwDyWdbS6TK1D2p+Y7XfrNqVyBmuOofsBcgZqLIC4vV1CnX/PWQ/LkynN3bCPbM/oI9gPoI9h/ePsYVC4MfYTnI2NjFlzz/DJ9NQbty1sXY/tHfffm1hw37AJeVMxjePkLv18DH/aXJBulyy14V3S+zrlPNV/3cHl5CvXl2Ecc2sgX1mXaIZtUttjKftcx38C4gG3Ry9GkT4ysVD+NEDzKpqjt7qIy9dVHZbuYA/vLwLiN7cBxm203lD9c4+T56/gaNM+tvwy88Do8jwMI/49guz8j2diXiZMkTiceFfD4dWP2U6gTj0bg8vYEPSbgH3VoI19Yl2kzn1ZP2a7Jpg7bRXtj21X9hPAxslL9NELwKBsri/0y9ZepbBLKvC9TPwJtZv1U6/+hO3nYHnBPEH8dXvlCT/fyxizWPTVmKftnv4H2z34DdZT9BvYt+w3+4jjDc67A4Pc7fvf/Fn+ijhTQdZkreIx4/ArwoPSb51YGP5rxmPbxAcdrnAMFcT4jw5OXK7B+rCOmRntnX+D54PQp6jfZbrFvOKej8g4oU84VmIwGBTzi6yf450MfcK4A/dFXiHf0RxyDTAq6yh9hruDwjI/hpNN2RwHuxaR76NPYX6QP657BHwH6/GvZ7yr9xk4qQz/AsbUac5SeqbUiHEO5nvkB8yuoi3XkCgz/UNLZ5jK5AmV/OD5wrqCk35zKFTwu6Kl+wFwByhTpGy4vV1CnX0M5xfg1hOe5O7aR7Rl9BPsB9BHsPyYdeugjMBY/nGxf+cjYmAXn5++iXAHaF9s/2jjbP+r7JJWhDDlueAx4UTEPjtkIfyz4sHeTbJQue3HsVwX84wDzMLUHdf2rEbgecWh/TcB/1aGNfGFdph2ySWWLJps65hsYF7Atqn5C+BhZqX4aIXiUTVHbfYzKJqGM7Rp1+1Fo87sD4za2A8dttt2HBa8YD+xpuYJlYLsfItko/+zlCorO19GHPRaBy5uvefqraCNfWJdpM59Wby7lClQ/eT5WyUr100jSaddsgzOZK2D9rCpX8KK9PFcQM+ajriI85woM/ncpV4A6UkDXZa7gceIR8xkx83qDvwl82+8FfFtsrsDg/2AO5ArQ3tkXeD44fYr6TbZb7JvZyhXcEJkr4Lxm1bmCrZG5glsqyhVsB30en4FcAfoBzhWoMUfpmcoV4BjK9cwPdDmXjs4VGP6hpLPNZXIFyv68XEFJvzmVK1BzHNUPmCtQcxHENRdzBXly5bm7ymkWnW+w/5h06IVyBVtryhX8UkW5AtT3SSpDGXLc8DjwomIeHLMR/mHwYd8m2Shd9uLYKubrHi4vV/B1Af81hzbyhXWZdsgmZzpXgHEB26KXo0mfGFmpfhoheJRNUdt9nMomoYztGnUbc2DfrilXwPFA3nftOW5Se6y8+YnyOeosqbfnXu01eiBAB30C9sk12W/ea/RXkTG10e5S3+fXvY8mbz7IZ2fQd09SGcrYaKqxAc+4/OKYrKFJu26wv0d6yKuaJ7PuDQbgDR/vQ/+JiNk9ffbOfxXVZ2xDt/qMtnEVtdXg/7+Z1ecDZlufWWdRnzknpPS5kXT6sG7yOT+ag/q/78Ld/z8d9H8E2joX9V/NJTz9z8uRsP5j/DYb+v+tAvr/mENT6b+1LaT/mE9E+IMc/Vfy9fQ/b43Q0/+vUhnWeyBAB/Uf+5313+BfGqn/RrsO/UcZsf5786b0KTrX4TUBjN89/ef12qr0f0cB/fdib6X/1taQ/hs+zpe/1tF/ZYPeOcaia13YhsepDOs9EKATiudZ/w3+zZH6b7Tr0P8q5695eQaO59E2PP3ndY6q9P820n884+7d4Rhzjt27u8LaMQm8KBvBe1ER/h0Lp+udsbAdp4qRvDsSq5jzerg8+/Tia0Vb3Y3BvCSCT6tX4/mvgbrPtSpZqX4aIXiUjbItPuMee67EuyuvlUy3mfVTnXGPtV08477omHa8O3LwsjxbAt67g0bd4ars37sTIuYcu9J19hu43pcIeF6LNviLs76w9Q3UkQK6LteiHyYe8Ry+0m9euzP43wXftiLg2wYK4rwicpyt6K6a/rrvqsnzm2y36mxag/5GXChTzqmajAYTPdfle1kM/qMirlP+iO/jUPc1KX/EZ+7QZnAtelXGB5/RTX+PAty1pHstKGN/kT6huxjXgj5/Mvtdpd/g+7DUXQfemKP0bETUxzGU65kf6PIMePRatOEfSjrbXIBew7O/FrzjteiSfnNqLVrlCVU/4Fo0ylStl3hr0XX6tRYAxPg1hOe1YWwj2zP6iBaVoY9g/+Hdv4c+YhLasIpsP+/+HI5Z1DeeUrxH03yjBXDefU4x59jVnjmOGx4GXlTMg2M2wm8AHzZJslG6PAnvip4z5/uD1DlzD1fLoa3O7XzZoa3O7TAvSRK2SWWLJps65hsYF7At5q3JxshK9dMIwaNsitour2+rc+zKdjH/PhkYt7Ed6p4NFQ+0AO+1NHYjfW/s9u6g4TsV0K75fhq1xoB+xvByzP9VsN3vk2xUHNmCd0XXt3jOhL7okQhc3l18eX6DaSu/wbwkSXhs3Zvvp+A5v3c/hbqvRdkn5xjU3Snq7iSc07F+5n1TzBt38W6ZYcoVTAq83dwD6d1Xy3tFsR77jdhx3buLhf0Gx4cMz7kCg/8h5QpQRwrouswV8DiOZ26UfvPcyuDnnbD7/7SPfxzwbQMFcT4RmSuwfqwjpq5yHM/zm2y32DctwtUSuFCmnCswGQ0mOk9h+Di//V+RuYIi8YLK3yl/hLmC0Uy/OJ+b/h4FuP4T2ttdNk/1EtDnfbLfVfoNL7ZGHKxTnp6pvYE4hnI98wPmV1AX68gVGP6hpLPNZXIFsXP3Lv3mVK5AxeGqHzBXgDJV9/d4uYJJ4B9hq/BrXg40T648d8c2tqjMyyeij2D/8ZBDD30ExuKjZPutpLMdsTFLC/DOo1yB2n9U9Jwsxw1qPsfjRmhPU+ic7MvAh72ZZFP1nVqT1J6id2p5Ofa8M7pMu3enVju86qeid2p5tss5Bhzf2a5Rt3F/+ZsD4za2YxLese1OCl4xHlC5Av7uBeKIyQcom28l7e1Qsa/67gDHvseA7Z5Osqk6zxczX/dwefO1vDwf0+7l+drhVT/F5PnwuxecK4i1T7b5FpThuMv6WVWu4JGj2/Eqn+DpnreWq3RvUrRP2T/7jaL5AKXrLeLd+hN1FeE5V2Dw52R9YfFnyXukZK7gK8Qj5jOUfofOBP82+LbzAr5toCDOCzM8M7R/u/BZUM8Hp09Rv8l2q8b4Bv2NuNQZMLazwUTnLA0fz5mvhD7wvrPHeU30R5wDUXe7K3+EuYKbKFeAtjsKcB8h3VN5ffQ5rHsGfyvo88cp3qjCb7SoTOWMvDFH6Zla58UxlOuZH+hyLh2dKzD8Q0lnm8vkCpT9qflOl35zKlcQe/8e5grUXARxebmCOv2atx6SJ1eeu6s7X5SP8NYw2H94d/W3oB7G4jeR7U+KdsTGLJOAd1sWsygbZ/svmg9Qc+tW0t4OdZ8s+iAcsxF+DfiwLSQbpcteHJs3X+d1GDVf93B5eYq8cwZMu8idWsoma7xvYqDuO3fz7tTi+N+7UyvWdvnOO5UPULaLObAtgXEb26HylSoewDH/I3tormAX2O63ermCDtrMZy9X0F42k7mCb9WUK/hoL1dQOFfwN3tAruA/wLf9fUW5gn/q5QqmyiYJ16TAVUeu4F/nSK7gue/Y/TsvV/CzinIFz3/HdL1f9HIF3tPLFRC9Xq5gdnIF5iM8H1kmV/DBPTRX8GLwYa8h2fRyBWGb7OUKitluFbkC1s+qcgU/K5AraEGZN4/o9gwC7skwvBx/vAVs90SSTdVnELz9j49E4OrmDIK396p3BsG/2887g+DlCnCc8+x6kspCZxBYP1WuQJ0pHE467QFzBW+iXMGkwNvNGQTv3hHvDAL7DS//UDSPwHZW9AzCkqwv5vIZhCvAt50Z8G0DBXF+IMPTO4Mwe2cQLoE+8HIFnOdQufNuziB8nnIFaLujAPch0r2yZxBuAH2+Ovtdpd/onUHonUF4Cnn2/956BgF9BPsB9BFVnEH4PNl+K+lsR2zM0gK8h1CuIDZX6K3XzcQZhFvAh91FsumdQQjbZO8MQjHbreIMwl2BcRvbMQnvYs8gfIjGbrWGOdP7CtT5TI59t4HtfoNkU/W+gpj5uofLu9swb32Maff2FbTDq36K2VeAOTHej1D1vgLWT3W3Yey4i3cb/uyodrzKJ3i65+Uble5NivYp+2e/MZf2FXyPcgVzcV/BE+Db/jLg24ruK/iryFxBb19Bp0yr2lfwIydXgP6o7n0Fz1i0+3fevoInA+sTRfcVPGvRdL2fUrxRhd9oUVlvX0E0vd6+gqR7v+ath1S5r0DdZVbXvgLzEZ6PjI1ZJgHvE1nMomyc7X8u7St4Hviw3yDZ9PYVhG2yt6+gmO1Wsa+A9dOL89Mndl8BxwPqvlPlExrEL8J785NJAd8CGJ6fqFhIrXPGfF8B23ZS9j+v/RyWyTkvpm5lv+f6twPy5oN8165ar1H6bjTV2ID33n6XxoYGwJ1DvDaSTl4bom0jgfoKF/bLofD7EChH+NOy/rf4BOVZoF8XDkOdBHAg7pI6sxDbao+KJzF2UvTSZ0iU9Ufwsuuw1nEr//PQAxpU33jhd6yXAwL+HAFvshok3keTqOc4ZbtG28q47ViG9mc8pDb7MuJvoCR/MfJD/CMCfhHAFemLA5N2XUB9N3vFO3o3UlkLyrrNK7O/Qr/tfTvQ4JdALLeCxkq1ltyCd0X3mfG3adR80sPlfYc2L2/NtHv7zNrhVT/F7DPbCGX8ParYOG+SykL7zFg/q/qm1WbKHU8KvJ7u5e0zY91rifYp+2e/UWVeme2s6D6zj9J4XzLHU+s+sxvAt/1OwLcV3Wf2icg41/qxt89s+qlqn9kfQR9w7hj9Eee90R9Vsc/sXsodo+2OAtwXSffK7jN7APT5pux3lX6jt8+st8/sKeTZ/3vrPjP0EewH0EdUsc/sXrL9VtLZjtiYpQV4b6f8ANoX23+VeWUeN4ruM9sBPux/kmx6+8zCNtnbZ1bMdqvYZ/Y/A+M2tmMS3sXuM/sijd17Sq7ge2C7P+7lCjpoM5+9XEF72UzmCn5cU65gRS9XUDhX8F97QK7gWe/c/f9T9vJOjbNorqAvw9PLFcxermA+9MFs5gpelfGRlyt4Dule2VzBq0Gfn5v97uUK5NPLFRC9Xq5gdnIFryLbbyWd7SiTK1i+h+YK3gg+7ASSTS9XELbJXq6gmO1WkSs4ITBuYzsm4V1sroDjgU0C7xaBt5F0+iGD9/aZ7RDwKA/+rjbKkWMCrLcxQEflINKH95kZ/GmRMbXRrkPfUUas7y0o6xPwRff18fwa9YTvdUEZG03jeYvAmfL+Thob7gO4e5P2sq1QxmeZcR8bf2sNz1EiH9gG1IN1AGN4+wn+XBgbPkw2onR+K7wrqvPrqD1K5z1c9zm0WwJ+h0NbzT2Yl0TwafWUrZhs6rAVvJ+HbUX1k3efT0vAq35Se4J5T+a9UHYflXl3J+G31viMJeo2nk1k/bxPtGMdvOOxYZ3gNcV70Rvb8W4TeD3d885eKt3bKtqn7J/9Bto/+w3vm/Bq3GE7Q11FeM5FGfwns76w+U0L6hTQdZmLahGPDwEPSr957m7w4+DbPh3wbQMFcX42cty0fqxjzob2zr7A88HpU9Rvst22oGwr4doqcKFMOaYyGQ0KeMTXT/A3Obko9Ee8txz9EZ/PfkDQVf4Ic1E7KBeFtjsKcBOke+jT2F+kD+uewe8EfV5Duagq/AbHpOgHEEdozFF6pu6uwDGU65kfML+CulhHLsrwDyWdbS6Ti1L2p+YJXfrNqVzUpKCn+gFzUSjTFvw2XF4uqk6/hnKK8WvqDmI1v2R7Rh/BfgB9BPuPBxx66CMwFt9Btq98ZGzMshXwLstiFmXjbP/eXa2o7xw3oAw5bmgBLyrmwTEb4R8DH/Y9ko3S5brvpfRw1X3PBfOSJGGbVLZosqljvtFCAMAb6ieEj5GV6id1BozzTbG226IyHN/ZrlG3MZ/yvcC4je0oc8fKBI3dtwDc9Ul72TiUHZy087NS8IPwNxL8RPb3YADe8PUT/N+KeGs+waS/XxGgh/zhO44RsP5EABf6G2zfRQHe/1nE64ZzleDvFYI/g18t4FcBjPGjZLM60bSxPSsB5ipqj8H/JHL+YTrVpW84QPkGlBv7Bk9G6cMyXSPgUVYmkxGCR/la2fVQtorK0HbGiYdbBA83wju2a9Q7q5vK4ZHX7v5t/d8EuLlo130n7v4/z65vDtBD/jy7xvpF7frqAO9DwHuMXd8s+JtLdj0i2qPsupn97tl1vl03BQ+xdm11Uznc/dp2vLdDWV/Saevcxwb/Qkdn70g6eUUZsnzvFPB3CP7nEw9Yd76ot5bK7oQy9jvrhBwQnm3X4F8Kcljh6Lrx1aWuDytdxzkX6/p6KFNzNO6LDQJ+PcCYTEYInvsF/0Zc2NecQzMZDSa6DwxfP8G/Svh+428t1Oe1gBsL8t4UvA8nnTaDNnX1a3b/Nh1E37CSaN7m0OS6SGcwAG/42HbfKOTFvg7tAPlaSDgN/nDHHyhZjsM71kHlP24X7VIyvYPKboMy0wVlnwZXx1iE7Wf79NqaPmV95UjSaT9rqAxtg/VfjXlNeOfpP+rQ2a9px3sblBneL0DdS7Lf/QS/qKB+4RhfVL+MH6VDrF9YbxWVYb+w7d4p5IDwlyXtcjD4UyPHG+OrS30+Qukz6iDrM44tyudzX3jjE8pkhOC5X9hPsUzTh8cb5T/vEPjZf57pjDcYa/NYuaYg718QvA8nnTaDNnXfq3f/Nh3EOLVJNNc4NLku+ovBALzh6yf4C5zxZjXwzrFiI2m/VwbhL3b8gdHFdt0K71gHlezXinYpmXpjkemCsk+D69I+36rsE9vP9um1NX1YNsq3ou5a/48knf5wNZWhbawlOmpOFqv/qEMrX63xhsabC7PfrF8fc/RL2Q3mOViGSh9RT3i8Qf3iOQzWG6cylOkE8aDGXYTnnKPB/37keFORPj9T6TPqLOuzp5/pU3TsN5mMJJ3jAftDpbPY1zzemIwGE90Hho9j6+uc8WYc6t9GvE8U5L2MvV1D4w3OaZpEc8KhyXXRX4TGG8PH+adbnfFmJfDO+T413hj8yoI5Om+8ycvRGT9KpqupDHk3XVD2aXBd2uezZjvXxuONmk8r21hFdFReOlb/UYcuofGmSXgRF+qFp49NgNk/+836eK+jj56dpQ/LXOkv6lUz+630kec8TSjz9NHgutTHU5Q+YvtZH722pk9RW7X+HEk6ddXTRx6fm4IO+hDWR9SjJrT1jFe3w+EaYCP73/bOnAvvC8h8XoPwGc/4DvEPES8F6U3tRzqX6HH7rO9Sm3lm9vvyy5afv/yyK4+/aOlZRy69eMXl5y+bh6iTzhUrlApixXeNpL31WNZH7/YjuKPp7wWiXiJw9wHd86FMScJwmlVim84P1ENZJOLdPAF/LuE6V9Qz3vuc+ogD67HGNOg9es1hQbuf4P8MvOZvXRGmO5x0ymGY/r5S0KvR6g58eljdMwirwSAsPs8AzhB+P/qbe3ShqMePSayfeP5BpkWp9n0/+209/0Koa/trrexFgNvumX3qPNdJ7XAHEw/qf+Qd3/H4VYWn4PXJ9FlM9c6HeqdH8HC+4HlE1De4YVGvrGxGHJ6NDnqT0ex32lf/cuL0+/TfBVCmPBGvnxr80pOm6/0kw2myRIs1HpWc35e081JUzu8TdOqW8/uIzgUV0rkAYEbhd/rv84SL5Wz9ZHK+GMo+T/WugzKEw1Hu8/D+OkFb4TcceTo47yTdtpAOGq1+gj8adHDgpPb2q9GUR98k8XWe9XIwAP8K4s/g98t4UvP4YdFm5IvXKQ3+AMB5fABnkvi+0msX6tRwoF0HinapPSBWX40th1DZi6DMfDiOLf2E47nZ+32Tzv4oECXIM08hvhHO6B5cjm70HMTwDyWdMiwTDR1M9Lh95aIhlD5LBbHiu0bS3nosy5uDnEB/l5mDKC/wQoHTPIqK67keWyG/myfgDyZcyoLYO6v6iAPrscaoeunf+4s6MRZQMj7vi7UAw1+VBeT1u+mqtf1cwcuIKNsPfmMZ0jlX0FG4XkS4XhTJc9qHz8p+Z1Z70mUXXbosM9uEnrxJx8EBNuaJ+gnVZdPmwP6FokloOgsCtEODsOHrJ/jXiMHKq58kcWqPXVSH4zf8Val9rArxJA7reoN8I+nswxlS1fQ5IcCGGlESwtUQ79JHxZL7Ur2ZUuO3OTHXvqJ+Gjv90YHttPPibJ7rGfwCJ+ZUcwPv3Mb1Ah7nI8bPfOIB684X9XieifuULyAebkg65YDwvFfW4N8JcvDWko2vOvbK3gAAvDaAayR9Ap774osCHteJTCYjBM/9gn8jLuxrtgOT0WCi+8Dw9RP8exw7wHn6DcT7BQV5Vzas5rVoU/NoDoo0eSi92KGpdNbohPxGaI78AWcOqnI/yBfPQQ1+ueMPvDxF+rAOKv/xedEuJdPrqAxzEpgPMtyMs469sth+tk+vrelT1leqsxkXUBnaBuv/BYJOrP6jDnFuEf2F4d1X4DV4289uOs4w2F8I/1ugjwvIJ7wI6n+R2oHnTxrZ/xbefYl4H02inujwzvAPES8F6U2Fd18iety+cvN6jnZQKogV3zWS9tZjWV4U9zb6u8y8/iYoU5LgeT226aZAPdZcfjdPwH+JcH1J1DPe+5z6iAPrscawFaFX/6KgzVb0KbAiXltEuhg1MC/297mCnlndTQSbJNNWdzO1aTSJek6NtTrDP0S8lLW6m4ket6+c1aGmIJV3EVaDQVh83gWcITxP87n3zhf1+DGJ9RPPayAnfwPFQ6ixLya+kQfPf42I+nwmFOm8pEs6LxF0TJOHoIzXSvcXbfXWRVT8sIjKrhPtsrLrHZw3ODi/IMrSvjt4cTsceqNG4P/06RPvWKZfErxa36EHwJRHyNpuduhgfYMbFvW6bY/imWMMbGsq37toDQzPrqvRwOKsfoL/9Sum691D9oZ3WRiPSs5si0Xl/GJBp245s03dWiEd3Js2Cr/Tf+OEi+Vs/eTtJ7R6K6EM4TAiGIf3as+nwm848nTwkZN020I62Mx+9xP8fNDBR0vq4K1Uhn3A42Ez6ZQDwvPc2fgcDMA3A+36YyfX8CVRX/HO97Dc6vCePt49LAZXt86/guiE9Oc7pD9NKFP6wzkKg//p5dP1/oL0ByO0Otrv2TVGcjxraEJ9q8uyVPXQRl8VwcO44HlE1De4YVGvW91QPOfpxj+Sbqh94liXz80a/P8G3fgh6Qb6zylfJHjmGLConF8i6NQtZ47vJpLpp1s6EwAzCr/Tf2q/OMrZ+snkjHvJV1M9dZawkbSPb7jfXJ2dUPgNR54O/tdJum0hHTRafJbuEdBB2zio5hqeDk5QGcqUz1RMCDmoPmgQ34MB+Alql8Hvk7WlzDkj9uUGvx/gjDlnpGbLni4WPWfk0UY5LwjQHkx0+0O6cqAjU6s/EGgPy9Tgn+3IVMnIk2ne+SQ+D4Nt5jsAVKYN5RwjU2z/TdR+g3++kKmKW24i3jF24BhSxWEIfzHBKxtTsQnb2Isc3r8k6qvcAu+Vw9zCLVSGuQWei2Hev0llmFvgPAfmFsap7AYoW0ll6qwj5hb6qa2vyN53mYOXe/q+RLwNAXwj8H+SxI2n2Ff7EZ268iZM56YK6SAuy8irORuvaRbNG2B9b264f5d09hd0GBf65FGA4T2wBj8Gdn00+WR1h+H+8G6B01a2Z8RlfWb2gb6vjjUqwz9EvBSk1/B8LraPtyA1BS8joizUp0jnYEGnKF/7Z/TTJ8viv23ZGZefffxFZyf09NPfRwVYfD7BLQiw1hB4G/SP3z+f3vUJWMQ9U6Y3m3Re3iWdlws6dac6X050QtOd0xdPv0cVDk13Lsp+c0p5M0x33utMd0Jmh7rmbYUzeqHl/uEAf2eA610QcaziIofnW4AG001/Hxrg4WwKVUq6YhmqcCoU+RmiMgw9+EpIDHH6xDvWuRsFHcYVGiZNrhzSXVhwmPQW6pGnW6gMhyaWg6Kj3LuSg0fnN7qk8xuCjjfsl/Ulimc1lRjNfqd9fDX5kluhTIU0vFXM4MfBl/y240uQR/5b+eXQOBnyJTcH+Pu440s4NMR2Kp5xCsh0lS8x+GvJlzST9raPJnGP8iXN7LcaC1+ZtPNfdCzE+jM1Fr6S6NS97KfS/exfmkSH33n+pUntCdnj9Ys1TWWPPK4h/HKwxy9GjO0xS3V1+17GFTsGGfx4hWPQzRH89SedNpX+/k1ocwhXIt4ZPI5/nL64lWBvcWBDfiv9vSL7Xbd92SUiyr5eTfw1iU6efWH9JrUnZF+bCtpXpkYd9rUY7Gsz2dc41Ge58hIAwh5NsCuh3bF4B6hu+iwi2HHCizp5WtLeXsP7wpOn8W+lLUMrCb/6P31idAdT+6w7E1D2GviNZUaH3zEdrG9wbAusOzsXa5qoO1iXdcfgh0CWjywOt5HTrFXI2d6vgvdMl5cgVxMspvLHicdVVFf9n8ejuoZzNeFd4/A/TnhWinp1L7euJjqrK6SDuE4nOiHd/Tbprro+Hev+Vvabr3j8/uLpet8l3cX6rLvoU3kLZRPK0I+99eR2nvEKSpPTu0Vdg7+N4BFH+uRds8wwVpevWf5rMbewtq0R9NK2/e1i3TbsD3UNM19Z3Ae+5B+oP1Be1h/qqnC2AfwsAMMeHZDB/wG9+NHiMC22C9XGFMcTi8NwRws4xjFPyICvlV8p6qnra9l21xKNNQ6N1aKedwXzvKRTZurq2DtyytVnCBLxbp6AXxtobyJo35aDd43Ao/y7dyUsX0GulrZjryBEv/dtx15CNqH0aq3D++3Eu3fFsuJdyQ/9hxc32N8xY31D/G38fQjesY9VS/0IY3V5qX8k81sqH6O27yBfVwRwPhNwxlyF/Rp4x0tFeVdh85YUZeeKd/Ql/M6LZRLBA/pCpbOhOI7loXhQ22+U3+TtNyoOj7VNjKd3Pk3nGC89WdMsOsd4C8xPf/3kcBv3hDkG58znwhzjFsLTm2MkyRtJd8vOMZ4Nuns46W7sHIO3UjWhTM0xrMzkO0/UaxK/Ru9siMGPInz7Ay3Um/RZBHCoi/2ifvqb1xUMfgGMe++gT0pi/TcRPVzXUWs9rBNvEnyF2qnGMJbbWRnf+yadtlhgPeQIT/8N95qSuGPsR9m8mj8MibL+CF4u/OnSQ5cOXvUY25Xxwu9iYpk3CXiTFc+bR5Oo583qCgb+lBnq9hoqG4Ay4yHV6ZcRf2tL8hcjP8Svru7/MPwu0hcKV7NCXLeUxHVg0q6jaIfK33PuRuWZ0368hvw2+qE3EK9F/RDWL+KHeN3GYD9Gfmgc6hTQr1d78YnhXl0Sd6wfCsUEyNeQKIvxQ+f87IiLd574p7/SSDr9bZ94F7Ml/Q0Cvks7f6XyQ+xr0A+tpjL0Q8aD8kMlx5RXxsgP8atcEvuh2L5QuJoV4rqlJC7zQ97aAvohju/UEVv0Q7ye9QcQs33i5HZcXq5axW8cY6qycYEzpf2lQPw5mP3/Tijj9UA1R7e/8R3qOtbhdXSD/zzI5rPEH65lYzuRP9VfuMfm+pPDcCsdOC++V+vgXuwf2y88VtxCY0XJi0zkHh7DldL6/2W/s+3Hxyy77KRzll667KyTlp156bLL+gATcseY7G9rNdbjxzjhncdfoL95x1qT/h4XePJoqh0mh8Fvphuzw+QwwfNs0nlzl3TeLOjUvYvwzUQHd6aMZr9Ta1lPM3+1ixB3p2T3h3V45SNWTNfb5ESQLGe0wiOSdl6K7nbD+jf36FRO561d0nmroFP3bsS3UnvQRlhuRe0a698yw3Ty7PqrJ2uasXZt8E9eOl3vG45dh3btYxuLHrBinxTCdSLhwvrepSU3R9DxLv6IvRwlpj0endlsj+FqClzYB4sdvpqEazwH10mEC+uPU9n+Ds9FsxNYf3+HTrNLOs1IOjPVnhu7pHNjJJ0juqRzhKAzLOo1Av8bHX7nnVQ7guiE/O2T5G/HoUz5Wz6NYfB/Bf72p+Rvx4H23i7nKlYz1QrfKNEJ9WffKdPv038TWJbk96fBPw79OZjh9PpTyWY80B6k6/X1OLzjzN5KAd904PN2CRh8jRnV6M8U8upNyVWqqcPR3uU36YOHkJ+d/c6yAEcsW/GqQw572/9NAVx58WWh7OozkGjSvrKO8An9zfVS3voJZn9BI31Yf1YSHPe7vWf8MTzlweaVK1+3KtDOJInzdVh//wAutPlRgLH+4UzTczM7V6dZVEymLmTx4gG1Io9wfaIN+wXqfSzR/FmbkSfVZoM/yGlzM/HbzPG7ih3ZNzFcn2jDvkmnDiAOJeMjk3bei+oT1p+psfNIohMa0w6mMa0JZX2i7sez33yC5n4Y015BY5qKBetuP8ev6nrtjwNMaG7TH8DJuzcM/nVZ27tcfZQZZcOl+hRt9PXUp6rtXp8a/O3Qp2+K6FPPPtRlzZ4vuMWBHxfwKsfkxY3WPxPwPr5/Gv87RkcR/xDxUlAfpuINdSEatq9svGF4/xIahPznxRtcz4s3GDZkexwDjNP7vHhD8RSC7SbeWBloZ5LEjQ9Y3+BMP0t+YGLUeLkZ+DBeUOdDJ3/nJZ22peBVjKF2abAv6k/0ODwK5Qi/CGKJE51dcW8L8JckcX2B9WdqrHob0bmxQjrq1hmVX8WTV1hmdEI+dkTU99YLVnZJZ6WgE6vrH81+58VEZ9D46eXJkS7nyU+D8XMZjZ/qFiUvDxdzk0/RjyR4dh1rpyq//k7CVXRtA+t7p/UV76Gbf36H4rKSN/8sUrtDzP66jPkWxdg44le7HprZ7yFRFrMr7B+H3vT4P2/+0h83qL7xwu9ickfvFPDdxV/JQrUrDHespA/qyDiVDUCZ8aB2hZWM1xbGyA/xq8uk8TRQkb4YEWULSuKynVxNqM/rTTPtk0K5F/NPHDv8vpOHUL5J3Vjk3X7EPo3byD4nScJ69At6DF8zmW4D0+JLbA32s9Duk+nTULcKXs1H9Dk0EvGukYRlwzTmibq/k7Tz1ozgTeWDEMeNAT5THGoNkfVW4cR3nt4anKJzQpd0ThB0vDGJ/zc6/M5bjzyB6ITipgmKm8ahTMVN12S/eb3rGIib1lDchPWbSTs9dZOh2l/Asg/dEMD+xODvBLvi064qP3wN4AzpWewpIYPfNAN5Jm5Tf9LpW9Pn7YluUyhfzDJQejLqwE8AbdYrpKUumJ+AtmDb7jttmof7TynW/uMCOO89dRrn1oI4jw/g/Oop0zi3O7ZxbNJOr+itklifd+CqS7j3TTp1t4AeRl9ubPiHks42l8mnqfyAkou6qJ3XZ7EsZp/GsYJOg3Dl8bV/UtnlxsbiLxHcggBrDYG3Qf/4/S/RO5WSQ9ypmp98+u7f6vvhSwi/+lYvvmM1x/r8XWKkc1CXdA4SdDxcSwQug79ewB8k4CtUDWPxBQDDXppZY7x5qsG4Q6phTx/RTH/z/aPcNcyj+uz8kNOmPvGOu3pI0FJ0zuiSzhmCDkcJP6EoAekX8Jaf4M9GGA7EXTJT/YlYz8+ft0B6xpf6LHNM1uNlD3145Rtfcs47GlTfeOF3bJJqFnmGgO8y+/Q7KuuBu3/TR2XGVNbDeFBZj5KfDPidGPkhfpWl5qxH0QyCuge0KC7LeuBnUjxbnimfUQcdD5d3d7PJZjDRK0Xskwz+P2H2dCplJZS8E/FuXtLpj7Jge0puiOvwAO+KtuFPnxFR3+Bq9IkDRX3iUNLZ5jLRsLIPJRd1Ts/q8g719OG7MYquCMx1XKib/PklK1f/Gx1+x3KuYkWwytNlVd4zrLJkr4XfWGa4+B33C9ZvUtn1go4ah26gMpTbAipTdyooP8T+u6gfGhL85d2R/KJ3aZqYbVGndthvnwDZjF99V7iNMTupED6U4fr1jMZM7KQKye7gArJLn8XUFoN/FcjuFY7seOxvQhmvBKM8+KQZZrwQB5Ylib+DSGWCcYWN6/HYNwHv6xj7DH9VO6tUVrEJ7ziGX1WOXr/RWy3oqX54RqJlqu46MxtTvo79Gfo6XoXEcW2cytS9DZ4/wzZxZlbxN1N+U9E5vUs6pws6XpwYo+uKjuI5z5ctJF+mVlOx7lXZb85OHwS+bBH5MqyPPPLfMfMLoxf7bRiDPznjSa3OqDZf5fCMNJKk02547DL402nsKjmflmMXn/ZVp6S7pBudjTf8Q8RLWR+ctxqPqc1nZr+z1ObxFy0968ilF6+4/Pxl8xB1Et7j2CCs+K6RtLcey/ro3TDBHUt/LxD1EoEbM57qTIi3L0Gt1atZ+Y2CLq/Nq3PXak8Az277nPqII7RfpC9QL/37k6JOlfcEVDmjqXGP2LNiLdPwDxEvZS1znOhx+0J77rGu2sOJi0lYhnS86BRxXVcRrvRZ1MPVw9XD1cM1C7i8PWU8C0sfPiuJfpDPZhVduMb63gL5CV3SOUHQGRb1yo7JIw7PKtvCcmsmne1pOnTU2dK8/XOr36VphvbP8QzN4J8BM7Tb3tXOs5qhpY+aDWM/GA6uuy/wYGUF4ov56Szt3fSVnSYA4IplXhyS/ra9dmo/Ne/XQV0wHHl9tJn6SO338/Y4Gvy/v2u63n00i1bnOplekkOP7XAwAM97HA1+G8yiT70izN/NAXqhrMKFAXo7gN7xoA/WzoRod6l3z1J6h36G9U5lgpQ/8/wF2hbrYhPKeGVW7d3z9rVa/cFE94Hh6yf4x0Wfx+o596vBfz2yX02WdfQryor7Va16q/OBnh6oFXqVqfs84fq8wKX2scbasuFj2/qO06/qC+HIJ/erwf9FZL/ieVbDY2Xd9ivKivtVxR9q/6SnBzg+mExUZv0LVIY+kTPXyn+jHsT0OfZPyH//vehz7w6wmPElfTAD96zsd5aBO+myiy5dlqXgEnq8lFn69y0BNp4p6idUt0Hvnkllyn16m4SM9mCiU1bsPg3+X4TIPfebPjFbqrG760jiGv6qtlTnuTVOFXlm5k1lZkFV0+fYABsNUT8hXA3xLn3UNmd1y0+Md1OiUnu1EN7w8br1z52RQ42ETXjHHnZcwKs1PtX+cSrDejGnSVCNeESbgj91uq3eiFbRzEeOaCgjHtFUZgHhWd4TAl5lS9W3qDg6RRmPE508MzT3qmZWGFXyzErpixeZefJR+tWEspVUhvW8WbDB1TELxvawLnh9mz4sG3VrDPY3R624t6BJZWhLK4lOU9CJ1YUmtHV1YK0a8XozIHVjAw7hPCs3+JcIH2A4b81pW8wMUJ26VSt4TSrDerivwHAnBNelPh5QZVYmfYraKvsf1DPeO45jQTNp51ndpIF7IWZqDxaP3xPAiwoRDS/fHHoYZPaOO7Udp7LxJrzjPlD7j9TNh+o7k6sjcN3g0Fa3Zq52aCNfoW+dJoJP/PaV0bKyZva7S1sZULaC/pltxfPF6RMjK9VP6jtiq6ksdj/YBJXF7gdbCW1m/VTxovLhynZx3+XBZLtNgOPZdlPQxHfePjGD45j4JBgjjg7ExCG7viaA8xRn3GkmnW3wxp3xJNxmZVvo+8apDOuxX0Tfx35R+WvlR9gvml6jLSJ86JuZSzP5dXmLsNxvxb5uAnhQsRfvATb4D4LvPutUjXOgIM6zI+cszex3l76uv25flzcmmUzUt8pC+w0Rl9qLynY2mOj5kuHj1bZLoQ8404b+ln0q+ttxKrtF0PXOGqRyvy7jg+O19PcowF1JujcOZcpHsu4Z/BdAn38r+12l3+BbhtAPIA7WKU/P1KqgwSl9Nj/Q5Z7v6D3thn8o6WxzmVScsr9xeMd72kv6zak97SpWUf2Ae9rVPnbEZb5qpv0ayinGryE8nw/CNrI9o49gPxATkyl6oZjsuppishdRTIb2xfaPNs72j/rOcQPKkOOG1cCLinlwzEb4W8GH3U2yUbrs5VjUd5nV94HnJ526vjYC17hD+zYBv9ahjXxhXaYdsknv9r065lMYF7AtenPJ9ImRleqnEYJH2RS1XZ6H4fjOdo26vQrafHdg3MZ2NOEd225T8IrxgOkGLje9J2mnqZZ28B2Ps1jf4BSdg7qkc5Cg4+F6j8Bl8GptpebrVYzFlwBM+n7UYY3xNugfv2fcfQIWH9VNQwG+kySum9RmBcZlLjx9TgQYvlQY09DvJVxFNx9ifV4KM76+S1NMpF/AvX3OOx5uuEse4/9cg/AliQ4zQ0fTkC91pUDMVSpbb3vnAX+687Cpq0Bij9AZvEr1v1fAd3mVymfUEMbXpagjy0WvUil5BcRnYuSH+FU6nK9SKXqcEctOLInLrlLBoZI3EtftY3jq+pcihTfTvDSzv//GSSfmbWLijd/Iu7dZm9tV1F8ORdJ5X5d03ifo1L0p/H1EJ3Sc9icUjl0PZSr1e3X2mzddTsDFk09SKKY23zcSPf7gGJk+bK+8KZRhbg7w9++gn3ycVrX5aodnTKElSadf4PTu1DYUGntL+lSZ3uVrxWq4zid6J9ZsXedT7Dgtb09GqSBWfNdI2luPZX30jjdcHU1/lzlOqz4zcYPA6V1prkbfIpdUIV61KYEv5/NGe8ShFvUMh6qX/n2lqFPlRQUzdTTXLLMJ7wtYSvRnI5vZ7yHipaxlNoket4/bPi54UclsnlWNCzrjgo7CtbJCXLdUhCt9FvVw9XD1cM05XGoGeiuV4XjAn4dXxxoaVIb8eTMvrO8lHk/vks7pgs6wqNcI/G90+B3TUTyrjYMst6IXGmJ9vmgmdCTyqNM0zdBRMZ4JGfznYSZ07GntPKuZEMpAnSGo8ZiZ3CCJcuVFCrV5FPvNjvJ6R3SULsT20UnUR3nH+fhoscF/GProlOx3zLHQvGOrVxG8tTH22KrBvzvjKe/Y6g0Bemr2nj4LA/TeD/Rm4NjqgUrv0M/EHINT/szzF+oMjlrI4mNw3tHHokda1TE470irwZ8n9IHHItaNEH9KbhUfg7sxwMYzRP2E6jbo3TMCuAxP+g6nrzHH4NRJV3YRlwqRe12WPr1jcHvcMbijA2w0RP2EcDXEu/TJOwbHo4onYiWqsgeoPyZU2vOw3serVSSgcvPeMUAV9dwQoKMOdqcPj2gG/3uRI1pFkZQc0VBGPKI1oczLnBj8uIBvAgyb2jiU8WjnXXNc1TE4jtSUvnjH4JoCHnll/Yo9duRF1XvLsSM+BucdO8LhqEl0VBQVqws4e+KZVd5lFaE1WvQBOIRfk/3m9Za1wgcYzhtz2hbj71TW27tKXF0X7B3LNLgu9XFY6SO2P2aW5302pingvZlfE8p4GymOBRxG5umNt80T1/h+QuuTSId1r+hnW04U/Cs6B3VJ5yBBx8N1osDl9XfNW8WMxecDTPp+1GGN8TboH79n3H0CFh/VTdcF+E6SuG5S6qzoDHVJZyiSzmld0jlN0OGtIP8rA+pyufnjMQtmEyVxNwhfkujZlOEfFvSML3XKIWaL2b+MnPzI+U+uuaNB9Y0XfhdzGv40Ad/lqYiPqKGJT6Sqk25qi5nxoLaYlTyV8pEY+SF+dVMETwNj+2JElC0oicu2mHmn6+v2GbzF7K8ghOItZrPhv07vks7pgk6VXycacXjO24r1o8CUKbQV66rsN099XwPfnf4/lNxWNwk0Eu2n0/+9LxsYvdgvGxj8v4JO8Vasm0Wbr3J4xm/GM93096EBHv6Dxqhm0t720STuUVuxmtnv+YIfTuWoDT3qSwFqYetmh877u6TzfkGnys0wIw7PVd5hrxaiRrPf6pTnUviNZUaH3zEdrN906FzXJR1156tKC+GUSZ0INJl1GU/1x/QL4h8iXgrSc792hO3j7PQqwYt3W1CDypDOKkFH4RquENdKwtUUuJYKXEXlVeFUr5n9fQrBLQ6w1ifwNugfvz+F3oWmeoZ7pq7KninTz1s3f8npmmZo3Tz0Iear3j1d76W0woF8zac2Ft0xj/W9nfk8BGJmjbNu6krwBpUhf96JErVi0SfoKPf7dPzQEQ/pWFcN0TGXYMwXdIryVaGbMxYPJrjQnW4NgTfPzR1M70Juzv6eKdVXdBZ0SWdBJJ2Zas/NXdK5WdDxcC0QuHrq3YZbdVPoytgkiesmdTXEbI4gmJTIG+XfSaO8+kygN8ob/KdOn663GH7zngbE9aWkvQzleBPxr3aUdnkeOXoENPxDxEvZETB2Z1qxs0k8ZUCpIFZ851lKH73jDUr7U70yZ5PU6py6El7FcdcH6qEsEvFunoC/jnBdJ+oZ731OfcSB9VhjGvQere2LgjbvvTw7s6o0HfY/KB2maKE88vYXMgzzMLW/EHhYENgZ1B9oF1sz3wiAnuDoAP2PgJe56HRNPxH0uX3oPQcD/IYuCV8BMuANf8rzJ4F3KAOsG/obYfeltuDfShe/SPBfyGk797/BX+X0/7DgwfhKnwU5PDDMvgEeflvwILzmkRddfGVgrx/HGuzluJe4J4YFntBj0kg11rSXpcPWwXTsb6UBacufnf2eCt3OX3ZZaJ8jjwhDAZrzEv0MJ5q3JJm9ravD5ei5W1exfWW3roasNI9Ol1tXQ4O2chZcP6G6DfEufVJ1Pjhb1JjN9YvruqSjkkSMKxQWX5b95q9hXw8O6vjAutU8gTN9ONnpbZ81PAjfFPC3ijZ62yE92t4633hBXicE/DjAcGKuCWUTBXk9cYZ5vVnwWuO6SrTrnK11lWLTmtD98Q3Ciu8aSXvrsYw9JE8VjqG/y0xrYu/IVHc/rgrUY83md/ME/AThmhD1jPc+pz7iwHqsMape+vfviTqeBcRocPqEVuqqwLVa4DLLxDsTC1jKc2It0/APES9lLTP2nkhr+1rBy4go45SDurtzraCjcK2sENctFeFKn0U9XD1cPVw9XHs4LnXIi+/mxfGTr6io+6oFReeELumcIOioKwvKxgojDs/qrmuW22rRntUOHay/mtqDuxxHs99PHVw5XdPEmSzW5R2iBn8ebON48vRwG1HO1i7muY5vxmGMMwB4Q/aDMdw12W8VS/BhI+xrvBPc64OfUx+U/UbbYuiDRvZb7XjG3V8hu1H0WEdCn4G9hfibgs94UldQqG9+eDqJcv6DAL39gJ53YNdod6l3z6n7fvY8PeXtL+qee8Oldrmr7yY0qP5govsgdHLnOaLPY/Wc+9XgnxvZrxX5k+cUvdKmCWXeOOTpQRNg+CJj7PNQJhJxeZ90bmZ/h2yZd9wb/EucflWbBJBP7leDf2lkv5os6+hX7xBrE8qUbLlf1fjdBBiTyUjSOU7ytTB5+3Ni+hX7gH20wb/K6VeV5fb8sMG/eg74YZRVTL+qlYDYfmU/jP3KVwGNQxnb8kz56DHR52qneMyh4NCesQqvApoIsPFsUT+hug169+wALsOTvsO0KovcmjuY6BQoi9zgjxEiV2aq9mqpQ2Wztdu35EFcd7evcqlFd/sWHRZrUNX0OSbARkPUTwhXQ7zDsrzrJryrNHCEfifN1lCFeKagPJ+K/A3eItBQdGH4+gn+NGcU8qLg9GFvnfcFKD4bim24jcqw3niADo6O6Pl5dDT4JZGjo9GuY3REGfHoeDuU9Ql4lvcdAv52gOGs0h1QxiaNMr6N6OS5DtZ/padq9q2ice9aobxZGesX6sRaKlOzOaULBldHpgTbw7rg2VL6sGw83UHZjCT5eoJ2uZboeH4pfTxdwOzCT8gXov5xdm5c0MR3XnbO4BSd67qkc52gw7hi96kY/MeFjzKcE4I/b3+E9+Vb5EfJBu+IYNqNwP9Gh9+F7lvAvqpy5diLqL1V5bJ00M+sJDprKqQT8lnsG7qlo1aW1fjVLR30T3xO/fYK6aCvuxXqpX/jmKhuA71T8GFTgHXwvsBYEH3e2vAPES8F6U1NAdYRPW4fTwHWC15GRNmH4TeWIZ31go7CdUOFuKxv5yedfX040VGx1B0OncMj6Yx1SWdM0BkW9bq1ESUbo7OuQjpoM2NEZ32FdFAPRonOhgrpbACYQ4lOU/CQxgPb3j39Pv23Eco4y5U+/PVzg//WJdP1HqJVKPQVyCPWx1j2TtEOprcro2H+bxPUKeCP5L0rhitPdo+Q7O6EshjZGfwWkN2jJDtsF9v2XVC2jsruhrL1VLYZyhAHliXQBnzHOof1DW5Y1OPx6h54X6C/or8cb/iHks42lxmv7iF62Pb04TvS7i1Hb+rL8fcJeqof8MvxKFOkb7jMxpSf3URl6Bs3Uxn6s7upDO37EPiNOENt4h2wyB/rN/I3QWUY06+iMozDV1MZxs5rqAzbzPGttXmA8KTPIoLdRLB3CNh+wmsZyLTO3767Hd/mAO30Nx+SM9gfwo6Bf8h+83ikxpC7BK9WdrcoS/FvzS5jMjmijmIfhmwM33njt8EpOgu7pLNQ0GFceKgR9e9aKEf44eyT2136i7NN/ugv2NfeXxJ3rK81/MOCnvE1JMpi7rbs/8rE5NZzn1zUoPrGC7/jvMMDAn6hgDdZbYH6BWR1hsrXGW11t+X9VIY5N+NB3W35QEn+YuSH+EcE/JEAV6QvRgSdayvENVEhrtUlcdmdm/dBfbNpNS7xbk6VT5tweMb6Bld3fox9PsZUo9nvVI+f/Z7p9yhTjIuxLvtIg38vjHu/lOH0xv8G4U6AHsYe3kmbzYTrnhxc/MlprM9jxb05uHh3bSieQz0L4TqJcKl40NNxlO+1hAvrs+9X8/Mux6HBouPQkGhDmZjfk0v6cI7qAcHLiChjfVVj1AOCjsK1uUJc91SI694KcZm+KRs7hegUnb9i/Zj5a4wuKjqKZ87/sx99PfnRe6BMrTWHYs0TwI++ifwo9jm2n9tlcF2uPe6j1h7RL/Lao/JzqFufyn6PJJ2+ie/pxj4wHFX2tZLp65L29hSde2D9e5z2vI7aE9Kp4wvqlMmXdepNoFPviNApZbuc9y5qu4dH0lnWJZ1lgk7dPoLz3vdWSAftZxnRua9COmiLo0Tn/grpYFzBOYuQHZxFdvAAlCk7+HT2u5/g/9dZ0/XOduwAecT66EfvEe1geudT3qDkfFXmvQ1XnuwuLOBD0ofz3gbfAtldQrJD2mzbKi62Mi9uQFlxrGNlCbQB37HOYX2WG9Yz+Vp/bYX3deS9Df9Q0pV+TMXAW4ketj19OH+yrRy9qbz3g4Ke6gfMe6NMkb7h4rw3+lneb4S+cQuVoT8L5UnS35z33pzTJp6PKt0327H88e1gO5/IbGeYYNKHY01su+WeUxy/T/aHcuA8rZrH4jsvT8v2inRO6ZLOKYJO3eMnyxf9wmj2O5XvdeQz74OyPlGXY3mDvxH6/QvOeIPt53bVGctj/MCxvJpPo01xLI82xbG8ymdUuW9rpmP5VYIO51RYp26LGIexbiiWvxZ06k5Hp7y1NI7li36b4PBIOsu6pLNM0Kl7v18vlo+n48XyITtoRcTyWDcUy/862MGuGYjlH53BWD4ku8cL+JD0CcXywyC7rxfwISpnqOJ1juUx5kMcWJZAG/Cdl2s0uGFRz+TbZawbHcsb/qGks81lYvltRA/bnj4cyz9Yjt5ULL9d0FP9gLG8it8RF8fy6Gd5TEXfuJXK0J9xnO/F8vfktIljecUf4+qHdyp2Z1v7u8y+Ulv7G4r90c6Ndgp3/nvb4dQYZH2Asina74gvSbRe856AknsfpvTayxGnD6/TqP0Jqu9/H35jGdKJXVdeXyGuuRCHjXVJZ0zQmek4rK74aIzo1BUfjRKdByqkg2Mix2GhOe7Ae6ffo19Vc9z04VjC4NefOV1v3wynyhfwuL8F8CUC/tAAvQMyGl3m6GQcxvFESHYjJLt7oSxGdgb/GZDdMx3ZsW3Hxlr3UxmO14gDyxJoA75jncP6Bjcs6vF4VTJOiY7DDP9Q0tnmMuNVbI7T2re9HL2pOOwhQU/1A8ZhKvZCXF4cdi+VoW/cRmXozzhGQ/vmOOzenDZ5cdi9AVyxcZjBv4z8Rsm4SfoNzmn14rX2unXvT9xcIa5evDZNh9/14rVq6JSJ1xZUFK+9CmKO42cgXnvnHIjXTqooXns2yO4Ukp2XN1PrHyqW43gNZcXjYNG8mcqvPF3yZmq82lvyZugbOSZDf8Z5My9eqyJvFpvjYpqhuO5dVG7wl7x3GudFlDdDvtYB7Z/28mt7TX7NO2vI8Zo607jOoXN4JJ2xLumMCTrDol4j8L/R4Xfe3g6O1+o6Qz9GdPa2dc5QzPEZ8m9qndOLOQz+3jOm633Oiddi1jm9eM3gv0DxWp3rnCHZ3VhRvPYFkN3NjuzYtnFs5PP4vXXO3U9vnTMcr6k9dMo3VrXOuT6nTRyvIX/rA7hi4zCDv5f8Rsk4RvoN3h+oxqou7xaJjtcM/1DSKb8y+r+J6HH7OF67V/DCc7z0ORLguMyLC9V8cXOFuHrx2jQdflckXttUIR20mTGiU9eZmVGiU9c+u9h47c8o5vD2/KYPxxwG/3qIOb7t5IhCZ4Rj96UZ/PfI75Y8tyv9Lp8XVndjpe38fmAuj7JDnxbal/YCkN0PSHbqTjkl101UhmMqn01BWfF+n6JzUrXn0JuLdHlHRHS8ZvjVnR5lxit1Ntg7Y1Jy/jAVr6m4WfUDxmsoU6RvuLx4bT2VoW/kc+Lozzh3gvYdE69hm2LitaI5rhpipvmxOjhbMVN6R+yvZb+zq+KPWXbZosvPOH/5mcctu3LFEReetWjppZctX3r+EWeddemyFSuQaSR0ALzHcnwYxn5PiPeIY3NOY1gZsLNiLsBAXN1egKGcuDe48d8DSSefdlHJvAg8aGghvk4ivopepoHKGXOZhucYEdenCJe6yIf/Hkg6+WR5eXhCDhT5+jTxpRym4dqWg+tjhCt02C/992AOrj8kXGoSzn8PJJ18srw8POm/7Tl8fYb4Cm2+Sf89lIPrasKlNu8Yrh05uK4iXFgf6+LfA0knnywvD0/6r5XD1zXE1w4oa1EZ1jud6BS90Bfr86BZV7L7dKLTqpBOC2BGoV769ySUoW8dFu+Mhg3+O+F9HQkTwz9EvBSkNzX47yR63D5OmOwSvIyIMhxXsQzp7BJ0FK7NFeKapPaEDge99n3tNPHySpXU4EnYFDxMwl6f4VSxRytpp6fimE2CXoPaNSjgEV8/wR+e8aQ+hdUS9RVuHE+9RMe+Sad91WEjhr+qC3AniR63j21kp+BlRJRx0kLZ4k5BR+G6r0JcfAl0yEYWVmQj/7J0ut6iOWgjJ1dgIxhDxdhIN5dJID7jB98h/qpsRMWyno1MCl5GRBlvrJ8UdCYFHYVra4W4Ym3krIps5NtLp+udXaONmLxjbcTgz6/ARjBujrGRbpJhiM/4wXeIvyobURfteDayVfAyIspwzoRlSMdbHEdc2yvEFWsjV1dkI62l0/V+ew7ayMcL2ojivY65l8pfHQW/QzLyLo47SrRHzfGOovaEdORT79P8hC46sPk7XwC/AXTkM46O8EYV5JkXVovOpQ+PpLO8SzrLBZ265+y8sFrXgudyorOlQjo4rowSna0V0kFfGXvhx2qyg21QpuzA8kX9BP+OpdP1bnPsIJSzxIXVTaIdTG99RqPLjUdyYdVw5cluY0XjzCEgu7sL+BCM6dnHozy2UBmOyZz3VflVfMc6h/UNbljUM/laf2Heso6FVcM/lHS2uUysFXvw09rXKkdvamF1UtBT/fCMRMu0Bb8NFy+sop/lzUroG7dTGfqzB6kM7ZsXVjfltInX0hR/3gabfQXvdcTxhn8o6bTRMrqVFy9yHL9F8KL65rPwG8uQjncxJ+JaXyEuW2OYzVhorEs6Y4LO3hILjRGdp0ss9LcFYqH04fHc4P90yXS9f5iBWOhHcyAW+nFFsdB9S6brPdGLhbxnj4mFdpSjNxULtQS9IrGQWtPeG2KhPsEfwqHtqXxSIt41HHpMY56o+0fEN5adRzSK5oDOE/zWmNfti7WvPSWvy2vo3eRiY2KevenQx3nwrqJNtH1eP2x26JVcy5tn9Ly9XUgv9aeDSWcfhvagqb1b2F8hmy+7n3JLDi5vPyWvA27NwcX7KUMbl7HssOyDnakf/u/vb4exvYAvB5iXZb/Vhn6Mp15LcOryky4v9Ii2Pf5IQskN8+5HEtSBw1Q390l8HcE+Cu0zVZdmxegs8hSjs0X7VG0qT+He4MDdK+AUrfTvCSgzHByLvznDkcr54iva24j1eW/yxDTpKXnhO+9whsEpOod3SefwSDpjXdIZE3SGRb1G4H+jw++YjpIN60UVdNThvLoPuo0SnbpyHZwbCB2iWvz+6fdsa954wYfe37Vkut67nA86hw51xh5AM/j3ZDRm4mK9kOzeR7IrewDtDUum6y11ZMe27R1wRXnw4TQcG3hvXdEDaOoyiKfLATTvgqc94QCaGuuUb+QDaOjP+AAa2jfnBtbltMn76K7VTQ9XvTD7PX246rhlV56y9PzlZy29bPlFF5647JLLl624rB8wq5GDPTx7YrwaKvQ06O95VDZB5YsEHD7eaNrlFQfRka/hH0o6e6GM5agTXSrK4Kt6sK66quJz8BvLkM59go7CtapCXKY3vas8O98xHe8qz3sqpIOj6BjRqesKgFGiU9cVVLGR3nUUreCx3ZhoxeD/Amb2X6BoBUcN3mmPV7wkAp4jPYO/mSK9klk3Genx6jv6utHsd9rOWyNkhz4tJLuHQHYrSXZIm20b5cT+BfubP4+DskIcWJYk/uq8ighmYNdCdKQ3E7sW1LUsXV59MRXpqchS9QNGeihTdRLXu8pzgsrUNRbKn/EVBWjfHOmtymmTF+nxeLNB0LGyu6BsNZXdLdqc2t1WyjQ1AW4D4bgTyu6iso1Qdjfg/9jy9ratE21Ttst2jXrMdq2ugDDZ3w+8sG9CvP0E/wj4pu+Qv/NOmafPPOJBZbBxdsIzWXVlrIdrnUNbzZy2OLTVlXfMS5KEbW0YaFmZyabLz2cOqM9n4oyJP5+p+knNGj1ZqX5SK2W8IqeuBPGuqVE+hv2PukZH6aeaWeJ4bP5GjfM4lvM4vykHL8vT2/GGeqF8g3eagf2GukHDy+4oXWe/oa5aV1fG82rQ31F8VnJlxr1qnfW7P9H6HbrO9Gfg2/4x4NsGCuL8IawiHA82miTtvsD6sUtf0K98Ado7+wLPB6dPUb/Jdot9w7FlbKaH7WxQwCM+Xsn5KfQBnxRCf8Sf4lYZae/aQG/elcr9eUt2/+Z4OP09CnA/J91Tp3PUiSo+nfMrS6brNbLfVfoNvmIW/QBn8NWYo/RMZQhxDOV65ge6zKhGzyN4t0u3K76xu12qWNFO/8VeaYvziLwdD+arZtqvoZxi/BrCm29RO9nYntFHsB9AH8H+416HnlqFRx/h+Ui1Y0TldTBmuY7yCGhfbP/q6sGyn9nlcSO0Kw/HbIT/1SXT9V63pB2n0mUvjlU7f3DXDq+AeaeCFa7NDm21m/ZBh7baTcu8JEnYJpUtmmzqmG9gXMC2qPpJ7bTzZKX6aYTgUTZFbZevu1afG/Kuwlb6mXeyhW1X7ZzBeGCmVntDY7fKASNejn2PWDJdb/GSdpzKP6uVUvYfCK9O6HjzdQ/XPQ5tT38VbfX5SeYlEXziJwiMlpWZbOqw3SrnB0pWqp/UqQG2wdiVZ7bP2JVnHHdZP/Nuq/TGXdzhwbs/1Jqhp3tqpwXaMeue2mmh7N/LrbHfQB1lv6FO47Gdoa4iPOcKDP6MJbv/73LHr8wV8CkXzGco/Q59qu5DS3b/n/bxsiUa50BBnOdkePJyBdaPdcTUaO/sCzwfnD5F/SbbLfZN6NOqiEvtQmU7G0x0zpI/1WrwK5bs/l/lCtAfcV4zdicM71VQu/FSuV+/ZPdvtd9hFOCuWtLebpXXR5/DumfwX1wyXe/D2e8q/QbnLVXOyBtzvNO1al1A6bP5gS7n0tG5At4dXjI34e4OV/OdKm49S//Ffl4acwV5JyK8XEGdfs1bD8mTK8/d1acvlY9gP4A+gv3HJoeeyoWhj/B8ZGzMgjt6F9N8A+3LWxdj+0d99+bWHDeok8dqzsUngZtLputtXtKOU+myF8fmzdc596nm6x4uL0+hTphud2gjX1iXaYdsUtmiyaaO+QbGBWyLXo4mfWJkpfpphOBRNkVtl29YVKfDlO1iDoz104vz04dtN5Q/tHhgpk6N89z6IeCF1+F5HED47Uum631zSTtOdbu4pxMtAY+noNlPhW6OCeHa5NCeFPAthzbyhXWZNvNp9ZTtmmzqsF20N7Zd1U8IHyMr1U/qxtAWlcWeYH+IymJPsG+HNrN+qvV/zNuz7ao9cuoWCeULPd3LG7NY99SYpeyf/QbaP/sN1FH2G9i37Dda2d+oqwjPuQKD//6S3f93eRu2zBVMEo87gAel3zy3Mvgnl+z+/6lPRy3ROAcK4vybDE9ersD6sY6YGu2dfUELyvoEfFG/yXaLfcM5HZV3QJlyrsBkNCjgEV8/wf94ye7/Va4A/dEO4j32Rg2OM9StPqncn7l09+/hpNN2RwHu35Ykbe1Gn8b+In1Y9wz+OUun6/17hrNKv7GVytAPcGytxhylZ2qtCMdQrmd+oMsb7aJzBa3s91DS2eYyuYIW0cO2pw/nCibL0ZvKFewU9FQ/YK6gBTSRvuHycgV1+jWUU4xfUzfXqJuI2Z7RR7AfQB/B/mOLQw99BMbi5iM8Hxkbs+D8/G/pliq0L7Z/tHG2f9R3jhtaUBa6dV75MB6zEf4F4MN+k2SjdNmLY3cJ+J0A8yC1B3V9VwSu7Q7thwX8Loc28oV1mXbIJpUtmmzqmG9MIgDgDfUTwsfISvXTCMGjbIra7iSVqZsgle22kuk2s356cX76sO2qr4BhPLCn5QpeD7Z7PMmmlUw/MbmCSQHfAhgvVzAZgcubr3n6q2i3oAzrMm3m0+rNpVxBC8pifKySVQtgOFeAds02OJO5AtbPqnIFG/fyXEELykJjPuoqwnOuwOBPz/qiy6/LyVzBTuKxBTzEzOsN/mLwbe8N+LbYXIHBL8nwzGauoAUA7AsmoaxPwBf1m2y32DezlSs4D/rAyxW0iPeqcwWfzvjIyxVcSrpXNlfwWdDny7PfdeYKWlDGuQIrSxJfz1SuwOCUPpsf6HIuHZ0rMPxDSWeby+QKJoketj19OFdQ0m9O5QrUHKcl6GGuAGWK9A3XXMwV5MmV5+7YxrK5ghaVlckVfJpsv6pcweqKcgUtKOO4AWXIccNO4EXFPIa3n+C/AD7sTpKN0mUvjq1ivu7h8nIFjwj4hx3ayBfWZdohm5zpXAHGBWyLXo4mfWJkpfpphOBRNkVtdyeV4fjeojLU7clkus2sn1XlCjgeyLv/guMmtcfKm5/k7R319hptozK1V5/poE/APrkm+817je7L5JEXUxvtLvV9ft37aPLmg3x2Bn0373lBGeN5JB4b8IzLpwp8YdC764HrYh8MBuB5P5nBPwJ9bDG7p8/e+a+i+qy+dltWn9E2rqK2GvzXZlafD5htfWadRX3mnJDS50bS6cO6yedcPQf1/3tPI/3/6zmu/5NQFqP/eTkS1n+M32ZD/88qoP+TDk2l/9a2kP4bPo77/19H/5V8Pf334s88/d9FZVhvfYAO6j/2O+u/wf9HpP4b7Tr0H2XE+u/Nm9Kn6FzHZKLid0//eb22Kv1f2OUXlj39t7aG9N/wcb58vzN2/6/0f1Lw4J1jLLrWhW3YSWVYb32ATiieZ/03+AOhrZ7+G+069L/K+WtenoHjebQNT/95naMq/X8t6T+ece/2HLt3d4W1Q53ZxHYbXj6z+ZIzoA1ntONUMZK6H9jgqzhn7uHy7DPvbgymre7GYF4SwafVq/H810Dd51qVrFQ/jRA8ykadK+Ez7rHnSry78vC8GOtnVWfcv//edrz35+BleXr3ESItZf8PUFmV59iVrrPfUF+tVGtvPN94W9YXdX61kvUb16JRv3ntzuBPB992TMC3DRTE+fbIcbaiu2r6676rJs9vst2qs2kN+htxqfUbtrPBRM91+V4Wgz9ZxHXKH/F9HOq+JuWP+Mwd2gyuRX8o44PP6Ka/RwHuPaR7Ze9ivBr0+f3Z7yr9Bt+Hpe468MYc7+uD6j4bpc/mB7o8Ax69Fm34h5LONpdZi469n65Lvzm1Fq3yhKofcC1anaFFXN5adJ1+zbvHJ0+uvDaMbWR7jr17h/2Hd/8e+giMxT9Etp93fw7HLPeIdqR4/yyLWeo4x672zHHc8CDwomIeHLMR/mPgw64j2Shd9uLYvHPmfH+QOmfu4fLO13tnRRVtdW6HeUmSsE0qWzTZ1DHfwLiAbTFvTTZGVqqfRggeZVPUdnl9W51jV7aL+ffrAuM2tkPds6HiARzz30Njt3fnHdq1N3/mOxXQrvl+GrXGgH4mdD/FrWC7d5Nsqr6fgudMRe+n8O7iy/MbTLt3P0U7vOqnmPsp0Hb53hm1RuPdV6nuTsI5HeunulsmdtzFu2VupFxB1fdAevfV8l5Rdeevt8aobMm7i4X9BseHDM+5AoNvUa4AdaTbXAGP43jmRuk3z60M/lvg23YFfNtAQZxfjswVVDSO99c9juf5TbZb7BueP6qxFGXKuQKT0WCi8xR8/7LB/0lkroDjBfRHHC+o/J3yR5greJJyBWi7owD3nYryVD8Fff4Lijeq8BtebM37VtWYo/RM7Q3EMZTrmR8wv4K6WEeuwPAPJZ1tLpMriJ27d+k3p3IFKg5X/YC5ApSpur/HyxXU6de8HGieXHnujm1ke/byiegj2H/c59BDH4Gx+JMR843YmAXnG5+hXIG3b8lbM/Puj1PzOR43QnuaQudkfw4+7MAz23FWfacW78MveqeWl2OfFPAth3bvTq12eNVPMXdqxdou5xhwfGe7Rt3G/eWsn3lrsmy7ao0Z4wGVK1iVtJcVzQcom+c4TcW+6rsDHPs+/8zpeq8g2VSd54uZr3u4vPlaXp6PaffyfO3wqp9i8nyroMz7PrZnn2zzqNs47rJ+VpUrOIlyBconeLqXt5+GdS/2DAn7jaL5AKXr7DesP1FXEZ5zBQb/pqwvLP4seY+UzBXsIB4xn6H0O3Qm+ETwbW8J+Lai54zfmuGZof3bhc+Cej44fYr6TbZbNcY36G/Epc6AsZ0NJjpnGTovsBD6wPvOHuc10R9xDkTd7a78EeYKLs744LlO+nsU4BaT7qm8Pvoc1j2DXwH6/K7sd5V+g/c4qZyRN+YoPVPrvDiGcj3zA13OpaNzBYZ/KOlsc5lcgbI/Nd/p0m9O5Qpagp7qB8wVqLkI4vJyBXX6NW89JE+uPHdXd74oH+GtYbD/8O7qRx+BsfjFZPvKR8bGLLhfYQHlCtC+2P6L5gPU3JrjBnWfrLqbiO+TvQp82KdINq1k+omJYycFfAtgvPs9JyNwdXPuybsvBOsy7ZBN1njfxEDdd+7m3anF8T/u/Z+ksljb5TvvVD5A2S7mwD4VGLexHSpfqeIBHPMX09i9p+QKbgDbvaOXK+igzXz2cgXtZTOZK7ijplzBSC9XUDhX8MAekCv4Bvi2bRXlCh7q5QqmymYrV/DYHMkV/DAyV/DNinIFPwZ9/tNersB7erkCotfLFcxOruCHNeUKBvbQXMG/gQ8bOqsdZyuZfnq5gvZ6vVxBMdutIlfA+llVruCbNHajjbPtqnsH6jiDgPs1QmcQnnXWdL2XkmyqPoMQc4e4h8u7ryAvT8G0e2cQ2uFVP8WcQUDb5RyDOgfUzRkE1k91X0HsXSN4X8Hj72nHmzeeFz2D4J1B8s4gsN9Q9w7M1hmEV2d9MZfPILwdfNvrAr6t6BmEN2R4emcQZu8MwlHQB16ugPMc6I+qOINwTsZH3hmE40n3yp5BOA/0+R3Z7yr9Ru8MQu8MwlPIs//31jMI6CO8s8tVnEE4h2xf+cjYmAXPILSymKVorpDtf6bPIFwKPuwakk3vDELYJntnEIrZbhVnEK4JjNvYjjJnEI4vOY9pEL8I790jmHefGs9P1H1x6l6kVQE6of0Kn85+8z1Mn4mMqSu6K2ffonflqPmglweJPZOuYiNeb0cZG828+extNJ9V+rLO4b+u+/fuBf4Nd5JU2rf7zOW+9e5B47lUVfcaXUdxQgPgziGaDUET33FMz/UVLuzHQ+H3IVCO8C3KK6D8C+jBwmGokwAOxF1SxxZiW+1RcwuMoxW99BkSZf0RvOw6rHXcyv889IAG1Tde+B3r8YCAP0fAm6wGiffRJOo5Ttm60bYybjuWob0aD6mNv4z4GyjJX4z8EP+IgF8EcEX64sCkXRdQ39U6Qsz9xXWsI6wGmNA6wlcgrv9uzesIq6k9M7mOwLR76wjt8KqfYtYR8D6xutcRvhsRf6+GdzzWrha8pngvrHkdgXUvdh0h5v7i2VpH+Ic9YB3h5+Db/rmidYR/6a0jTJXN1jrCvzvrCOiP6l5HeMGy3b/z1hGSZe3tLruOcNAyqJf9rtJv9NYReusITyHP/t9b1xFi70CtYh3hBWT7ykfGxiyYpzvLWUeIub94ttYRXgo+7PUkm946Qtgme+sIxWy3inWE1wfGbWxHmXUEjgdi5zEN4hfhvTNReXlhnp/E5oU3B+gUXUd4WyaP3jpCZ64ZZczrCKH57PE0n1Vn87x1BJXDRttifVE5bLUmtRn4N9wJwdWxjoDt4b6tek2Ocyc4R+J+V99aKeoT8nTh9e/Jx+vpgneuE9swX/DBsQbWmwD+DTfz36UuDCpdwPawLnh6nz4sG093UDZqnGE9mYAy/sbEakFHfYNjOOnUq9XQ1mdTzHgXwK0jmncJmviO53dY3+AUnYVd0lko6DAuzBNNAC6eVxv8H2Tjj82P7ga8BfTtbJa/4UDc95TE3SB8SaLns4ZfrS8aX0OiLGbtqv8rE5Nbz31ykedLvDyp8iULBbzJCm2pgKzO8MYXtXZ1D5WhXzAe1NrVvSX5i5Ef4h8R8EcCXJG+ULgWV4SL/Vi3uFaXxGXrc+gH7yZcyqeqvTvzRbuYr7tycJ1IuLA++7C7c3AtJlx3iTb2JZ1tRrjQWSOkPZx0to19WUk/2R/rywz/kGhDmdyckq0aa9Q4anVV7MY6r77rrL4prnCtrhDXKmrPKqjXCPxvdPgdr28jn8cRz8q2Vjs8Y32Oi1YJOtaeDVA2mv1OdXvtMs0P6v0G4IfjAoNfe8l0vTso3460ed8u8nx40s4L9kGfeMeyOTySzuIu6SwWdKrUG9WfhxOduyukg75pMdHZXCEdtLdRonNPhXRwXDyU6KwWPKQ6u4PsAO/ZUXZ5UvZ/P8EfC3aw07ED5BHrY6y1QbSD6X2F4vGScaBcWzZcebJ7jGS3AcqU7NiHGPzBILuvFfAhGFveTWVqjunt22xQWZJ05i7Sh3UO6xvcsKhn8rX+wpxHHWt2hn8o6WxzmbhA5XTUvN/at6Ucvak1O5UfVP2Aa3YoU5VXNhtTfnYDlaFv5G8Oet//Rfs+BH4jjVCbOJ5W/A0LXKxbMx1zbihHz405sX1lY86j4TeWIZ2icWIVuPhMwmzEQmNd0hkTdPaWWGiM6DxdYqFfFIyFeDw3+K9dPF1v3gd2/64zFtonozGbsdDQB9rbUjYW2giyGybZIW22bZQTx0JqfUnFSYgDy5LEX/cZEfVZbliPx6uSsUl0LGT4h5Ku9GNqvFIxohqvuoz1pmIhtbaq+gFjIfU9YcTlxUKcX0Df6K29hnKx6W+OhVbntMmLhVZDG9K/7VvOXwDbeXFmO8OC3ilJexnq7R3JNI5fI/sL5QqxDNuD79hWVE6yynHNeMb+4RxU0RgG6/O63d2CjrUHv7U9mv1O5fvKD2h+0GduAn7YZxr870K/H0p9puSs+pPjrqL9eXgkncVd0lks6NQdD3HcVVc8xDmouuKhUaJzb4V0cKzluCtkB8eSHeAZR2UHnIMy+P8GdnCcYwec87gP8CUC/tAAvUUUd5Ucx2XcxbmUkOxOJNndBWUxPsTg9wPZnVzAh8TmmbxvdfO+FpVrUXupvH35as+WybfLHE103GX4h5LONpeJu2LjIGvf1nL0puIudX+i6geMu1TeCXFx3KViCm9fm/JnnJ9C++a46+6cNnHcVTRO2VfwXkcOivdplMx5TemWioXUOOztGVF9wzmobtb676oQF+egcI2bY6F1gs46h87hkXTGuqQzJugMi3qNwP9Gh995+7Y4FrqrQjrYv2NEZ2/LQYXG82tpPFc5KG88N/g7L5qu90lnHheTg7pbtIPpfWYGc1Ah2f0Rye5uKIuRncF/GmR3nSM7724d3t/YW4/b/fTW48LrcWqflfKNVa3H3ZXTJo6F1P5dxtUP71TOiecdGzL7Sm1tHeWs0M6Ndgr36rPb4XpxWHtd1fe/D7+xDOnExk7rK8TVi8Om6fC7InFYXfHRGNHZ23JSdwkeUh/z9YicFPpPjiUM/jchlvimE0vE5KS8OMzg/58ZzEmFZPftiDjMk53BPxNk990CcVgvJzXNJ75D/L2cVDgn5cVhcyEnpfhjXLFxmME/QX6jZNwk/Qae6eT2sv734rXdz5EAx2VFY6wNFeLqxWvTdPhdL16rhk6ZeO3As6ff4xhUNF7bfOF0vWdnOOuM1345ozGb8drzSXZl47XrQXYvJNmpc8RKrt7+LI7XUFY8DhbNm6n9zk+XvJkar/bUvJm3hsgxmbqTIiZeqyJvFpvjYpqhuO5dVG7wrz97GufrKG+GfG0C2jt6+bW9Jr9m/Tpf4OZ4bb2gs96hc7jgWdEZ65LOmKAzLOo1Av8bHX7HdJRs2E6roIM2P0Z09rZ1zlDMcSr5N7XO6cUcBv86iDne7cRrVa1zLqF4rc51zpDszqgoXnseyG6ZIzu2bRwb2b/01jl3P711znC8hn6W82voG6ta59yU0yaO15C/TQFcsXGYwX+Y/EbJOEb6Dd6Xhvyw/m8qRzc6XjP8Q8RLWf1XfafuieBYFevyHC99jgQ4LvPiQjVf3FAhLi+O6sVr7XS8eG1DhXSwf8eITl1x4SjRqetsQ2y8dhPFHOqsihdzGPy2C6br3erkiDifsxnwJQL+0AC9VeR3S96tJv0u36MWOhu5JjCXjz0bafC3gOxuJ9khbbZtlNMGKsMxlWO5KvfeYv3Q/XNWnj5d3p8WHa8ZfnXfXZnxSt1fp+6P6nL+MBWvqbhZ9QPGayhTpG+4vHiNz0aq88zKn3nn5TheW5/TJo7XlO6rHBfe8cQ5LjUu7SvaWKCP5sfqoOEfSjrlXUYH1T0barze///++7Xs9+WXLT9/+WVXHrPsskWXn3H+8jOPW3bliiMuPGvR0ksvW770/CPOOuvSZStWINNI6AB4j+X4MIz9nhDvEcemnMawMmBncfB+Vw6uEwkX1o858Iq4Yi7h478Hkk4+F2X/z4vAg4YW4usk4kstvnhOHpXzWsKlPvTkOUbE9SnCpS655L8Hkk4+WV4enpADRb4+TXwph2m4HsjB9THCFTqknv7bkoPrDwmXmoTz3wNJJ58sLw9P+m9rDl+fIb5Cm2/Sf9tycF1NuNTmHcP1YA6uqwiX+mAb/z2QdPLJ8vLwpP+25/B1DfGFH9vYTmVY73SiU3SShvVnapJ2OtHZXiEd/BDJKNRL/8aPZaBvHRbvjIYN/vgRijoSJoa/qgtM1Yc3vAtMW4KXEVHGSY6WoNMSdBSuTRXieojaE5qE/ZwmYWUvqPkETMIa5+z+rWIP/lilimPUBaMNateggEd8/PGcwYwn9eGz7aK+wo3jqZfoqOIDVYjP+MF3iH8o6dSfMjaiPmiH7WMb2SF4GRFlnLRQtrhD0FG4NleIiy/PC9nIc85pp1nWRi4GG3nuHLSRX6nARjCGirGRbi5BQnzGD75D/FXZiIplPRtRH30cEWW8sV7ZovpQlMJ1f4W4Ym3k5RXZyGlgI79Zo42YvGNtxOBfXYGNYNwcYyPdJMMQn/GD7xB/VTaiLojzbOR+wcuIKMM5E5YhHW9xXH0cuQpcsTZyZEU28lawkaPnoI0cV9BGFO91zL1U/uoo+B2SkdLdEVGfF1bXCzp5OnLyOZofpSPpb5u/88L6K0FHTnV0ZC4srC7vks5yQWdv2Qi3nOjcVyEdHFdGic79FdJRH4HOs4MLyA7UBxKxruWL+AOJf3L+dL2LHTsI5SxjL501+MszGl1uPJILq4YrT3YfrGicuQdkd1UBH4IxPft4lAd/8BDHZM77qvyq+sjsiKhvcMOinsnX+gvzlnUsrBr+oaSzzWVirdiDn11+FHxqYVXNJVQ/4MIqylR9QNtbWN1AZegbvQ/R84dx0b5jLuBXH8ie7/DnbbCZrU1mJRdo3U1m2D6O4+8TvKi++Sz8xjKk410ojbjWV4jL1hh6m8w6383FQwFPl1hofYFYKH14PDf4k2E83zQDsdC9cyAWur+iWOgwkN3WXizkPXtMLPRgOXpTsZBawy4SC6k17b0hFuoT/CEc2p7KJyXiXcOhxzTmibp/RHxj2XlEo2gO6DzBb4153b5Y+9pT8rq8ht5NLjYm5ulyA2N0PD4TGxjPg3cVbaLt8/phk0Ov5FrePKPn7e1Ceqk/HUw6+zC0B03t3cL+Ctl82f2U9+Xg8vZT8jrg/Tm4eD9laONyG19ZUjH1w//nnHYY2wv45DnTME9kv9mmUA5P7SUhOHX5SZcXekTbHn/cp+SGeffjPurAYaqb+yS+jmAfhfaZqkuzYnQWeYrR2aJ9qjaVp3Dzlofh7hZwilb69wSUGQ6OxQcyHKmcL76ivY1Yn/cmT0yTnpIXvvMOZxiconN4l3QOj6Qz1iWdMUFnWNRrBP43OvyO6SjZeIcwy9JBHRsjOhsqpIN2M0p06sp1cG5gveAhtZkXLJ9+z7bmjRd86P3Pz5uud1CGU+3R57EOL9ZLBPyhAXq/mtGYiYv1QrJ7KclOHUDzZGfwD4Lsft2RHds2+v7VVIby2EBlODbw3rqiB9DUZRBPlwNo3gVPe8IBNDXWKd/IB9DQn/EBNLRvzg2szmkTxxtqLE8PV70w+z19uOq4ZVeesvT85WctvWz5RReeuOySy5etuKwfMKuRgz08e2K8Gir0NOjveVQ2QeWLBBw+3mg6W59hnihHz/0Ms4oy+KoerKuuqvgc/MYypFP008lV4OJPVPSu8gzT8a7ynKlP4NR1BcAo0anrCqrYSO+9FK3gsd2YaMXg3wvRyhKKVnDU4J326wFfIuA50jP4ZRTplcy6yUiPV9/R141mv9N2nh0hO/RpIdmNgezOJdkhbbZtlBP7F3Xtj5qxIw4sSxJ/dV5FBDOwayE60puJXQvqapwur76YivRUZKn6ASM9lKk6ietd5TlBZeoaC+8KHeWDYiI9bFNMpGe61RR0rOxOKFtFZRuhzPCndvcxsjv8BPSZ1A4rw3bgO7aRMwU/is6a7Hc/tfFL5OtKXvP05mGiYzgQ97qSuGPtMhQ3IF9Doqw/gpefPmvsN55o/uRLDapvvPC7eYAfdRnhzxTwXY45bxgGGgnRtjIcD9dR2QCUGQ9p1vJlxF/JlaE3xMhP2T6W8acoi8aaiGtVSVwHJu16hbZj9teEsrXZ7+Gk06bZTkraYPR8y/APJZ0yKDN+Kd+rfBb7CKw7Isr4Kt41gs4aQUfhalaIy8YA1c8832oKOk2HzuGCZ0VnrEs6Y4LOsKjXCPxvdPgd02kCzGxl1tdUSAf1YJTorK2QzlqA4flWaM6wjeYM66AsZs5g8D84d7reQ07sgjxifRxfVol2ML1dFIOUHFvkfIt3V4Rk9wjJbhWUxcjO4B8G2T3qyK6ZtJep663UfGsNlWGcwDmlovMtrP90m2+pMd7aV/Imj6n5lspHFplvqZuieL7VBJhVVKbm0cqfccyF9s3zrVU5beL5VlPw14uF4mKh9DkS4LisaPxyR4W4mtnvXizU+a4XC1VDp0ws9J8VxULLYDz/+QzEQn0ZvdmMhQbObW9L2VjoWJDdvtlvlX9rJu1lKCeOhVROR8VJPK8veioJ68/ADt3oWGgmduiq8aqKE4Hpv7ybO1UsFNqVyOvlys9y7lntBlT+bB2VebHQRE6bvFiI190xb8yw48l0exH2ILCzo84N07qN+BiHstupLNY+EQfKF30Fwl9GbTD4l2Z8p7nGFVdonPMSraPmf1Tu09qxL9C1sgL6O5ny9e4rpumgvqTPQNLOM45/Xkxl8LcJeNQ5jg1vgzKO55Q+Ynxh+qjkZTzWIS/kIUZeag0sVl5s9yivOwmXin9Rhp68jMc65IU8xMhL7XGJlZfJQMlrI+HKm+MsIHjDPZhon8C7pg3+reAT+FaeJtTnvh4XuNE3NggHtmNItGOYyrBuivcl2XWoM5Xn4VhT3biD/hv3QSD8O2DcOINko8Zpb31L5Ti8naQ4jt8dgWuVQ9v7FKCijXzxHhnem6PiDeUHTDZd+oEB5QcwX8V+QPWTOvHkyUr1k1pz571xTSjzck58s0JszglPWpwRmJNgO0I+m+0B5zM811HzBE/3VPyMdsy6p3Ksyv6bVKb21ShbYr+Bfct+o+xO+ItpjlrHTnjW7/5E63doh/vvgm9bEfBtAwVxXgHj0fFgo0mi19u79AX9yhegvbMv8Hxw+hT1m2y33v5VtW6OMuWYwGQ0KOARH+/N+2hkTODtLvdy4N68z+whlfuqjI+8PZDXku6hT1NzxdBtDmtBnz9Jc7wq/MZaKlN7tLwxR+mZ2r3Pn032bmwvue88OpfC+867vbE9dp2nik8up//UyRnVD5hLyTu9ab5qpv0ayinGr6m1JrWHkO25CWXsB9SeV7UWw/TQR2AsvopsX/nI2JgF89f/SXlotK9m0l6GNs72j/rOcQPKkOMG9ck49EH8iXOD3wA+bJJko3TZi2PVHlb16W11Ou3eCFwbHNrqtPy9Dm31eXrmJUnCNqls0WRTx3wD4wK2RdVP6pyKJyvVT+oWmHuprAllnu3yCTEc39muUbfxJOpkYNzGdqgcb97p9Gtp7N5TcgVfBdv9fi9X0EGb+ezlCtrLmlBWd67g+zXlCniPWC9XMP07lCv44R6QK5gHZ6R+XFGu4IlermCqbLZyBf81R3IFo5l+5eUK+s9rb3fZXMFLQJ/3yX73cgXy6eUKiF4vVzA7uYJRsv2qcgXb9tBcwcvAh72ZZNPLFYRtspcrKGa7VeQK3hwYt7EdZXIF/TR2I998Xl/ZlLJ5Pq+/SciC+y+UKzC8/QR/DNju6SQb7+vR6VPUfnjOpOzHw7Xaoa1uRLrPoY188Q3sbMvqDH2N46i0XbRPtl3PZ6ZPjKxUP6kbcPmmXZX3UncH8C1ROA6xzaNu47jL+qn2NsWOu7jXiO/v2JCDl+XpfclCjRsqh+KdEVP2z35D3dqmdJ39hvUn6irCc67A4M/J+qLLG1dlroC/EID3Vij95rmVwf82+LbzAr5toCDOCzM8ebkC68c6Ymq0d/YFng9On6J+k+0W+2Y14VL2qG5wYzsbTHQMwXsNDf5K6APOFaA/4jhD3TSp/BH7MXWfUir3myhXgLY7CnAfId1TeX30Oax7Bn8r6PPHKd6owm9spjL0A3wzpxpzlJ6pm/9wDOV65ge6vCkxOlfAt9h3e5Nz7C32VdxUnf5TXwwO3RytZKpuMvdyBXX6NW89JE+uPHfHNrI9o49gP4A+gv3H3Q49Nb9DH+H5yNj5BsYs76VcgcqxKhtn+0d957gBZchxw/3Ai4p5cMxG+DXgw7aQbJQue3GsutEfb+PndRjva78Kl5enUF/J2eLQVl/JYV6SJGyTyhZNNnXMNzAuYFtU/aS+oOHJSvXTCMGjbIra7v1UhuM72zXq9n3Q5i2BcRvbofKVKh7AMf8jNHbXfYtzaOwO5fkML8e+u8B2v0WyUf5Z3YDM/gPh1Zf3vPm6h8tbH/P0V9FGvrAu02Y+rZ6yXZNNHbZb5fxAyUr100jSaddsgzj/9tbx2D7RjrwbpXHcZf3MO8vqjbu4rsy3unv7LtKH5enlWZXuqRvUlf17uTX2G6ij7DfUVzbZzlBXEZ5zBQb/N5QrKPklH5kr4K/XYT5D6TfPrQz+P8C3/X3Atw0UxPlPkbkC68c6Ymq0d/YFng9On6J+k+0W+yZmL5j6ugzb2WCic5a45wXh/9XJFaA/4rwm+iPvhnveO6W+spHK/bnn7/7NazHp71GA+1lg/Qx1D30O657BP//86Xq/oHijCr/BeUuVM/LGHO+ruWpdQOmz+YEu59LRuQL+6lPJ3IT71Sc13+nSb07lCtQcR/UD5gryvnTm5Qrq9GveekieXHnujm1ke0YfwX4AfQT7D28fg8qFoY/wfGRszIJrni+gXAHal7cuxvaP+u7NrTluUF8UVnOufoJ/Mfiw15BslC57cWzefJ1zn2q+7uHy8hTqy7FbHdrIF9Zl2iGbVLZosqljvoFxAduil6NJnxhZqX4aIXiUTVHbfYDKcHxnu0bdxhwY62fefgq23VD+8GdOnr+Or0Hz3Hob8MLr8DwOIPxbwHZPJNnYl4mTJE4n1JeQ8evG7KdQJ7ZH4PL2BD0k4Lc7tJEvrMu0mU+rp2zXZFOH7aK9se2qfkL4GFmpfhoheJSNlcV+mXoblcV+mXortJn1U63/Y96ebVftQU7x8tfhlS/0dC9vzGLdU2OWsn/2G2j/7DdQR9lvYN+y3+AvjjM85woMfknWFxZ/oo50myt4iHh8EHhQ+s1zK4O/AnzbmQHfNlAQ5wcyPHm5AuvHOmJqtHf2BZ4PTp+ifpPtFvuGczoq74Ay5VyByWhQwCO+foK/BPqAcwXojx4k3tEfcQyicsfKH2Gu4POUK0DbHQW4D5HuoU9jf5E+rHsGfwPo89XZ7yr9xv1Uhn6AY2s15ig9U2tFOIZyPfMD5ldQF+vIFRj+oaSzzWVyBcr+cHzgXEFJvzmVK9gh6Kl+wFwByhTpGy4vV1CnX0M5xfg1hOe5O7aR7Rl9BPsB9BHsP+5z6KGPwFj882T7ykfGxiw4P1+fxSzKxtn+0cbZ/lHfOW5AGXLc8BDwomIeHLMR/hbwYXeRbJQue3FsS8DvAJgt1B7U9VYErq0O7UkB33JoI19Yl2mHbFLZosmmjvkGxgVsi6qfED5GVqqfRggeZVPUdh+iMhzf2a5Rt7dDm+8KjNvYDhy32Xa3CF4xHtjTcgXbwHa/QbJR/tnLFRSdr6MPeygClzdf8/RX0Ua+sC7TZj6t3lzKFah+8nyskpXqp5Gk067ZBmcyV/CNmnIFH9zLcwUxYz7qKsJzrsDgv0e5AtSRbnMFO4hHzGfEzOsN/gnwbX8Z8G2xuQKD/6s5kCtAe2df4Png9CnqN9lusW9mK1fwo8hcAec1q84VPOOC3b/zcgVPVpQreNYF0/V+OgO5AvQDnCtQY47SM5UrwDGU65kf6HIuHZ0rMPxDSWeby+QKlP15uYKSfnMqV9AS9FQ/YK5AzUUQ11zMFeTJlefuKqdZdL7B/qNMrsB8hOcjy+QKLqgoV4D6znEDypDjhh3Ai4p5cMxG+OeBD/sNkk0rmX5i4thJAd8CmJj5uofLyxXsFPCTDu0WlGFdph2yyZnOFWBcwLbYgrI+AR8jqxbAcPy/E8omqSzWdndQGY7vbNeo25gDY/2sKlfA8UDed+05blJ7rLz5Sd7eUW+v0QNUpvbqMx30Cdgn12S/ea/RYZmc82Jqo92lvs+vex9N3nyQz86g7+Y9LyhjPI+E/YY4U95PprEBc1G8J8O764HrYh8MBuB5P5nBHwN9fOoVGify4J3/KqrP2IZu9Rlt4ypqq8GfMLP6fMBs6zPrLOoz54SUPjeSTh/WTT7nyDmo/+97Gun/sjmu/2ou4el/Xo6E9R/jt9nQ/5cX0P+HHJpK/61tIf3HfCLCX+7ov5Kvp/8tAY8y9/S/RWVYb32ADuo/9jvrv8H/VqT+G+069L8FAKz/k1DWJ+CLznV4TQDjd0//W0SnKv1/TgH992Jvpf/W1pD+Gz7Ol/+Bo//KBr1zjEXXurANO6gM660P0AnF86z/Bv+5SP032nXof5Xz10kB3wIYjufRNjz953WOqvT/52fv/q3OuHt3OMacY1dnVfh8oTqzqc708ZnN1ZAbeoDm3ipG8u5IrGLO6+Hy7DPvbgymre7GYF4SwafVq/H810Dd51qVrFQ/jRA8ykbZFp9xjz1X4t2Vh+fFWD/VGfdY28Uz7mvObsd7Tw7eone48h006g5XZf/enRAx59iVrrPf4DuQGJ7Xog3+y1lf2PoG6kgBXZdr0XxXDZ7DV/rNa3cG/z3wbY8FfNtAQZxfixxnK7qrpr/uu2ry/CbbrTqb1qC/EZdav2E7G0z0XJfvZTH4b4u4Tvkjvo8D/RGf3Vd3zSp/hGvR/0Fr0Wi7owD3fdK9sncx/hfo8w+y31X6Db4PS9114I05Ss9GRH0cQ7me+YEuz4BHr0Ub/qGks81l1qJj76fr0m9OrUWrPKHqB1yLVmdoEZe3Fl2nX/Pu8cmTK68NYxvZntFHeHfvsP/w7t9DH4Gx+H+Q7efdn8Mxi/rGU4r3JppvePe2Fz3HrvbMcdywBXhRMQ+O2Qjff+F0vV+6sB2n0mUvjs07Z873B6lz5h4u73y9d1ZU0VbndpiXJAnbpLJFk00d8w2MC9gW89ZkY2Sl+mmE4FE2RW2X17fVOXZlu5h/Z/3Mu3ecbVfdo47xwHxB3xu7vTto+E4FtGu+n0atMaCfCd1P8SKw3VeTbKq+n4LnTEXvp/Du4svzG0y7dz9FO7zqp5j7KdR9Lco+Oceg7k5RdyfhnI71M++bYt64i3fLnEG5gqrvgfTuq+W9ot79kbHjuncXC/sNjg8ZnnMFBv/WrC8s/kQd6TZXwOM4nrlR+s1zK4M/FXzbUQHfNlAQ57EZnrxcQUXjeH/d43ie32S7xb6J+VYRypRzBSajwUTnKfj+ZYM/CfrAyxUUiRdU/k75I8wVXJHxwfnc9PcowJ1Oulc2T3Ul6PN7s99V+g0vtuZ9q2rMUXqm9gbiGMr1zA+YX0FdrCNXYPiHks42l8kVxM7du/SbU7kCFYerfsBcAcpU3d/j5Qrq9GteDjRPrjx3xzayPXv5RPQR7D82O/TQR2AsfkXEfCM2ZsH5xqmUK/Dufo49J8txg5rP8bgR2tMUOif7EfBhnyPZVH2nFu/DL3qnlpdjzzuj690z1LtTS/dT0Tu1PNvlHAOO72zXqNu4v/xzgXEb26HWQlQ8gGP+6TR2q2+Cls0HKJvnOE3Fvuq7Axz73gy2u6nmPF/MfN3D5c3X8vJ8TLuX52uHV/0Uk+fD715wriDWPtnmUbdx3N1UU67g+ZQrUD7B0728/TSse7FnSNhvFM0HKF1nv2H9ibqK8JwrMPiHKFdQ8h4pmSt4kHjEfIbS79CZ4D8D3zYZ8G1Fzxk/HJkrqGj/duGzoJ4PTp+ifpPtVo3xDfobcakzYGxng4nOWYbOC/yxkytAf8R5TfRHnANRd7srf4S5gicoV4C2Owpw3yLdU3l99Dmsewb/r6DPf07xRhV+g/c4qZyRN+YoPVPrvDiGcj3zA13OpaNzBYZ/KOlsc5lcgbI/Nd/p0m9O5Qpi79/DXIGaiyAuL1dQp1/z1kPy5Mpzd3Xni/IR3hoG+w/vrn70ERiLP0G2r3xkbMyC+xUOpFwB2hfbf9F8gJpbc9yg7pNVdxPxfbI/Ax82clE7TqXLXhybN1/37veMuVOrm3NP3n0heXdqKZus8b6Jgbrv3M27U4vjf+9OrVjb5TvvVD5A2S7mwFg/8/Zssu2qb5RgPLCn5Qp++aLpei8n2fRyBZ189nIF7WUzmStg/awqV/DtD7Tj7eUKpn+HcgVvyPpiLucKFoFve3PAtxXNFYxleHq5gtnLFRwHfTCbuYILMz7ycgUnBmKOormCS0CfT85+93IF8unlCoheL1cwO7mCC8n2q8oVfD2LWfa0XMGHwId9spcr6KAdsslerqCY7VaRK/hkTbmCE2ns9nIFyJs3j+j2DALuyQidQbgObPc2kk3VZxC8/Y91n0Hw9l71ziD4d/t5ZxC8XAGOc1WcQbgtIlegzhQOJ532gLmCP6JcQdVnELx7R7wzCOw3vPzDTJ9BuI9yBSVj+lrPIHwNfNuWgG8regbhwchcQe8MQqdMqzqD8JXIXAHnOVTuvJszCP9EuYLQGYRvkO6VPYPwI9DnP6F4owq/0TuD0DuD8BTy7P+99QwC+gj2A+gjqjiD8E9k+8pHxsYseAbhWsoVxOYKvfW6mTiD8CT4sH0ubsfZO4MQtsneGYRitlvFGQTWz6rOIHyDxm61hjnT+wrU+UyOfQ+8eLrer5Jsqt5XEDNf93B5dxvmrY8x7d6+gnZ41U8x+wowJ8b7EareV8D6qe42jB138W7DEyP2FXi6l7evwLuTxNtXwH5jLu0rOCTri7m8r+BY8G2vCfi2ovsKDsvw9PYVzN6+giOhDzhXgP6o7n0FH8j4yNtX8HbSvbL7CpaDPi/MflfpN3r7Cnr7Cp5Cnv2/t+4rUHeZ1bWv4ANk+8pHxsYsuK/gWGdfAdv/XNpXcDH4sI+TbHr7CsI22dtXUMx2q9hX8PHAuI3tKLOvgOMBdd+p8gkN4hfhvfmJ8jnenYkqFlLrnDHfV8C2nZT9z2s/n46Mqetci0cZdfvtgLz5IN+1q9ZrlL4bTTU24L23r6SxoQFw5xCvjaST14Zo20igvsKF/XIo/D4EyhF+I80lUZ4F+nXhMNRJAAfiLqkzC7Gt9qh4EmMnRS99hkRZfwQvuw5rHbfyPw89oEH1jRd+x3o5IODPEfAmq0HifTSJeo5Ttmu0rYzbjmVof8ZDarMvI/4GSvIXIz/EPyLgFwFckb44MGnXBdR3s9cNULaKypT/rWOf2WqACe0zuw9iucdoTKt6n9lqak/RfWYbHNp5eWum3dtn1g6v+ilmn9kqKNtAZbFxXuw+M9bPDaIdq+Fd7DethiL2mXm6l7fPjHUvdp8Z+40q88psZ0X3mX2bxvu5uM/sR+DbvhvwbUX3mf2vyDi3t8+sU6ZV7TP7Byd3jP6I897oj6rYZ7b/Jbt/5+0z+3FgvbroPrP5l0zXe4Jyx1X4jd4+s94+s6eQZ//vrfvM0Ed438ioYp+Z+QjPR8bGLLjP7BfLdv9WNs72X2VemceNovvMngM+7L+TbHr7zJKgTfb2mSWFbLeKfWasn1XtM/sxjd17Sq7gELDdo0g2vVxBJ5+9XEF72UzmClg/q8oVPLasHW8vVzD9O5QrOCnri7mcK1gOvu2UgG8rmis4LcPTyxXMXq7gLOiD2cwVfCIyV3BeIOYomiv4fdDnC7PfvVyBfHq5AqLXyxXMTq7gEzXlCnbsobmCz4IPW9XLFXTQDtlkL1dQzHaryBWsqilXwPHAaoF3g8DbSDr9UMw+s3sEPMrDaKn7dDgmwHqrAnRUDiJ9eJ+ZwW+MjKmNdh36jjJifc/7dnLRfX08v0Y94XtdUMZG03jeIHCmvK+lseFOgLsjaS/bCGXrqAz3sfG31vAcJfKBbUA9aAKM4e0n+BaMDX9KNqJ0fiO8K6rzTWqP0nkP150ObU9fFG0192BeEsGn1VO2YrKpw1bwfh62FdVP3n0+Slaqn9SeYN6TeQeU3Ull3t1J+K01PmOJuo1nE1k/7xTtaMI7HhuagtcU7yPvbse7SeD1dM87e6l0b6Non7J/9hto/+w3vG/Cq3GH7Qx1FeE5F2XwP6BcFOpIt7koznFsBh6UfvPc3eB/Cr7tbwK+baAgzr+PHDetH+uYs6G9sy/wfHD6FPWbbLfYNxsJ10aBC2XKMZXJaFDAI75+gn/CyUWhP+K95eiP+Hz2ekFX+SPMRT3n0t2/1R70UYD7d9I99GnsL9KHdc/gn3vpdL2fUS6qCr/BMSn6AcQRGnOUnqm7K3AM5XrmB8yvoC7WkYsy/ENJZ5vL5KKU/al5Qpd+cyoXpeJe1Q+Yi0KZIn1cr0yfmfZrKKcYv6buIFbzS7Zn9BHsB9BHsP9Y79BDH4GxuPkIz0c2BV4Vs2wEvNuymEXZONu/d1cr6jvHDShDjhswL6ZiHhyzEf4g8GGHkGxm415KD1fd91wwL0kStklliyabOuYbGBewLXpz7fSJkZXqJ3UGjPNNsbbrfZed7Rp1G/MprJ9V3bHC8cCtAu/+Aq/BNwFXH+FIf1+T/e4n+Ndn7cHY1XCOCx6G4B336YSAHwcY42d+0unHJqgM692Y/Vb6bnBd6vsBSt+xPazvq6CsT8CzbFRuEXNK1rcjBI9ysrIbocxoDhMelHfK+49Oa+cnr29Zv1YCLtW3n8h+9xP8cY5+KX25Gd6xDD2ZIz/ziQesO1/Ua2a/lX4ZXJf6NV/pF7aH9cvTl/Rh2awR8KhD1rcjBI9ysrImlBnNYcKD8k55nzilHQ79VyPwv/HK73iegLgWET/NCuk0AeZQonMLlI1mv9N2L6XxAGXSJ+p+NPvdT/AfhhjorOz3fFG/SfWt7GywsyuuCNdnH4xjxP5U1oQy9DmhdiL8JwLtvAD4XOHkSoyvLu1uRNndOADE+HWEL+rXm8ZI0mmTtxCuWwSuJrxjn2wyGkx0Hxi+foL/EPQB50pw/Bgn3m8syLsaT5QfsbppX5yR+REVB6wkmuOCpuqrEVF/PIBrnuAf7Zb7vS/R4yHDm05gvlL5536Cvwb66sorNM4kwMMtAZ4HA/CriAeD/z2hL54fQP2fIJwG/weA8+iCOD8ewPmHTqyh7HQlvCs6nnI8gXJcQ2XIO4+Lq4E+w/4u0ccy1HOmmzj88piax28z+816uQbGqxuz3/sSvoK+us/rq3cLfmP76hanfYzL6vUnnfro2QjKY/xSjXOgIM5VYkxXscohgH9NIB5JH45H0of9MvoMtMOlFJM0AW5/4t/GiXXCHtVYb7i6G+sb/1uN9TcCBI/1SjYIzz5hpYDHfuQYG8eb36QyHGc5trpR0IkdS2+Etr7+lHa8TQdv+vsi4gP7X8UXH8x+sx/e5vhhJUNP5mqOiHJtZr+VH+acQhPKTP4zrY/YftZHr63pU3Q+zPqoxg+ljxxnNQWdWH1sQlsPptgOeeW5xyqHn7yYe4jgzccPBuDZ5xv8N524Z63gYRzecV/dJuDXCp7nEw9Yl2mH9nctpPYY/Lci/XFFOY8Dlf6j3Fj/PRmlD8v0dgGPsuL9XbdD2RoqQ/1fS2Uqj+TZbKxtWN2n+pF89XgkXvarofwc+2qD/7uC+TnPV9eVn/N8dZ26Olfzc6irsfm5J09u56cp+Nnf4V/pY1Pwr/JK3O9Y79Ykn6+m4EvNY5oOnSO6pHOEoFN3DvIIas94Em6P6p/xyPaMU3vGK2yP4jkvp7rviun3Id+Gcxge7wz+xSum6+2f/fZyqkV19+aknc9xkIHy2Scm0+1PkjpiTr1uO5Mxp8lAxZwxOUPUPRw7DSYhHuuQVxMBknaePT+YPkXXRE0GI0mnLG+lMtS3JtGpKv/61ZPz+b/VaW+efnAuZg6t0c16DMC6UHSNjv0l0lH+kvsY/Sv2y0ez3/0Ef0jmU1XsqPTA05u8OZ3xo3RjNZWpPH+NPmRO680ElaHvKao3Xq4Qx2gbv70cWSNpHyeb8B7hQ+srTcLToPf7wXus99tJe5utLAF4xP0/CN7aORiAN3wciywAWznVyYkpnB8hHiZyeFhJPBj8QsGDJ//08WLCfZNOWyxgN/0Nwmf84DvEP5Ro/RhNop4Gy8/oKT1IH7ZlZU9qrcTzgcrOFa79K8RlcYOKYQ8nOk1Bp+nQwfpNh85Yl3TGBJ2651+HE52JCumgzYwRnVUV0kE9GCU6qyukg+MR7525VfCQjhMX0DxvDZSpmIHPQBj8vZdN17uY5nnjQBt5xPo47o+LdjC9yzMa5v8wj1vAH8lzToYrT3YfJNmNQ1mM7Az+CyC7qxzZNZP2MhVjzE865cExPeZnee1V5X/xHeucypEPi3o8XmEeuMhcMcY2EP9Q0tnmMuOVynNjTMjnR+4oR2/q/Ig6Q6n6Ac+PoEzV+U+zMeVnx6kMfeNtVIb+jPP0aN+HwG+kEWqTxbbzHf5UHIqxm8q3sO7NdKy0shw9N1ZS+aGisRLKEMuQzlyIlZBPjpWUTo07dLD+uENnrEs6Y4JO3bndXqwUT6dMrLSholjp9TDe30XjPfqKmFhppWgH07tvDsRKD0SsJ3iyM/gXgOy2ObIbT9rLerHSNJ/4DvH3YqVwrDQOMJwHriNWWpnTJo6VFH8q3kmf0STuiYmlsH0F+u5Fsbpp+KuKpVRcomIpa9/qcvRGU13bL6vXBByXwm+1/wn7q6r+a8K72e6/Zjl6bv814V0d/Ye2VaT/lG0eBr+xDNszLtozIuobXN1x5WFEJzTG/z2N8WpNC8d43jNg8D+FPQP/RGN87L6AW4BnbrPBdbnm1Ff0XJO3dzl9iu675f1K3rq12lPeSDr7pOi6NZ5vXR9Yt24A3o+KumzbCD8h+DB4sznbU8owVpf39P8M1mAWBPbboc4iXx8lnAb/C2cdVq01VnnuBeXM50iwnvW7sgmD69ImXqRsAtvDNqH28KpY0eDz9vCy3mMsO0G42L7SZ6HA5fHa7IJX7kfsK95vbLCol9ge1kuDPzCbL+XtNzaZ19H/3jq8kqm3Dp8nU853eXuRx6EsZk8x+kn2ibcKHnBMnKk5KucMbgde+gSvhref4F8C8+zXXtaO0+ZLSRJns2p+hnMuPg+Nc7M7I3B5vnSdgL/ToY18YV2mzXxavRptS+6Tw7k225bqJ4SPkZXqJ3WvC98xOQ5l3nz5diqLnS/fBm1m/VRxVqztYl6Kc1bKV3m6FztWeedNlP2z31BjnLIl9hvYt+w3OA/C8JxrNPi3ZX1h8y/UkQK6LnON64jHO4AHpd+cQzT408G3HRPwbQMFcb49cpy1fqzjnja0d/YFng9On6J+k+0W+ybmbDDKlON6k9GggEd8fLbqZOgDvlNhHOrfQbzH5u/4vJJaQ0jl/qGMDz5vlf4eBbj3kO6hT2N/kT6sewZ/Nejz+7PfVfoN3tuJfoDjVDXmKD1T8RmOoVzP/ID5FdTFOnLihn8o6WxzmbxVbI66S785lRNfL+ipfsCcOMoU6Rsu81Uz7ddQTjF+TeXJR5LONrI9j0MZ+wH0Eew/Vjn00EdgLP4hsn3lI2NjFlyH3EDzDbQvtn+0cbZ/1HeOG1CGHDesA15UzINjNsJ/DHzYdSQbpcteHLtBwOM9g2upPajrGyJw3ebQ3ijgNzi01f3GzEuShG1S2aLJpo75BsYFbIuqnxA+Rlaqn0YIHmVT1HbXURmO72zXqNt4L/11gXEb24HjNtvuWsErxgMztfevqlzBrWC7d8/xXMG4Q7uXK5jmJ8/HVpkraELZOJVVnStg/RwX7Ygdd8cB7wcjcgWe7tWVK2hS2VzKFbT2gFzBt8C37aooV/DlXq5gqmy2cgV/4uQKmlC/7lzBk5G5gu9UlCv4KejzXzi5gmbSXtbLFUzzie8Qfy9X8PTJFTShrO5cwZM15QoucHIFzaS9bC7lCn4OPuzAy9tx9nIFYZvs5QqK2W4VuQLWz6pyBRwP8J7+9MH7WnkvC+/xDvFh8KYnob1WodzAL2ftx71Wal/QAmjb8y/XbUM/oeY/HOO9/vLpei/MfqtYx9ZwvVgnSTr9MsMenWgZvBT4eMnlYVqmQ8NOG1Mc//3yMNzRAo5xzBMy4PFtpain5p6rk3Yaa4nGGofGalFP0VhFOFFm6qzBHTnlt4u2JeLdPAG/NtDeRNC+LQfvGoFH+RrPR3FMXVVs8MZsL6eyl5BNKL1a6/B+O/GetxeQeVfyQ/+h9kfyWQbWrQnRzob42/j7ELxjH8v7UxnG6vL+1KOEz2ScoX2AVwRwHgs4eX+q0pnXwDsei71+Qn7Uvsa1VA95R1/C71T/3EKwnEs4WvAU+nu1wBPiwTtf653fQ5pFbdPqpv3+UrLNJsDx3fbjxDvCNok//FvpN5/xxXt4+gQM67fBn+7otzoX2AScVwRwvtfRbyX3V8M71m91xgT1rpn99u5PU7yj7+F3qn9Yv9kfHS14Cv29UuAJ8TAu8Ki7PlcSP03Ay/qQPqzf+ws6ab9vypJXSr58T7va66f25Knvp/AdTc3s7wtBl/i7GMinauPCAM5LHP1UbejmPnbvG0ITTr0m4N1X0Bq1H7/wH8NntrBPEtZB3q9+Jcjp5Cs0Lw3mJ+ep8RzjaIPwJYnOEe6h5xgPquIcI5+NagD91I4+TvO9JpT1ibo2rWEb+z2YZ/1uAGeSdOebrl/cjtezxfQpOrZYO5Xteud++M4M7JNQXIryRXi+p9zgPwu2uaL2u+sbP1E5JYwRB5L2dnnnptKnaBxrMhkheO6XkH6pXC/rTeh7CIaPz5ndBH3A61Z4N+1q4v3WgryPC96VHVtdZcdVfz/1ouw32/1qZ2wdFzx0830Z7/upnEfCet55VIPrMgd74GzfO83fT1X6rM6jGk3le/F86dXke9V9y9i3rF+Iq0/wcWH2u5/g73f0qyl46OYOf76bueg96DWed37mbJ93tr4tek+30RwmPCjvlPfTSb/UOIl1s89Fd4yTjxbMtXg2lzdGGT9erkXlVFmXVH7PePD2GqS/LyM5GPw3I+OFiva8HVF0PVjlhr31Om+PHMpkhOC5X/BvxOWtv6jvJ60V+Pnup79w4oVxqO/lmGN4V35X2Rva1H+dtPu3mudzzDrh0OS6OPYMBuBD88+/FfJifxbKvV5MOA3+Hxx/oMbUm+Ad66CSvcpHeveJqfmD6UJ98Xzy1tm+o53HD+9uf7QNPhuel6/x9B916B9J/5sA9yWiOe7Q5LpIJ6T/ho919WeO/jeBdxUbn084Df4XBXNfnv7nxQjGj5f7UvG5+Zsa4/OjZjs+Z/334vOied5Y/W9CW79zUjvecShTOntB9ruf4A/MZBqrXzhvKBuDKh3yfC/nZ1Tsyv0YGmd4nmLwvwxy8OIt46tLfX7WbPtzk4ny5+OEa1zgwr4OfctvMPHzdOw/fxX6wMvPcG7p1oK8x9ob2tQjNN7g3JfHm1sdmlwX7To03hg+HhteIeTVIBqhfBCPNwb/KscfNJPOdnnjjZJ9U7RLyZTHIuTdm68bXJf2+Wxln00AYPv02po+RXNlPN6gP+Tv5RT9rlas/qMO3ZXpf3dy/dDdDeDFcPcJyH7632COyvpkCOjb//0RfHz3kX/91j1vP+QCPveSPtZH+3WB/4BHHnjHD/6/i19aF/7nP7jsm2/53j99ry78f7PvoqPm3fsHB9WF/xN/9Yvv/MHVv/wvdeF/860f/L3h12y8qy786/f/n2/dfuu+76sL/zf3+ecnv/rlsz+Th39+9nsQyvuozj7Z//1QNijw9RP8+zMbS21zKcVCA4Je+u4iB64R+F/xjPzYuyEB3yfgjfZ+At7KML+MPhxhUF6IawjKEf6CrO3WJ/tCHas/IujvS/QV3/huHsHvL+BV/jxt5wfIb2LbC4yLDaM9SPXxHdLuxhZ+62uXrv35gXf+XV22tvk1L3/DAae+9CN14X/jr336uc9/7JLhuvAP9D//i6MblxxfF/7fO6T/wE+ftvDYuvB/4ckTXvPx577kx3Xhv+7h3zj2x+/80Qvz8P//ATSA+3b+uBAA",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL3Lziy7jqT5LnvcgxAlimK+Sg8KXV0XJJCoBOoyypev32mizCZnfbbPWjL6hRYe4Yzw//jnv/zX//x//vt/+tf/8d/+/X/98y//73/885//57/+27/963//T//27/////e///Xf/8fff/2Pf37f/5y//53/zz9n/PMv++8P++df1t8fE38s/OH//Mv5+2Pjj8AfB39k/ZE//DHwh+GPiT8W/sAqiVUSqyRWSawyfr/757h/2v1z3j/X/dPvn/v+GffPc/+864273rjrjbveuOuNu96464273rjrjbveuOvZXc/uenbXs7ue3fXsrmd3Pbvr2V3P7nrzrjfvevOuN+96864373rzrjfvevOuN+9666637nrrrrfueuuut+5666637nrrrrfuen7X87ue3/X8rud3Pb/r+V3P73p+1/O73r7r7bve/ltv/D6YDavBG/7WHPODaDgNeSH+1h37g7+F7ftXYQ2zYTV4w274W9nWB6chL3ztAfhW9g+sYTZ8NX+b8zUKYDf8rTzHB6chL3wtAxgN1jAbVoM37IZeOXvlvCvb10VzfjAarGE2rAZv2A3RcBrywuiVR688euXRK49eefTKo1cevfLolUevbL2y9crWK1uvbL2y9cpff03/IBpOQ174egwwGqxhNqwGb+iVZ688e+XZK69eefXKq1devfLqlVevvHrl1SuvXnn1yt4re6/svbL3yt4re6/svbL3yt4re6+8e+XdK+9eeffKu1fevfLulXevvHvl3StHrxy9cvTK0StHrxy9cvTK0StHrxy98umVT698euXTK59e+fTKp1c+vfLplU+vnL1y9srVg+eD2bAavGE3RMNpSMCsHiwYDdYwG1bD38prfLAbouFv5bU/yAtfDwJGgzXMhtXgDbshGnrl0Stbr2w3kaZZw2xYDd6wG6LhNNxEmvPX0CvPXnn2yl8PrvzAG3ZDNJyGvPD1IGA0WMNs6JVXr7x65dUrfz3ovw/ywteDgNFgDbNhNXjDboiGXtl75d0rfz3o8YE1zIbV4A27IRpOQ174ehDQK0evHL1y9MrRK0evHL1y9MrRK59e+fTKp1c+vfLplU+vfHrl0yufXvn0ytkrZ6+cvXL2ytkrZ6+cvXL2ytkr5115/X4No8EaZsNq8IbdEA2noVcevfLolUevPHrl0SuPXnn0yqNXHr3y6JWtV7Ze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0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0c3p5nRzujndnG5ON6eb041ZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSL0vs97LEfi9L7PeyxH4vS+z3ssR+L0vs97LEfi9L7PeyxH4/ug26DboNug26DboNug26DboNug26Gd2MbkY3o5vRrbJk1E+rVJZcDOIh5sPKkouDaMRJXES6TbpNulWWDCvMh5UlFwfRiJO4iE7cxCDSbdHN6eZ0c7o53ZxuTjenm9PN6eZ023TbdNt023TbdNt023TbdNt023QLugXdgm5Bt6Bb0C3oFnQLugXdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2Sbkm3pFvSLemWdEu6VZaMVXiI2VgDiGNE4SAacRIX0YmbGMRDzIeDboNug26DboNug26DboNug26DbkY3o5vRzehmdDO6Gd2MbkY3o9uk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Kb083p5nRzujndnG5ON6eb083ptum26bbptum26bbptum26bbptukWdAu6Bd2CbkG3oFvQLegWdAu6Hboduh26Hboduh26Hboduh26Hbol3ZJuSbekW9It6ZZ0S7ol3fK5GbPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJ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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBNJwAABE0nAgIEAScCAwQAHwoAAgADAEwtCEwBJQAAAEElAAAAbycCAQRNJwICBAA7DgACAAEnAEMEAycARAEAJwBFBAAnAEYAACcARwEBJwBIBAEnAEkAAScASgQCJwBLBAUmJQAABn0pAgACAN51zkoKKgECAycCBAQAJwIGBAMAKgQGBS0IAQIACAEFAScDAgQBACICAgUtDgQFACIFAgUtDgQFJwIFBAMAKgIFBCQCAAMAAADIIwAAA9stCAEDJwIEBAYACAEEAScDAwQBACIDAgQfMABLAEgABC0IAQQAAAECAS0OAwQtCAEDAAABAgEtDEUDJwIGBActCAAHLQoECC0KAwkACAAGACUAAAajLQIAAC0KCAUAIgVIBy0LBwYnAgcECC0IAAgtCgQJLQoDCgAIAAcAJQAABqMtAgAALQoJBQAiBUgILQsIBycCCAQJLQgACS0KBAotCgMLAAgACAAlAAAGoy0CAAAtCgoFACIFSAktCwkIJwIJBAotCAAKLQoECy0KAwwACAAJACUAAAajLQIAAC0KCwUAIgVICi0LCgkcCgkKBhwKCgUAJwIKBAstCAALLQoEDC0KAw0ACAAKACUAAAajLQIAAC0KDAkAIglIBC0LBAMnAgQAAi0IAQknAgoEAwAIAQoBJwMJBAEAIgkCCi0KCgstDgQLACILAgstDgYLJwIKBAstCAALLQoJDC0ISg0tCEQOAAgACgAlAAAHFC0CAAAtCgwECiIERgkKIglECiQCAAoAAAJUJQAACPYwCgAHAAQnAgQAAy0IAQcnAgkEAwAIAQkBJwMHBAEAIgcCCS0KCQotDgQKACIKAgotDgYKJwIJBAotCAAKLQoHCy0ISgwtCEQNAAgACQAlAAAHFC0CAAAtCgsECiIERgcKIgdECSQCAAkAAALGJQAACPYwCgAIAAQnAgQABC0IAQcnAggEAwAIAQgBJwMHBAEAIgcCCC0KCAktDgQJACIJAgktDgYJJwIIBAktCAAJLQoHCi0ISgstCEQMAAgACAAlAAAHFC0CAAAtCgoECiIERgcKIgdECCQCAAgAAAM4JQAACPYwCgAFAAQnAgQABS0IAQUnAgcEAwAIAQcBJwMFBAEAIgUCBy0KBwgtDgQIACIIAggtDgYIJwIGBActCAAHLQoFCC0ISgktCEQKAAgABgAlAAAHFC0CAAAtCggECiIERgUKIgVEBiQCAAYAAAOqJQAACPYwCgADAAQtCwIDACIDAgMtDgMCACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAAAPbKQIAAwCzy0t4CioBAwQkAgAEAAAD9iMAAAS8LQgBAycCBAQCAAgBBAEnAwMEAQAiAwIEHzAASABIAAQAIgNIBS0LBQQnAgMABi0IAQUnAgYEAwAIAQYBJwMFBAEAIgUCBi0KBgctDgMHACIHAgctDgQHJwIEBAYtCAAGLQoFBy0ISggtCEQJAAgABAAlAAAHFC0CAAAtCgcDCiIDRgQKIgREBSQCAAUAAASLJQAACPYwCABJAAMtCwIDACIDAgMtDgMCACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAAAS8JwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCiBERwIkAgACAAAGfScCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQXpSUPomzfdLAAiBQIFACIQAgYnAgcEGy0CBgMtAgUELQIHBSUAAAkIJwIGBBsAKgUGBS0MSQUAIgUCBS0OAQUAIgUCBTwOAwQoAAAEBHhNDAAABAMkAAADAAAGoioBAAEF2sX11rRKMm08BAIBJiUAAAZ9LQsCAy0LAQQMIgNLBSQCAAUAAAbCJQAACToAIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIACIDSAUOKgMFByQCAAcAAAcHJQAACUwtDgQBLQ4FAi0KBgEmJQAABn0cCgIFACsCAAYAAAAAAAAAAAEAAAAAAAAAAAQqBQYHLQgBBScCBgQEAAgBBgEnAwUEAQAiBQIGLQoGCC0MRggAIggCCC0MRggAIggCCC0MRggtCAEGJwIIBAUACAEIAScDBgQBACIGAggtCggJLQxGCQAiCQIJLQxGCQAiCQIJLQxGCQAiCQIJLQ4HCS0IAQcAAAECAS0OBQctCAEFAAABAgEtDgYFLQgBBgAAAQIBLQxFBi0IAQgAAAECAS0MRAgtCEUEIwAAB+IMIgRKCSQCAAkAAAiYIwAAB/QkAgADAAAIASMAAAgxJwIBBAktCAAJLQoHCi0KBQstCgYMLQoIDS0ISQ4ACAABACUAAAleLQIAACMAAAgxLQsIAQoiAUQCJAIAAgAACEsnAgMEADwGAwEnAgEECS0IAAktCgcKLQoFCy0KBgwtCggNAAgAAQAlAAAKXS0CAAAtCwcBLQsFAi0LBgMtDgEHLQ4CBS0OAwYtDEcIACICSAMtCwMBJgwqBAIJJAIACQAACKojAAAI6AAiAQIKACoKBAstCwsJJwIKBAstCAALLQoHDC0KBQ0tCgYOLQoIDy0KCRAACAAKACUAAAleLQIAACMAAAjoACIESAktCgkEIwAAB+IqAQABBbq7IdeCMxhkPAQCASYAAAMFBy0AAwgtAAQJCgAIBwokAAAKAAAJOS0BCAYtBAYJAAAIAggAAAkCCSMAAAkVJioBAAEF5AhQRQK1jB88BAIBJioBAAEF0Afr9MvGZ5A8BAIBJiUAAAZ9LQsEBgoiBkQHJAIABwAACX0nAggEADwGCAEtCwMGCiIGQwckAgAHAAAJ+SMAAAmTLQsBBy0LAggMIgZDCSQCAAkAAAmtJQAACTotAgcDJwAEBAQlAAALWS0IBQkAIgkCCgAqCgYLLQ4FCwAiBkgFDioGBQckAgAHAAAJ5CUAAAlMLQ4JAS0OCAItDgUDLQxEBCMAAApcJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAACl0tAgAALQsBBi0LAgctCwQILQIGAycABAQEJQAAC1ktCAUJACIJSAotDgUKLQ4JAS0OBwItDEgDLQ4IBCMAAApcJiUAAAZ9LQhFBSMAAAprDCIFQwYkAgAGAAAK0yMAAAp9LQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAK6SMAAAtLLQsCBwAiBwIJACoJBQotCwoILQsBCQAiCQILACoLBQwtCwwKACoICgstCwQILQIHAycABAQFJQAAC1ktCAUKACIKAgwAKgwFDS0OCw0tDgkBLQ4KAi0OBgMtDggEIwAAC0sAIgVIBi0KBgUjAAAKay0BAwYKAAYCByQAAAcAAAtvIwAAC3gtAAMFIwAAC7wtAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAALsi0BCggtBAgLAAAKAgoAAAsCCyMAAAuOJwEFBAECAAYCBiY=",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl6dj1fn49X5eHU+Xp2PV+fj1fl4dT5enY9X5+PV+Xh1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHU+X53PV+fz1fl8dT5fnc9X5/PV+Xx1Pl+dz1fn89X5fHW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69X5enW+Xp2vV+fr1fl6db5ena9X5+vV+Xp1vl6dr1fn69V59SD5KTqPsumr86jO4a/OL81H69F+ZI/8UTw6j7LJn4c/D38e/jz8efjz8Ofhz8Ofhz+PeB7xPOJ5xPOI5xHPI55HPI94HvE8zvM4z+M8j/M8zvM4z+M8j/M8zvM4zyOfRz6PfB75PPJ55PPI55HPI59Htkc1Ll0aj+aj9Wg/skf+KB6dR89jPI/xPMbzGM9jPI/xPMbzGM9jPI/xPObzmM9jPo/5PObzmM9jPo/5PObzmM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/1PPbz2M9jP4/9PPbz2M9jP4/9PPbz2M/j1fl+db5fne9X5/vVefU7xSzyR/HoPMqmqnPQeDQfrUf70fPw5+HPw5+HP494HvE84nnE84jnEc8jnkc8j3ge8TzO8zjP4zyP8zzO8zjP4zyP8zzO8zjPI59HPo98Hvk88nnk88jnkc8jn0e2RzVHXRqP5qP1aD+yR/4oHp1Hz2M8j/E8xvMYz2M8j/E8xvMYz2M8j/E85vOYz2M+j/k85vOYz2M+j/k85vOYz2M9j/U81vNYz2M9j/U81vNYz2M9j/U89vPYz2M/j/089vPYz2M/j/089vPYz8Oehz0Pex72POx5vDq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txenVe/VVjRfmSP/FE8Oo+yqeocNB7NR88jn0c+j3we+TzyeWR7VAPWpfFoPlqP9iN75I/i0Z/HGUXZVH8XBxqP5qP1aD+yR/4oHj2Pr87Pt+LVlHVpPJqP1qP9yB75o3h0Hj2P9TzW81jP46vzs4v2I3vkj+LReZRN9YejoPFoPnoe+3ns57Gfx34e+3ns52HPw56HPQ97HvY87HnY87DnYc/Dnoc/D38e/jz8efjz8Ofhz8OfR/0xap1h9feoRfUnqaDPw4vmo/Xo8zhF9sgf/XlknU1fnV/Kpq/OM4rGo/nozyNrlK/OL9kj//5481cYxEPMh1+tNw7iJC7iJhqRbkm3pFuW23dU1fLVOIjltgsXcRON6MQgHmI+HD/iINJt0G3QbZSbFToxiIeYD/Ens8BBnMRF3ES6TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeh26Hboduh26Hboduh26Hboduh26JZ0S7ol3ZJuSbekW9It6ZZ0y+d2fj/iIE7iIm6iEZ0YxEOk26DboNugG7LkFG6iEZ0YxEPMh8gS4CBOIt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dEu6Jd2Sbkm3pFvSLemWdEu65XPL3484iJO4iJtoRCcG8RDpNug26DboxixJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLqkVwjFE4iJO4iJtoRCcG8RDzYdIt6ZZ0qywZs3ATjejEIB5iXpzVSdg4iJO4iJtoRCcG8RDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6VZaMXbiIm1huUejEIB5iPqwsuTiIk7iIm0g3p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3ZJuSbekW9It6ZZ0S7ol3ZJu+dzG70ccxElcxE00ohODeIh0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023QzuhndjG5GN6Mbs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxaz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MEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrMEfa/fK30X+l4v5sPKkr0KB3ESF3ETjejEIB5iPnS6Od2QJVG4iJtoRCcG8RDzIbIEOIh0C7oF3YJuQbegW9At6Hboduh26Hboduh26Hboduh26HbolnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdGIQD5Fug26DboNug26DbpUlNgudGMTPzVZhPqwsuVjn5C6cxEXcRCM6MYiHmA8rSy7SbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od2CbkG3oFvQLegWdAu6Bd2CbkG3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7ekW9It6ZZ0S7ol3ZJuSbekWz439L1eHMRJXMRNNKITg3iIdBt0G3RDlozCRdxEIzoxiIeYD3FdAhxEuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3oduh26Hboduh26Hboduh26HboduiWdEu6Jd2Sbkm3pFvSLemWdMvnhr7Xi4M4iZ+bncJNNOLn5vhvg3iIn5t/lwfoe704iJO4iJtoRCcG8RDpNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dboduh26Hboduh26Hboduh26HboVvSLemWdEu6Jd2Sbkm3pFvSLZ8b+l4vDuIkLuImGtGJQTxEujFLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzBH2v39tCFvpeLy7iJhrRiUE8xHyILAHSbdJt0m3SrbIkvNCJQeSxMUuCWYK+16jBKksuLuImGtGJQTzEfFhZcpFum26bbptum26VJafmW1ly8RA/t+8Zywt9rxcHcRIXcRON6MQgHiLdnG5ON6dbZcmpvagsuWhEJwbxEPNhZcnFQZxEugXdgm5Bt6Bb0C3ohiyZhYM4iYu4iUZ0YhAPMR8m3ZJuSbekW9It6ZZ0S7ol3fK5oe/14iBO4iJuohGdGMRDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJuzJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLElmCfpecxVO4iJ+brkLjejEP7f5Pep+Vd9rYz78suTvV+bCQZzERdxEIzoxiIeYDyfdJt0m3SbdJt0m3SbdJt0m3b4s+ful+8MvSxoH8XP7nq25qu+1cRM/t+GFTgzi5/Y9kGVV3+vF/SMO4iQu4iYa0YlBpNumm9HN6PZlyd+P6YWLuImf27RCJwbxc/v+umpV3+vFL0saB3ESF3ETjejEINLN6RZ0C7oF3YJuQbegW9At6BZ0C7oduh26Hboduh26Hboduh26HboduiXdkm5Jt6Rb0i3plnRLuiXdst129b02DuIkLuImGtGJQTxEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeh26Hboduh26Hboduh26Hboduh26JZ0S7ol3ZJuSbekW9It6ZZ0Y5YMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJZU3+v8/gxiV9/rxcqSi5/b15i1q++1cRE/t68palffa6MTP7fvN+xdfa+N+bCyZEfhIE7i5/b1w+zqe2004udm5VZZcvEQPzf/fVhZcnEQP7fv17Ndfa+Nm/i5eR1xZcnFIH5uXotaWQKsLLn4uUUdUGXJxUX83KIGqyy56ES6VZZczIdOt8qSi5P4uZ1a9cqSi0b0N53KkouHmG86lSUXB/Fzy1qzypKLm/i5Ze1bZcnFIH5uWW6VJcDKkot/butX8/2ypHER94dWaEQnxptOZcnFfFhZgulUllycRLrlJhqRbl+WNB5ifvitWfW9Ng7iJC7iJhrRiUE8RLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbp9WbLGKpzERfzcvme17+p7bXRiEA8xH35Z0jiIk7iIdNt023TbdNvlFoX50H7Ez23OwklcxM9t1mF+WdLoxM+tPgOq77UxH35ZstavcBAn8XOrD4nqe2004ue2ar5fljQe4ue2yi1+xEGcxEXcRCM6MYiHSLdDt8qSXfOtLLm4iJ9bfQ5V32ujEz+3jcEOMR9+WfL3A3jhIE7i52Y1WGXJRSN+bl77Vlly8RA/t+997Lv6XhsH8XP7Xry8q++1cRM/txiFToyHuPNf9A37vcR0V0vk3+8DhUZ0YhAPMR/WaXZxECdxEenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAt6ZZ0S7ol3ZJuSbekW9It6ZbPrVoiGwdxEhdxE43oxHKLwkPMh/WRdXEQJ/Fz+174uqslstGITvzcvhey7mqJbPzcvt+7drVENg7iJC7iJhqx3LwwiIdYbl85VUtk4yB+bnUtUi2RjZtoRCcG8XNLK8yH9ZF1cRDLrWZWH1kXN/HP7W93C50YxPMhBsuHX2g01ppl4f7+rzWu1Qh1xF8+7FFT//Lh4pcPjYM4iYv4jTvK7cuHRicGsdxqDp4Po9xqkjGIk7iIm2jEz60+YqvNsfEQ8+GXD3tWBXz50Pi5zZrklw+Nm2jEcivjE8RDzIf5Iw7i57ZqOl8+NG6iET+3VZP88qHxEMvtK8hqc2wcRCfWCN9RVJPirm+T1Zm465O5OhMbN9GITvwGq6+b1ZnYmA+/km4cxEn83OoDvToTG43oxHKr+c5DzIer3GpmaxAn8XOzUfi51dfY6kz8K45CJwbxEPPhV9KNNW5Ncm+iEZ0YxPOwqrC+E1eD4MWqwvoiXK2Au646qhWw0YhODOJ5WHVRlyXVsteYD6suLg7iJC7iJhrRiXQ7dDt0S7ol3ZJuVQFeZ2qd6+6FNcK33dWG1ziINUIWLuImGtGJ8bDqoi7PqrVu14VYtdbt+tys1rpGJ34jxCo8xHxYxXBxECex3KxwE8vNC50YD+u0r8/japfbdUOg2uUaa4RZWCPUYdYJfvEQ82Gd4KfW4fvMapzEz60+3KtdrtGIdNt023TbdKvPrIvj7YVxN427adxN424ad7NqCFtYn1nYwqohbJZzN527WTWEvXDupnM3nbsZ3M3gbtZnFvYtuJv1mYXNCu5mcDerCrGFVW/Yt8PdrHrDFla9YaEO1/dwfQ/Xt+oNm5XczeRuVr1hs5K7mdzNpFvSLemWdMu3m9UbtuuirHrDGvNhFcP3ivhdvWGNk7iIm2hEJwbxEMutplMlcnEQJ3ERN/Fzy5pvFc7FIB7i5/b93L2rN6xxED+3uu6r3rDGTSw3L3RiEA+x3L4TprrA9vda+11dYI2baMS/ce37yX1XF5h9b5ff1QVmdT1ZXWAXvw+fxkGcH9YRf+XUuIlGLLc6Ni+Lmq+XRU3nqyEbNZ2vhqxuEFXrV+MibqIRnRjEz63u6VTr18VTbmV8BnESF3ETjfi51Z2eav1qPMR8+NWb1QVntX41TuLnVtee1frVaMRyq+3Ocqs55CFmY7V+NQ7iJH7jfn/psqvJqzEejvq/7sIgfm51uVjNWBe/4m0cxElcxO/Y6s5UNWNZ3YOqZqzGIB5iPlw/Yo1bB7RqhCz8Rtiz8BDz4VeQtuswv4JsnMRF3EQjfm51yVoNVo3lVgu186H9iDVurUOVXt3bqqapxhrhV5hvoar0Lg7iJNa4tSRVeheN6G8DPIjcTadb0C3oFnSrKgRWtdTFdDU3NW5iVUtZVLVcDOIh5sOqlovfHKyWpKrl4iJuohGdGI3VxmR1xV9tTI2TuIibaEQnBvEQ8+Gg26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJuh26Hboduh26Hboduh26Hboduh25Jt6Rb0i3plnRLuiXdkm5Jt2w3+70ssd/LEvu9LLHfyxL7vSyx38sS+70ssd/LEvu9LLHfj26DboNug26DbsiSVWhEJ56biPZDgBQiQICDOImLuIlGdGIQ6Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53ZxuQbegW9At6BZ0C7oF3YJuQbeg26Hboduh26Hboduh26Hboduh26Fb0i3plnRLuiXdkm5Jt6Rb0i2f2/j9iIM4iYu4iUZ0YhAPkW6DboNug26DboNug26DboNuzJLBLBnMksEsGcySwSwZyBIvNKITy+0UHmI+RJZE4SBO4iJuohE/t+/WqlXvUuMh5sPKkouDOImLuIlGpNum26ZbZYnX6lSWXBzESVzETSy3VejEIJbbLsyHlSUXB7HGtcIaobal8uFiPqx88NqWyoeLk1jzzcJNNKITP7eoA6p8uJgPKx8ufuNGLV/V/Hd7zKrHqPEQ69wpC9Q8cBAncRE30YjlVqtTNX/xEGu+30pWj1HjIE7iIm6iEZ0YxEOk26Bb1fx3d9Gqx8i+u4tWPUaNm2hEJwbxEPNh1fzFQaRb1fx3o9Gqx6jRiOV2CoN4iJ/b90uxVY9R4yB+blmDVc1f3MTP7ftp1qrHqDGIn9t3D8+qx+hi1fzFzy1rOlXzFxdx8781ohP/3PxX0/lqvjEffjXv350yqx6jxklcH9ZufjXfaET/sKZjQTzEOrZas6r5i4P4uY1y+64fGjfxcxvl9l0/NAbxc/t+j7XqMbr45UPjd2yz/tsvHxoX8XObde58+dDoxM9t1Xy/fGjMh18++KpV/64fGifxc9u16t/1Q6MRP7ddp8aXJY2H+LntWpIvSxoHcRIXcRM/N6v5flnSGMTPzaqOvywBVo9R4+dWaVQ9Ro2L+LnVJ0P1GDU68XOrT4Z6tl5jPvyyxCvB69l6jZP4uVVs17P1Go34uVUE1bP1Gg/xc6uoqGfrNQ7i53bqiL8sadzEz+273W/1bL3GIH5uVYX1bL2LX5Y0fm5Zg31Z0riIdFtGdCLdvixpzIdflkQVej1br3ESF3ETjejEIB5iPjS6Gd2MbpUlOPjKkotG9HfwlSUXD7Hcaof8RxzEcquzxBdxE79jG+X2ZUljEL9jmzXfL0suflnS+Ll97zG2aiRrXMT9phNGdGK86cQh5sNDtzOIk0i3L0sajfi5zVqzL0saD7GOraolf8RB/NxWuX1Z0riJn1tFWzWSNQbxc1t1QF+WAKuRrPFz++6kWzWSNS7i51bJVY1kjU783L4b2laNZI358MuSqGirRrLGSfzc6l5FNZI1GvFzs3L7sqTxED83r8G+LGkcxM+toq0ayRo38XOri95qJGsM4ucWGCwfflnS+LlFDfZlSeMifm5Ri/plSaMTP7e6NqpGssZ8WFlyalErSy5O4ud2onATjXj64qmel2ff77xWz8trXMRNNKITg3iINd86uSofLg7iJC7iJhrRid/q1FVbNZI15sPKh1MrWflwcRLr+rf2or6LXDTi51YXRNUyFpWI1TLWOIiTuIibaEQnBvEQ6ZZ0S7ol3ZJuSbekW9It6ZZ0y+dWLWONgziJi7iJRnRiEA+RboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0Y5YYs8SYJcYsMWaJMUuMWWLMEkOW7MJDzIfIEuAgTuIibqIRyy0Kg3iI5fZ9QjqyBDiIk7iIm2hEJwbxEOk26DbohizJwkXcxD+3U9+aq32vMYjnw+/YHKlR/wz5cAqN+I3w9UFbteQ1HmI+/PKhcRDnhzX1Lx8aN9GI5VaTXEE8xHKrqe8fcRDLraa+F3ETjVhudfBfPpy6pq1GvfP1uFg16jVO4iJ+49aVbjXqnVlH8SXBqe/z9Vy7M8vtS4LGfOg/YrnVdHwSF3ETP7dV8/3K/9TNgerkO3VVXJ18Z9V0vvI/dSlcnXyNk7iIm2hEJ5ZbzSHOQ9Q8kGfU4Zl6eKYenqmoeaATg3iI+TDplnRLuiXdkm5fzZ+6xVGtfo1B/A5o10p+NQ+sJ9g1DuIkLuImGtGJQTxEuo1ys8JBnMRF3EQjllsWBvEQ8+F3/XDqR4vqUmycxM+tvsJUl+KpLyvVpdj4udU9m+pSbPzc6ntLdSlerHy4OIiTuIibaEQnBpFui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbhUg9StXtTE2OjGI9TkEzIdfljQO4iQu4iYa0Yl1FF8UV2siPvWqNfHUL23VmthoRCcG8RCzsZoQT92UrCZErEM1IeIwqwmx8RDzYdV83bWsJ801TuIivt2sJ801OjGIh/h288wfcbw5oOaBi7iJ9uZQNX8xiHRjzR/W/GHNH9b8Yc0f1vxZ79w5iyu5uJKLK1k1jzlsruTmSrLmD2v+sOYPa/6w5g9r/rDmz+a+oeaBXEnjShr3rWr+IleSNX9Y84c1f1jzhzV/WPOHNX9Y88e5b86VdK6kcyWdK1k1Xz/YVtNkY63kLJzERdzEOraaQ9X8xSAeYj6smr84iJNYbjXJqvmLVfO1kue8Kqya96/Qq+2ycRAnkTuU3KHkDiXP9eS5Xklw8Z191YyJDahmzMZJXMRNNKITg/jOh0Q+nMJJXMQ6iiz8xq2fkqvtsjGIh5gPKx8uDuIkLuK7m5S4ewA8xHyIuwfAQZzERdxEI9Jt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnTjPccMugXdgm6Hboduh26Hboduh26Hboduh26Hbkm3pFvSLemWdEu6Jd2Sbkm3bDf//X7EQZzERdxEIzoxiIdIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdDO6Gd2MbkY3o5vRzenmdHO6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3ZJuSbekW9It6ZZ0S7ol3ZJuzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcyS6rU8X0OdV6/lxfqGcnEQJ3ERN9GITgwi3RbdNt023TbdNt023TbdNt023d6vno5eS6D9iIM4iYtYbqvQiE4st114iPmwvqF8HYJevZaNk7iIm2hEJwbxEPNh0C3oFnQLugXdgm5Bt6Bb0C3oduhW31C+Bh+v58Sdr5PPq1uzcRON6MQgHmI+rO8tFweRbtm9gI4ezotG7F5ARw/nxUOss+Tvi4Kjh/PiIE7iIm6iEZ0YxEOk26BbfW8J4Lc636/rXn2Zp87J6stszIf1DeXiN8LXpuTVa3m+hiSvXsvGQ8yHVfMXB/Fb36+JwKvXsnETjejEIB5iPqya//4s3KvXsnESF7HcTqERa33rMKu/+uIh5kPUPLDcan2te/a8uirv/7Vqs06Y6ols3MTu9/TqiWwM4iHmw/gRB3ESF3ET6RZ0C7oF3YJuh26Hboduh26Hboduh26Hboduh25Jt6Rb0i3pVj2Rv1rJ6om86MQgHmJ3znp1P56q2OpzPPVJVn2O5/v50qvPsfEQ82HdXbw4iJO4iJtoxHLzwiAeYj6s2rw4iJO4iJtoRLpNuk26TbotulWf49fX5uhzvLiIm2hEJ9a4X8VW7+LJ+r9WbX4/IHn1LjYa0YlBPMR8+NVmYmO/2myct4PY0bt4cRONeL5/VueD1wh1PlRv8wIu4ibabRD26kdsDGJ1G2PcfFi9zRcHcRIXcRON6MQg0i3o9lVs/mo6X23m1xru1WOYv9rjrzYbDzEfZo1Q+5Y1Qq1ZOjGIh5iN1TfY+K3v9xu2V99g4yJuohGdGMRDLLfvPKu+wcZBnMRym4X74Vdk+T30wasBsHES1+2k9moAbDSiE4N4Hq4a1wrL2AvrMGtmy4lBPMR8uH/EQaz5nsJF3LdD26upr9GJ8bDKqeqimvry61r1auqrFm6vpr5GJ8Zt4fZq6mvMh16t4TVJH8RJXMRNNKITg3iI+TDoFnT7yilnnTBf4eSsI/4KJ2ft0Fc4F78PwMZBrBFq36pwZo1bhXMxH+aPOIiTWOtbq5ObaEQnBvEQs7Fa8hrLzQoncRE38XP7uoK9WvIaP7dKuWqzy+/BHl5tdo2baEQnBvEQ82HV28VBpNtr3nd7zftu04jdvO/2mve92uwaq53+2+Nqs2scxElcxE00ohODeIh023SrKlw1nV2rE4W1OqfwEPNhVeHFb4Rd2/LVW359FV7tcI2HmA+/emscxG99d83MF3ETjejEIB5iPoyab519MYiTuIjlVlsYRiw3LwziIebDqs1dq1O1eXESF3ETjejEIB5iPky6Zf+5gqMd7uIi9p8rONrhLjqx/oCgjqJuQl3MRrTDXRzESVzETTSiE4P43KrxLb9mFa8Wt/weCODV4pZfW4pXi1tjEM/Dqtj6UKsWt/x+SPNqcWt0YhAPMR9+tZlfP4FXi1vjJC7iJhrRiUEst1WYD+tz8+IgltspXMRv3O93SK+2tfQ6+O/SsnERN9GITgziIebDqtiLdKtPyPrmU21rjZto929svJ5F1xjE+iMcDJYP6xPy4iBO4iJuohGdGES6Bd2qNusCoxrU0mvnqwq9zsmqwouHmA/rc7OuNarpLOuqoprOGoN4iNlYTWeN3/rWTb5qOmtcxE00ohODeIjl9p191XTWOIiTWG6zcBPLbRc6MYiH+LnVTbNqOmscxElcxE00ohODeIh0W/1HTl5NZ42T2H/k5NV01mjEL6PqKrOazhoPMR/WT0UXB3ESF3ETjUi3Tbf6jI3ai6rjwP/1W51TR1F1fNGJ8bAqtm6aVXNY1kd+NYc1GtGJQTzEb33rwqWawxoHcRIXcRON6MRyq1WvT9OL+bA+TS+WW+1xVezFGvcUOjGIh5gP63PzYo1b61t1fPE7ironVi1jjZ9b3Z2plrHGz62ypFrGGj+3isF6ml3j51bZV41kjeVmhZtYbl7oxHKLwkMst++Aqr2ssdyycBL/3P5+UPoVb2ErHsUuHMWz+AhncR1Xvc+0eRTXkdUbTZvhW8c2t3BdH9QU6oeci0E8xHxYlX4RjrU+awovYTjWCiwTduEQPsJJ3j/hITyFl7D4bvGtt5n+Rs2/Xlz6q9sFeHPpr77449WlzVvYhF1Y5m8yf5P5u8zfZf4u83eZv8v8Xebvsm4uvi6+MXiMsXmMIfMPmX+9orT5CCf5yPyPzP/I/I/M/8j8j8z/yPyPzP/I/I+sW4pvim9uHmMGjzFl/sn5402kzUN4CnP+eBtpswm7cAgfYc6/Hub3eAhPYfEd4osEqGNMVHodY06Z/5T5zyW8hU3YhTH+Kj7CX7XX3Q20k10cxEnE2GCMYcU1Rh1GfVpfHMRvjLq3gCaxi5tY1wan0IlBPMR8WI0dFwdxEhdxE+lmdEMF1125RKXW7bNEpdZFQ6JSL5uwC9c4daFTPV1/XDtQLxJu3sIm7MIhXKuNXUClglGpl4fwFF7CW9iE4Vt7gUq9fISTjEqte0iJSr0M3yhewlvYhF04hI9wNscPlX15CE/hb8+/3+Xi9/4MPX7vz9ADLV/frYT4vT9Dj9/7M/RAy9d3XyLQ8nVxECdxETfRiE4M4iHSbdIN9f2dmfFDHX+VEj/U8Xd3P36o48tJrneRN9c43y8S8cPn8Krx8Tl8+QgnGZ/Dl4dwrfaqtcLn8OUtbMIuHMJHOMkG31k8hKfwEoZv7T4+ty+X7651wOf25fLd+Lflu2t9qnPL6hypzq2Lk7iIm2hEJwbxEPNh0C3ohsTAiYrEuLyFTdiFQ/gIJxmJcXkIw7fWH4lxeQubsAsHGZVuda6i0i+7cAgf4Xw8UOnfvakYqPTL+O9ncZLx2XsZ//0unsJL+Ns/x39uRCd++/fdswj0VF3Mh3hmRE0Kz4wATuIibqIRnRjEQ8yHi26LbrjirjNnoKK/m18xUNHfbawYqGgwKvryEK5xvFYeFYrxUaGXk4wKvTyEp3CtNtYKFXrZhF04hI9wknFlfRnzz+IpvIS3MHxr9/F5fRm+tW64snb890mOn/AQnsJLeAubsAuHsPhWu2UUVrvlxUH8TrFTe1Xtlhc38TvFoja22i0vBvEQ82G1W14cxElcxE2kW9INtfz9TUNMfDp/d7hi4rr7a3+LievuyybswhjnO8Mnavm7CRUTtXx5C5uwC4dwrXbNc+IbNhjX3ZeH8BRewlvYhOG7i0P4CCcZn9e1uRPfs8GoVhw7qvXyFF7CNZ86B+aW40UVX04yqvi79xMTVXx5Ctf4p/bOZJ1N1tlknU18TXxNfFHFl4ew7K/L/rr4unihQk+dJ6jQy0MYx1Lrgwq9vIVNuMY/NT4q9PIRTjI+T7+utJj43Dx1DuBz87IJY/zaX3xuXj7CScaV9uUhPIXLN2vf8fl72YRdOISPcD5e+Py9jDFnMf7tKj7CScZn8eUhPIUxZyvewibswiF8hJOM+r0MXy+ewkt4C5uwC8fbu4X6vZxk1O9l7MsuNq4brr0vh/ARxrF859Laslao8ctbGOOXL66xL4cwxs9i2SOTPTLZIxNfE18TX9T+ZReWc8Pk3DDxdfFyXnWs++kMduEQ/sYcv+LgVceKKbyEd/33YBN24Siu9Y8j/5ZXO+v8hMX3iO8RX9T+ZRN24RAW3xSvquvxq7XKLWzCOJY65zOEj3A+rm6sP/biITyFlzB8oxjjn+IjnOSB8bN4CE/hJbyFTdiFy/e7Nxb1/LbHSa7abx7CU3gJb2GM+Z0D1aX1x6t4Ci/hLWzCLow515qvI5zk/RMewlN4CW9h+NYebRcO4SOcZPsJD+6dTeElvIWxL7s4uW7+Ex7CUxjHUueSy1p5CB9hjF++8RMewhi/zpOQPQrZo5A9CvEN8Q3xjSSfn7CcG0fOjSO+R7xQ1wucZNT45SFcY846J/HZXfdbdrpwCNecvzuNsVHjxYYav1xz/u4ihuE6vP6t4Tr88hY2YRcO4SPM+0U2fsJDWHyHeKGuvza8MNT15SSjrr+7i2Go68tTeAnXvn89elHdYo9dOITh+52Thtqve26G2r+8hDF+FpuwC4fwEU4yav9y+db9PUPtX17CW9iEXTiEDxl1XffK6vFqf1xri1q+HMJHOMmo8cuYc605avzyEt7CJuzCIXyE4Vt7hNq/PISn8BLewsa9Q+1fDuFDRr3POj9R11i3s4VN2IVxLHUupaxVDuEpjPHLF5/vl00Y49d5krJHKXuU3CP//YSH8BRewlvYhF04hMULdV0547iev7yFTbjG/JoZw3HdXrnkuG6/PIRrznXP1lHjl7dwzXnjv3f5tyF8hMV3ie8S3zWFl/AWNmHxXeKFuq57y466vryEcSxWbMIuHMK173Wv1fGZDsZn+uUhDN8oxvin2IVDGONncZJR+5eH8BRewlu4fOu+rqP2L4fwEU4yav/yEJ7CGLPWHJ/dVmuLWr48hKfwEt7CmHOtOWr8cggf4SSj9i8P4SkM39oj1P5lE3bhED7C+fYuUPuXh/AUxr7s4njrFriev5xkXM9fxrFEMdcqcN1+2YUxfvni8/1ykvH5XndoY3KPYk7hJSy+U3yn+OLz/fIR5rlRTWyPxXeJFz7T67tn4DO9vpcFPtMvJxmf6ZeH8BRewvg12YpN2IVD+AgnGd/lLw/h1zcRgdqvnzYCtX85hI8wjqvWAbV/eQhP4SW8hU0Yx1XH7iF8hJMcP+EhPIWX8BYOHnvIcSEfwMiHy0NYjuvIcR05riPHhXy4HMJHWI4r5bhSjivluFKOK+W48L3gsqwn+2Li3P6XXzGP6yAHLi/hLczjOj8XDuEjzPPkjJ/wEOZx3c64y1vYhF1YjmscYa7nYb9M3A44HPuU45om7MIhLMc15biWHNeS41pTeAlvYTmuJce15LiWHNeS49pyXHsIy3puWc9qWK9b9fWktcZDzIe4XqhfwKoHrtpQ49gmGhELZsUhfISxYN+H0kFnbP3T6mW/OIl0dDo6HV+/bJzXLxvn9cvGQb9sYdAtaIEL//pZDw1wzSGM+Wdxkm8wgIdwbXj9qIUGuOYtbMLlG7U5uECoH8HQ6NY8hDF+zR8XCJe3sAm7cAgfYfh+G43GuOYhPIWX8BY2YSej6OsHGTS3ja+pOtDc1mzCLhzCRxhz/tYczXDNQ3gKL+EtbMIuXL71Qxma4ZqTjKK/PISn8Hp7lyj6yybswjjfvgufxAUC1g0XCJeX8BauMetHudyyVvgSAEZRX8acyxdfAi4v4Rq/6iVN9shkj0z2yMTXxNfFFxcIl6ewnBsu54aLr4tXVTWWqrrgL07iIuI46nyM/kOQqK65xnyI4q5f+9Az1zyFsUi18PUnZPefGtGJdDx0PHTMH3EQJ3ER6Za0QBF/vzIe9MA1D2HMP4uX8BY24drk7xe+88On++UjnGQU+tePf34o9O9Xq/NDoV82YYy/ikP4CCcZhX55CE9h+O7iLWzCLhzCRzjJKPTLGNOL8W9rbVG4l5OMK/7LQ3gKY8615ijoyybswiF8hJOMQr/8+c5f7VEVevMS3sIm7MLBvUOhX04yCv0yzrdTbFw3fMO/HMJHOMu3zqWQtcJdvMtbGHMu33DhED7FdZ6E7NGRPTqyR0d8j/ge8cWH+WUXlnPjyLlxxDfFq6ra6hSrP3C56MQg4jg+rs63+jvJUw8ia1xEbCzYhF0Yi+TFh/80H9bfs1yk46DjoCP+ZhRoRCcGkW6TFhMnZhRvYRPG/LM4hI9wkquI53fZf6o/7vEUXsLl+102HzTOze8nqoPGueYkb4y/iofwFF7CW9iEXRi+tdH7CCfZfsJDeAov4S2MMWvfHf+21tan8BLewibswphzrbkf4STHT3gIT+ElvIXLd9YeodAvh/ARTnIVevPg3p0pvIS3MM63U5xct/wJD+EpXGPOOpdS1ipD+Ahjzp9vPSjs8RCu8b+fwA5a5vBv0TLXbMIuHMJHOMnjJzyEp7D4DvGqqv7u4p/qnrtYBX5xEHEcu/iLi++u/akOucYgYmOtOMko7stYJC+e75/WH4lf3EQ6LjouOtYfiV/Mh/VH4hcHkW6bFijiWQuDIr6cZBTx91vfQZ9d8xRewrXJqxYQn9aXXTiEy3fVfFDoq04iFPrlJYzx6+RCoV924RA+wklGoV+Gb200Cv3yEt7CJuzCIXzIKOJV+37wb2ttUbiXQ/gIJxkFfRlzrjVHQV9ewlvYhF04hI9w+VYhoJ+ueQhP4SW8he3t3UKhXw7hQ0Zxf79nHvTZYd3QZ9dswi5cY9a5jX46rBX66ZqnMOZcvvgwv2zCNf73e9dBP13/2yPMPUI/XbP4LvHFh/nlLWzCLiy+S7yqqitOqs2ucRONiOPYxV9cVHnjEWQXBxEba8VLeAtjkWrw+hvz+0+DeIh0dDo6Hev+2sVF3EQj0s1pgSLe4Cm8hDH/LDZhFw7h2mSrExmf1mB8Wl8ewuVrdQKi0K1OIhT65RDG+HVyodDBKPTLQ3gKL+EtDN/aaBT65RA+wvkYDXbNQ3gKY0wvxr/91hbNc81DeAov4S2MOWexC4fwEU4yCv3yEJ7C5fv9GHbQPNdswi4cwkc4395tFPrlITyFcb6d4uC64Ur9cpJxpX65xvx+bDtonrtrhSvyyy6MOZcvPswvJxkf5t/N/YPmuftvTfbIZI9MfE18TXzxYX75CMu54XJuuPi6eOED3Oscwwf4d2/+oKmuOcn4AL88hKfwEq4sqW2sp01cdGIQDzEf4rlqwEHE+VR7hpq/7MIhjOOpY0bNg1Hzl4fwFF7CW9iEXTjvY15P9dU1DiIGz+IlvIVN2IVD+AgnGaFweQiL7xDfIb5DfIf4DvEd4jvEd4rvFN96rEx9U6rGu8ZNNGJ5fj+GnHoeWz0H8tTz2BoHsQ7o+7XkoOWueQvXAX1300+13PU/DeIh0nHTcdOxPvwvLuImGpFumxZIgO+XloM2u+YljPnXyYIEuOzCIVwb8t31P2i/u4wEuDyE4RvFGL8WH2lwOYQxfs0faQBGGlwewlN4CW/h8j210bgSuBzCRzjJuBK4PISnMMasfUfFn1pbVPzlITyFl/AWxpxrzVHxl0P4COdjtNk1D+EpDF8v3sIm7MIhfITz7Z0jDC4P4SmMfdnF8dbNUeiXk4xCv4xjiWKuFdrsml0Y45cvPuUvJxmf8vWjA9rs7r9dU3gJi+8S3yW+uBK4fIR5bvj+CYvvFi98+tcPHGizm/UDB9rsmpOMT//LQ3gKL+HKklra+j39ohODeIj5sK71Lw5irVGCTdiFQxjHU8eMmgej5i8P4Sm8hLewCbswxq/zD7V9eQhP4XWfwn2qA6/RiE4M4iHmw3rO/8VB3Pf56wfvLL3oxLhPGD+OJ/oDs7F66xoHcRIXcRON6MQgHiLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0QCbWd6L5rPsI8LdB91zyEcVp48RLGaXeKTdiFQ/gIJxmRcHkIT+ElLL740lC/ucWNDXAtL/6TQ8yH9fqAi9/Yq35vQxfeqt/AqgvP69eaasJrzIf1/OT6Cac68BoncX1Yi1hPh7xoRCcG8RDzYT0d8uIgTiLdgm71Yb8qoNBbt/B/r8JfOJAq/OYlvIUxzvchhF65VVeT6JVrnsJLeAubcK12/fiDXrnmI5yP0UPXPISn8BKGrxebsAuHMHxHcZIHfFfxEJ7CS3gLm7ALh/ARTvIU3y8EvG551cPlGhfx2/O6ZVR9dY1O/M6wumFfTXWN+bCeyHxxECdxETfRiE6k26LbxurtYqxSTX5jlWqe24VD+JAN42RxjVNfWvGEuGYXDuEjnOS6lF/1Uw+eENc8hZfwFjZhFw5hzP8UJzl+wkMYvrX7sYQx51pPVPTlIYx/W2uLir78bVvdw6meuEYnxkNUOc4dVHPdva7GN6/7T9X31ujEb4y6sVRNb43ZWC1v/rWan+p4a5zERdxEIzoxiIeYDwfdBt1Qo/XbDlreVv1Wg5a3Vffs0fJ2GbV4eQjXOPV7CFrY1ve3UgctbM1JXj/hITyFa7XrXjha2JpN2IVD+Agnef+E4buKp/AS3sLwrXVDdV4u3/o9BO1vzUmui/PmITyFl/AWNmEXFt/6aK7v3NX9drE+mi9+e15fxKv1rXERvzOsvuVX31ujE4N4iPmwPpovDuIkLiLdgm6B1aszEHVcv8yg/23Vrxvof2vewiaMcerA8clcPxDgGXDNS3gLm7ALY7WrUvDJfDmbE/1vzUN4Ci/hLQxfK3bhED7C5fv9MJHof2v+vol9RZm/99aD/L23HuTvvfUgf++tB/l7bz3I33vrQf7eWw+y+tsaN9GIdMNbD4CHmA/x1oM6Drz1ADiJ676oIH/vrQf5e289yN9760H+3lsP8vfeepC/99aD/L23HmR1wjVOIt023fAuhJoO3noQhbU6p3ASF3ET43Yb5O+99SB/760H+fNJXMRNNGK1CdTM3lsP8vfeepC/99aDrAe4NQ7iJC5izbfOwbpzftGJQSy32kK89aAQbz3wwkGcxEWsY6vVeW89yN9760H+3lsP8vfeepC/99aD/L23HmT1sTVO4iLSDW89qC3EWw+AQTz/4F0IiVdvFuLVmxfHfVFBjvfWgxzvrQc53lsPcry3HuR4bz3I8d56kOO99SDx6k1gPdPxIt0G3aqvrQLjdrCNwuqX+2r+NrMBB3ESu8kvx3vrQY731oMc60ccxElcxOq4i0IjOjGIh5gP8dYD4CCW2ypcxE00YrnVDlXFAqtiv+usHO+tBzneWw9yvLce5HhvPcjx3nqQ4731IMd760FWh1rjIm4i3fDWg5ok3noAPMS870LIgbceAAdx3hcV5HhvPcjx3nqQ4731IMd760GO99aDHO+tBzneWw+y+tEaB5Fuh25oJ6/5onG8dh6N43VOonEcOImLWCPUtry3HuR8bz3Iai9rnMRF3MRvfb9fXHK+tx7kfG89yPneepDVVnax+kgvDuIkllsUbqIRnVhus/AQy+3bN3ScXRzESfzcviuznO+tBznfWw9yvrce5HxvPcj53nqQ8731IKsJrXEQJ5FueOvBr9CIToz7LoSsFrTGfPjeepDzvfUg53vrQc731oOc760HOd9bD3K+tx7kfG89yGpRa8yHRjejW33GRu1F1XHg/1p/g1VHUXUMxF98AQex/rar9u39FVfO91dcOd9fceV8f8WVE289AE5i/c2YFW6iEZ0YxEPMh3jrAbDcatXx1gPgIm5iudUe410IQFwl1nHim+zlITyFl/AWrqvTClz0lzXX1Wl9nKC/rBm+31Ggv6wZvl48heEbxVsYvqfYheGbxUe4fCv30WvWXL5fu0XiWW/N5VtxjR605vKt1EMPWnP5fm0MiWe9NcO3jhHfkS/Dt45xTmH41jHiu/Nl+NYxTheGbx0jvlNfrkqpqdVjWC8O4iQu4iaWY9Qq4dv05RAux8B/n2R8m748hKfwEt7CJuzCISy+W3zxrbmSFI1qK2q18e24gg5PfGs+wknGva7LMn+X+bvM32X+LvN3mb/L/F3m7zL/kHUL8Q3xDeMx4nsxjjFk/kfmj+/Ll6fwEpb5H5n/kfkfmf+R+R+Zf8r8U+afMv+UdUvxTfFFYtQxoiENx4iGNMwZT3xr3sIm7MKcP54E18z5o5mteQhP4SW8hU3YhcV3iC8SAMeISscxTpn/lPnPED7C3Hc0pzVj/Ciewl+1r5pCVftFIzoRY39Js2/tZnGNgf/zJhqxxsB/G8RD/PKpvjhXd1rjIE7iIm6iEZ0YxEOkm9MNFVwf+2hDW/W5jza0VZ/gaENrTjIq9TLGqd0LjFM7gN+WLh/hJKNSLw/hWu1Ti4lKvbyFTdiFQ/gIJxmVWjdd0HbWPIWXMHxr71Cpl8v3axxIPOet+QjnYzznrXkIT+ElvIVN2IW/Pa/LkWpIa8yH9e25rkuqG61xEr8zrL4yVytaoxGdGMRDzIf1kPWLgziJdJt0Q33XVytDHddXPTzhbX1PiE20mzUv4S2Mcb4zHE9sW9/vuIkntjVP4SW8hU34W+39/QaceGJb8xFOct3Vbh7CU3gJw9eLTdiFQxi+tW6WZIdvrYMPYfjWv3X41vrUGxEc/4kRnRjEQ8yH9UaEi4M4iYtIt6BbYG2zOISPcJLPT3gIT+ElvIVNuHxHrX8lRvMRTnIlRvMQxn9f52rmY7SbNQ/hKbyEa57fU4AS7WaXB/57L17CWxj//Sl24RD+9q++kFcn2cUq1ovf/tVncz3FrXERv/2rmwLVW9boxCAeYj6sS/GLgziJi0i3RbeF1f52EA1iu75841lte9aBVEU3b2ETrnFmrTwqdNZqo0IvL+EtbMIuXKv9/SKaeCZbc5JRoZeH8BRewlsYvrUX7sIhfIThW7sfP+HyXbVudWW962oHTWPNW9iEXTiEj3CSUa2Xh7D44o0IdSLjjQhAI36n2Kk1qDciXDzE7xSrC5BqJmscxElcxE00ohODeIjPrVrMGrF6uxir5MVYpSg+wkkeP2GMk8U1Tv1QgiezNR/hJNc37OYhXKv9/WVX4slszVvYhF04hI9wkhfmf4qH8BRewvBdxUbe1XZVQ+5BnMRFxBi19qjsyy4cwkc4yfisvjyEp/ASFl8TXxNfE18TXxNfF18XXxdfF18XXyRB/ciEJ7TtXecOkuDyEU4ykuDyEJ7CS3gLm7D41n31+riqB7c15sO6r16fVdVZ1jiJ3331+iCstrJGIzoxiIeYD/NHHMRJpFvSLbF63xmKXrJdvxyjl2zXVSp6yZqX8BaucerKGr1hu+79oTeseQov4S1swrXadU8QvWHNRzjJSILLQ3gKL2H4zmITduEQhm8UJxlJUPcc8dy15im8hLewCbtwCB/hJG/xrd+yK/jqsWuNi/jtef14XJ1ljU78zrCFwQ4xH36h0TiIk7iIm2hEJ9LN6IZMqLu06CXbdQcWvWS77rqil6w5hA8ZNV7X2njb6K47rXjYWrMLh/ARTjI+1esOLPrKmqfwEt7CJuzCIQzfOvNxDQ7GNfjlIQzfWrdcwuVb92rxsLXmI1zj1yUwHrbWXOPXlS8etta8hDH+LjZhFw7hI5xkpMTlITyFl7D4DvEd4jvEd4jvEN8pvlN8p/hO8Z3iO8V3iu8UX6RE3ddDl9tlpMTlITyFl/DXtl43m9DAhtMZDWyXEQCXhzCG9GKe8mhUaw5hTDmKk4zLhMuY8ime/Le4TLi8hcXXxNfE144wSw3PaWsewuLr4oUYqNuUiRi4nGRcAtTPY4l4uDyFl3CNXzcH8erTZhcO4fLFfiEe6iYa2tWalzDGr/1CPFx24RA+wklGPFyGb60J4uHyEt7CJuzCIXyav5eDY9ADgX+dEK4iVBwVKQIJ0KLm/t3c+8RUsVRsFabCVYSKo6Jm8F1Ofy8v/6kYKqaKpWKrsN7RT7iKUHFEIAi+W9CfWLKiuDBoYSpcBQ5uldi6iAiBFlMFDgEzwNeIFqYCi2gQuo1bt3HrNprOwHQGpjNAULTYKvREMj2RTGdgaoooMKwBvjK02CpMBQ4OpzKywXDY8VMxVOA8CIilYqvAImJ/EBE9QKg4KnQGR2dwdAZnqlgqtgpToTM4aoqISCwiMqLFUvENbT+UTMXEE64iVJwSKIy6wrgCL0l9YqiYJRYEfDaEqwgV8DGIFDF+KoaKqWKp2CowA4dwFaHiqEgR86diqJgqMPSBwAC18HhA3BNDxVSxVGwVdQhjQLiKUHFUpIgKlCeGiqmiZjCwjRUoT5gKVxEqjoqUDbafiqFiqsBh/yBCVtSOihThPxU4OJx8rovopsJV4BAwAz8qUkRgEXFWhW5j6DaGbmPoDEJnEDqDCBVHhZ5IR0+kozM4aoqkWFeEiqMiRSQODqcyYmNjF3Bx0cJU4DwIiFBxVGARa3/w0Lk7AJ4698RUsVRsFabCVYSKoyJFDJ3BUFMkxUgIVxEq6uDmgEgRSIoWQ0WdIXNCLBVbhamoGcwFAZ86E/FQuieGCvgYxFKxVZgKVxEqjgrMoM4QvB72iaFiqlgqtgpT4SKQFBOni2EALDzCoYWpcBWh4qioQ1jYEsRGi6FiqlgqtgpT4SpqBgvbiEBpkSIQKC2GiqliyQYjUFqYCleBw8Z5jaS4K3qmiqViq8DB4eQ7uognRSA2WuAQMIOcKpYKLCLOqtRtTN3G1G1MnUHKDNB8+MRQMVUsFVuFqRBT9BdurCgaDJ+YKpYKHJxD4ActgzgqUgRiYwXEUDFVYBEPxNYBTIWr0BlMncHUGeDrS4uhYqpYKnQGS02RFPhgQQvhE0NFHdweEEvFVmEq6gzZEyJUHBUpAoGyFwR8sFkIlBamAj44HgRKi6MiRSBQWgwVUwVmgDMEgdLCVLiKUHFUpAgESgsMjdMFFxgbC49waJEicIHRYqiYKuoQDFuC2GhhKlxFqDgqUgQCpUXNwLCNCJQWS8VWYSpcRcgGI1BaJAUeovcEDvsHYVxRtCQ+ESqOChxcnXxoP7yLiP7DJ7YKHAJmgOuQFqECi2gQso14pt4TQ4XOYOoMps4A1yEtXEWoOCp0BktNb1dTQJgKVxEqcHB1Km+2PH1iqlgqcB5gAMRGC1eBRbz/5ugAKcJ+KnQGpjMwnYFtFabCVYQKnYGrKZLCsIhIihamog7OB0SoOCpSBJLCJ8RQMVUsFTUDx6mMQHGciQiUFikCgeI4RxEoLaaKpWKrMBWuAjPAGYJAaZEiECgthoqpYqnYKjB0bQlaHc0TYqpYKrYKU+Eq6hBiQBwVKQK3QFoMFVPFUrFV1AxiQriKUHFUpAgESovBDca7cJ9YKrYKHPYPImVF8V2mxVAxVeDgFoQuIr6xtDgqcAiYAa5DWgwVWESD0G3cuo1bt3HrDLbOYOsMcB1yBa5DWuiJZHoimc7A1BRJcTBR/JnDFYiNFkMFDs4h0PB7hasIFTgPAiJFIDZaYBGxP/jLhjvAbaS+YqvQGYTOIHQG7LL+RIpgn/UnhgqdwVFTJEVgEZEULVIEkuKgZJAULaaKpaLOkIPCwKVHC1cRKmoGp05ldFQafkVAS+UTSwV8DMJUuIpQcVSkCARKC8zAIaaKpWKrMBWuIlQcEUgK/NyBZ/oZ7vvjoX5PhIqjIkUgNlrUIeDHIDza74mlYqswFa4iVBwVNQP8TIRH/D0xVEwVS8VWYbLBCJQWoeKIQIbgdyb0dfaK4rtMC1PhKnBwOPlcFxHfWFpMFTgEzADXIS1MBRYRZ5XrNrpuo+s2hs4gdAahM8B1SIutQk+k0BMpdAahprj0wG9GeAmv4aoTb+F9wlS4ilBxVKSI+1dUML1/RnXFVLFUbBWmwlUEBd69u/BphpfvGq4g8fbdJ5aKrQJHekdzFaHiqEgRCJQWQwWO1CCWiq3CVLiKUHFUpAj8TWaLJQsy9UiROy1cRajQI516pEuPdOmR3ty5YqnYKvRIlx7p0iNdeqRLj3Trke6hQtd661rfv7/Egmw9UqRLixSBqGmhR2p6pKZHanqkpmeV6VllelaZHqnpkboeqeuRuh6p65G6nlWua+261vePNbEgoUcaWj+h9RNaP6FHGnqkoUcaeqShZ1XoWXX0rDp6pEeP9OiRHj3So0d69EiPnlVH1/roWteDHXCBUl2lj7ewCX8eA1f39fDCxAVNNZw+HsKz/oFBLBVbhZVwCJd/H8JHWLyHeA/xrqdANC/hLWzC4jvEC68G9ICYKpYKHFBCmApXESq+nalXt34iReAdgS2GipoBvuMdvvfzE64iVMAHx4PXCV6B9wm2GCqmiqViq8AMNoSrCBVHRYq4rxC9YqiYKjA0ThG+CvRP8F2gnxgqpoqlYqvAIWBL8DLBFqHiqEgR8VMxVEwVNQNcxp37BtErTIWrCBVHRcoG45WDLYaKqQLn6IEIWVG8U7BFirivDr6ihsbXoH5JMBbxviX4CleBQ8AM8KLgFklxXxWMmut3BQfEVLFUbBWmwlWEiqNCTqR+sfAVOoOhpnhizAGH8BFOMl4zikv56kdNVH/1oz42YZwABhEqjgqsXm1M9aT2v6+nxTRPYfFe4r3Eux7y1BzCRzjJW3y3eN2XB2PFEAstQgUO6P6bFIFYaDFU1OmQP4ilYqswFTUDfKFLvl/0T/AFo58YKuCDExLp0WKrMBWuIlQcFZgBTgmkR4uhYqpYKrYKU+Ei7ptIcYrwlaOf2CpMhasIFUcFDgFbgoxoMVRMFUvFVmEqXMU3g4neoLxvKr0inxh4RuMTQ8VUsd4Gj/ue4hamwlXgHD0lEAu1ogPNrU8sFVuF1QwGBBdx9NuIIe7riK/AIWAGeCtSi6Vil1gQpgO4ilChM5g6g6UzwEVHi6liqdgqdAZLTfFAuA0ewlN4CePArviCqH7yGtW9+jjJeE/C74qhYqrA6mFj6nlT/e9N2IXF28TbxLueRdU8hKfwEhZfF6/7kmKsGF6U0GKowAElxFKxVZiK73SoV9F+IlQcFSkCr1IYOG/5HtNPbBWmAj44IfEGpRZHRYq4rzy9YqiYKjADnBJ4rUoLU+EqQsVRkRRoa30CQzsEBgiIoyJF8O2mnxgqpgocQkJsFabCVYSKoyJF4J0qLWoG1Qg0xn0j6hVLxVZhKlxFcIPv+5BbpIj7RuQrcI4eCJMVxRsUWoSKo6KGrka60S89xiLetx5fsVXgEDADvDGhRagon2qxG/3uYwxguo2m22g6A9MZmM4Ab1tq4Sr0RDI9kUxn4GqKJ8ZiE/DI2MsuHMI4MJzGeEIs1g+PiL28hHECGISpcBVYPWwMHhZ7/32S8bjYy+J9xPuINx4Ze9mEXTiExTfF674MGSuGWGhhKnBAqA/EQoujIinuu5LXD2KomCqWippBtQSOyfelfuKoSBFIj2q7G/flyC2miqViqzAVrgIz2BBHRYq4L169YqiYKpaKrQJD1yky+QrVT0wVS8VWYSpcBQ4BW4KMaJEi8KaVFkPFVLFUbBU1A5TSvG9evSJUHBUpAunRYsgGIz1aLBVbBc7RA5GyongTW4uhYqqooVEY/XJlLOJ9u/IVRwUOATPARUeLoaJ8Ns6q0G0M3cbQbQydQegMQmeAi44rcNHRQk+koyfS0RkcNeVT4j+RIvDLTIuh4hva8R1h8lHxn3AVoeLUv8FaV2xcgebUJ0aJCTE5wH04ZoutwlS4ilBxVKQIPAmvxVChMxhqWknh+CqBttUnUsTEwRnEUDFVLBW7hEOYClcRKjADzG3B50BMFUsFfBLCVLiKUHFUpIj9U1EzwIUxelifWCq2ClPhKkLFEWEYGqeLYQAsvLmKUHFUpIiKjSdwCNgSnyqWiq3CVLiKUHFUYAbYxvipGCqmiqViqzDZ4HAVoeKIONi5DbFkRc9WYSpcBQ4OJ1/qIuZQMVXABzPIrcJUwAdnVeo2pm5jyjaiOfWJoWKqWCq2ClPhKkKFmiIp8PF+H5vZYqswFTU0vjbs+4KZOin2fcPMFUNFHQIu9NGc+sRWUYeAK/j7ZM0eIFQcFTqDpTNYOgO+neYTS8VWYSp0BktNkRT4doG21SeWChzc/TemwlWEijpDcB2OttUWdenxxFCBGQQEfA6EqwgV8EmIFIFAaTFUTBVLxVZRM8C1MnpYnwgVR0WKQKC0GCqmCgyN0yUwABYe4dBiqJgqloqtAoeALUFstAgVR0WKQKC0GCqmCswA24hAaWEqXEWoOCqSG4zneD4xVEwV2LkNEVxRtK0+kSLGTwUOLiBkEdGc+oSrgA9mgOuQFikC1yG4dEdzag8wp4qlQmcwdQZTZ4DrkBZHhZxI6GF9Qmew1BSXHvhWgLZVxwU62lafSBG49GgxVEwVS0Vl1d05PP6zhasIFUdFikAffIuhYv+DF5F/bMIuXNf6js3BzY4WKQLfaloMFVPFUrFVmApXoTNwnYHrDEJnEDqD0BmEziB0BqEzCJ0BWlvHFUdFikBrawtsNYoHrR74MMWzP59wFTilcLIhdFqkCITORi3jy88dAG1pLZYKnUHqDFJngK9FLY6KpMAjRZ8YKpYK1ItBhIqjAgdX0YLW1ieGiqkC9XIgtgpT4Sowg9ofvLjaDRNF6LSYKsqn/pxp4KXWT5gKVxEqjooUgdCpv20a6IB9YqpYKrYKU+EqQgRCBz/GoIHV8SMFGlifcBWh4qhIEbhWMWwJrlVaTBVLxVZhKlxFqMAMsI24irkCVzEthoqpYqnYssG4imnhKkIFztH6AEZra68ovu+02CpMBYbGyRe6iLiKaTFUlI9jBriKabFVlI/jrDq6jUe38eg2Hp1B6gxSZ4CrmBZLhZ5IqSdS6gxSTNHaunAjAK2tTywVWwUObkJUIuGrIRpYW+A2SYs6hPpDp4EG1ieWCizihjAdwFWECp3B0BlMnQG+FrWYKpaKrUJnMNUUSeFYRCRFi6kCB4d1Q1K0MBWuos4Qvz5HRYrAVUwLzCAhyqca2gYef/qEqyifanUb6Fl9IkUgUFoMFVPFUoEZ4AxBoLRwFaHiqEgRCJQWQwWGxumCbzWBhUc4XIFvNS2GiqliqcAhYEsQGy1cRag4KlIEAqXFUIEZYBsRKC22ClPhKkLFkQ1GoFyBQGkxVOAcdQiXFcX3nRZHRVLgeahebXgDbah3EdGG+oSpKJ9qtht4KOoTR0X5VEfcwPNSe4AxVEwVOoOhMxg6A1yHtAgVR4WcSHhy6hNqikuParYbaEmtF2J+IlQcFSkCgdJiqJgqkFVYENxAaWEqXEWoOCpSBJrgW/z5nIP9/fLksQm7MI4S4ouMc7AwX2I8nsK1Sy22ClOBpXSIkH9/hJPs4u3i7eLtS3gLm7ALi6+LF9Kjmu0G+k+f2CpwQKgPpEeLUHFU1LmRqAKkR4uhYqqoGSQ2EBmBJis0oz5xVMAHJxcyosVQMVUsFVuFqcAMcEogSlocFUmBNtUnhoqpYqnA0HWKoMvU0RaFLtMnpoqlYqswFTiEhAgVR0WKQEa0GCqmiqXim0HgFzI8PPUJVxEqjooUgSjBBuMRqk9MFUsFztEDcWRFcdFxBS46WgwVs2YwIHQRcdHRIlTgEDCDnSLqouOJUWJB6DaabqPpNprOwHQGpjPARUeLFOF6IrmeSK4zcDX9cgJ/Hz6qI/UxDg2na/xUDBVTxVKxVZgKnB/YgwgVRwVmgGmen4qhAjMwiKViq7Dv2LA5X848DuEjnOQvYx4P4Sm8hLfwNz6urKtZ9TGO7jt5J3pVnxgqpoqlYqswFbW+9fPhxPNanzgqagbVzDfxvNYnhgrMICGWiq3iW9+6IJv1uNbHIXyEk/zFz+MhPIWX8BbG8U2IoyJFLBzfghgqpoo6vmr7m2hkfaJWuH7QnHhk6xOhAjPA3FaK2D8VQ8VUsVRsFZhBQLiKUHFUpAgEVItvnTdG/lIID5Sa1fVq+/43LhzCRzjJX/48HsLfPi4s0Hcd83gLm/Dnu3BeVT41H+Ekf/H0eAhP4SW8hbF2OHjkT4sUgfwZ+DfInxZTRe3eRIEhf1rU7k3UVF3oPBEqagYTJ21d6LSoC50nhoqpYqnYKjADnOjpKkLFUZEU6Il94m8G9cjwj/fHP/CfCx6APOs5r49D+Agn+Quhx0N4fjzAS3gLm/DnG5dD+Agn+cufx0N4Ci/hLSznz5hHhZw/Y8n5M9ZQMVXI+YNnvz4h5w86Zp8IFXL+oGO2xf6pGCqmiqViq5DzB720T4SKo0LPH9Pzx+T8MTl/TM4fk/PH5PwxOX9Mzh+X88fl/HE5f1zOH5fzx+X8cTl/XM4fl/PH5fwJOX9Czp+Q8yfk/Ak5f5A/9YvqxCNfn0gRyJ8W2D2DmCqWiq3iOz58ZlZD7eMQPsJJ/qLn8RCewksYJwc294bLFUdFUswbLlcMFXWA9fvxRGftE1uFqagZ1O+tEz23TxwVNYNqVZnouX1iqMAMHAIzCAjMABMdpsJVhIqjIkXgWxQ+mPDY1ydqgPrJeKKz9okaoH7xnfVA2P3DEnwh83gKL+EtbMJwgEBWbKzYrpEMvIS3cI2Epfty4nEIH+Ek208YxldMFbUHG3b1HeoJU4HDwL5VIPxwFD5l0Xyp2CpMRe0HrmjQPPvEUaH7ge9NLYYKnUHoDBAIG/uOQGiRIhAIhuNBILSYKpaKrcJU1MEZDgEXJC2OihSBCxLDqYsLkhZTRc3AcbbigsRhiguSFq4iVBwVSYG22ieGiqkCM9gQWwVmYBCuIlQcFZhBHRzaap8YKqaKpWKrMBWuAjNIiKMCu1Ariu7biCuGiqliqdgqyhSfRmi4feKoKNP6UjvxnNgnhgqYYnlxNdMCplhEXM20cBWYgUMcFSkCVzMthoqpYqnADALCVLiKUHFUpAhczQROsRtIWIMbSPc/MxWuIlQcFSnCfyoGo3/dFLtiqdgqMANM9KbYFaHiqEgRN8WuGCqmiqUCK4pTGZHW4qhIEYi0FuWDCzI8dfaJpWKrMBWuomZwcIoh0lqkCERaC8wA5w4ircVSgRlgfxBpLVwFZoAKRqQl9geRVrfAJxp7nxgqpoqlYqv488HVTT2AtjEffpHVOIjzIXKj7rFOtN8+sVX8HeqC5xchjUE8xHz4RUcjxoYrQqBuj896BOy+/9Eh5sNdlwnAQZzERdxEI8LPIEIFNschUgRKvgVmHxAY7UCEim8VEoixIFDWLYaKqWKp2G/tnKvvXH3n6jtX37n6KNi75Lgpe5e8Cvb8sDhVsE+cEneAFFEFe3DNWI2z+EyqttnGRdxEIzoRY2NyVXAHV4LV+IoriGp7bTTiNwoWqW64XjzEbKxW18ZBhJ9BLBW7hEOYCleB2df5gAeyHtyPxQNZn/hW4aJx+dDx+kSoOCrggjnPn4qhYnKb0PH6xFahM5g6g6kzmDqDqTNYOoOlM1g6g6UzWDqDpTNYOoOlM1g6g5UiviRAfaEt9tYK2mKfWCq2ChNRn9UH973xrvonQsVXWjg3vpK++BV04yBO4iJuohGdGES6Od2CbkG3oFt9Gh/c1kaD6hOmAkd5/02oqCXH7XM0qLZA2bcYKqaKpWKrwAxQBcdVhArMAOWFcLgifyowA2whYqPFUvGtOQb+gqPRiUE8xGzEY1kP7sfh4asHd93QoXpwnwwdqk8cFSmivjoc3NFBh+oTU8VSsVV8R+FA+BtEqDgq4F8Rhc7VJ4YK+CfEUlH+CyuA8GjhKuqeEvAQ82Hdp7g4iJOIsbG6KH7c2cGzVw8uVfDs1SeGiqmijgGFgdbVJ0yFqwgV31FgCepmBbDuVVysu43ASVzETTSiE+GHw7ejIkX4VIHZY9fcVdRdS+Ah5sPAymH2MVRMFbVyuOhCV+oT5Y1vPOhKfaKOBN8DHCmC2zboVz24OYN+1XP3GynSYqqo31WBm2hEOEAgC+6SIgvuDiELcKWBrtNjOJK6Zj+GydeV+cFdEa8r8yvwdNUn/nzwPb0aUBsXsVakmnYnWkxPda/OajHFfdJqMG2sudoVmGtAbBWmwlXUquPKAu2lT6QIVH2LoWKqWCq2CvjUoqKj9OAaDK2ip/qHJ1pFT/XbTrSKPhEqjggUcAuMhuVGmbbAaFjauj4/uDWDFs5zVxQf5i1cBWaAdUOptUgR/hMfH/r/M1UsFVuFyeqgPFuEiiMidA1QivewUYotdHVQcPdcQ8HdsxAFh9tG6Od8YqiYKpaKrcJU1PHgHhL6OZ84KmoGuIeEfs6DO0Xo5zy4fxIoVdwpiluq2NNbqleYCvhckRRo7nziK7INnMRFxJE4BMapDazmTWxFtW42Yq4HouZafaQTjZtPmApXUauF36bQuPlEikCpthgqpoqlYquAT609ejXPwSGgVKs9c6LVEj2RE62WT6QIfNa2+JsO9rGeCtq4iJtoRCcG8RDz4ffp2kg3o5vRzehmdDO6Gd2MbkY3p5vTzenmdHO6Od2cbk63r55RCtV52biIm2hEJwbxEPPhV9eNdDt0O3Q7dDt0O3Q7dDt0O3RLuiXdkm5Jt6Rb0i3pls8ND+E8uImFh3Ae3DlDe+TBXSc0QR7cwEA/4sFtG/QjPmEqqvhwp6b6EeP+3w8xH36F0jiIk7iIm2hEJ9Jt0Q0fdLhBlPigwzfQakJEiVULYmMQDzEfVvPyxUGcxEXcRLoZ3YxuRjejm9PN6eZ0q15lHGq1Kl804ufmwCCeh/UxmLgBhU7CxA0DdBImvvyjk/CJUHFUpIj6GHxiqJgqloqtQmdwdAZHZ3AwA5ypJ0XkT8VQMVUsFVuFqXAVoUJnkJzBQr/hE0PFVLFUVNM50IhODOIh5sOBsTcEjsEg/kap0l/VL9h4iH+j1O3yVc2CjYM4iYu4iViZKLFw/JjWGiqmChx/QmwVpsJVhIqjIkXsn4qhYqrQGWydQV0S58Dy1CXxE6GiZjCwhXWx3KJuZufAbtRP7TmwG/VTew4sVd3mfmKrwAwwHXMVNYOJha8L7JyYTl1g//D/UdfXzUN4Ci/hLQyHWaK+y+bEYSE5Jo6kLqCfWCrqSOqJGAvPxXzCVYSKIwLJMbEUyIeJswb5MLEUyIcWoeKoSBHIhxZDxVSxVNQMFlYH+dDCVdQMFjYD+dAiKdDp90TNoG6/LLzU/YmlorZng03YhT975Akendmc5Pq4bx7CU7hOCwNvYRPGcd9/ECqOihQxpwqsImY+XQVGg888KlJEpQyiBC1/zVN4CW9hE3bhED7CSd7iu8V3i+8W3y2+W3y3+G7x3eK7xdfE18TXxNfE18TXxBdZUve4Fp6S+cRRgbXGv/GfiqGi9rR+9VvV/UdRNbOx2/Vl/QlXESqOiprBxkmBFGpRM9g4D5BCG7NGCtXtqoWnbT5hKjADHAJSqMVR8c0AUY8WweYhPIWX8BaGQ2UJ3gGfhkVC/hj+M+RPi6Viq6gjMSwS8qdFqDgqkgLNgPVjwZr3wf9g+BsE/O//z1bxueATZ94H34HrDxHx39zXDoFNGNM9EKHiqEgR86diqJgqasKOedXXlSdMRXDGeHjV5STj0VUOHsJTGHb3H2wVpqIO2O+/CRV1wI7VxtXLFbh6aVH+OES8eujyEt7CJuzCIXyEk4yH0FwWXxNfE18TXxNfE18TXxNfE18XXxdfF18XXxdfJIvj9EKytAgVWO37b1IEkqVFnV51E26hi/CJpWKrqBnUF+2FR3Bm4FyrZNmXj3CS8YUpUI247GkxVSwVW4WpcBWh4qhIEakzSJ1B6gwqkJDtaDRsNmEXDuEjnI/RYtj8OSP60WDYvIRx4FeYClcRKnDgGyJFjJ+KpQKjOQRGC4ijIkUgplpgtISo0Q4OE1c3LY6KFIHvUC2GitqUutW40AP4xFZhKlxFqDgqUgRSqG7ELvQAPjFVLBWYARYe36FaYAZYXnyHanFU1B9cVmWgBbB5CE/hJbyF4VARih6/PNhNXL0cbBOuXlosFVsFjgS7iYxpESqOihSBjEksLDKmxVSxVGwVpqJmkDgeXL20OCpSBGImcTyImRZTBWaAWX8x8/31JISp8BJY6y9mKE4JTPSLmSe+mKEYKqaKpWKrMBWuIlToDFJmUN1/FEPFVLFUbBWmwlWEiqNCZzB0BkNnMHQGQ2cwdAZDZzB0BkNnMHQGQ2cwdQZTZzB1BlNnMHUGU2cwdQZTZzB1BlNnsDCDBTFUTBVLBWYANmEXDuEjnOT9Ex7CUxjjbwgMZBApwjCUQwwVU8VSsVWYClcBn6rI6ld8a+e6KL5VmApXgXU5EEdFioifCj0xQmcQemKEnhihJ0boiRF6YsSRuUWKOHpiHD0xzpS5naViq9AZHJ3B0RloRG2NqK0RtTWiduqpmboLqbuQugs3ojC31F1I3QWNKNOIMo0o04gyjSjTiDKNKNOIshtRC+KokF2w8VMxVGAGCbFU1AzqD9+XIaJauIpQUTMYd+gUgYhqMVRMFUvFVmEqMIMNESqkzAyphFu0hlRqMVUsFXLy2Y2lK1xFqDgqpABt/1To1m/d+q1bv3Xrt2791q3foeKo0JMPwVV9f39iqdgqsLxYNwTXwKwtVBwVKcJ/KoaKqWKp2Crgg5MPkdYiRSDSWpQP7pobIq3FUrFVGC8c0cv5RKg4KlLE+akYKqYK47cFu1/hrggVR0UdKW7DoC/zfkFAX+YTW0XtHO7rG+KpRaioFcUdfzxS9A6AR4o+MVRMFUvFVmEqXEWoOCp0BkNNx+Z3NjxS9AlXgYMziKMCi1insiN3WgwVOF0OxFKxVdTy4rcAR+60CBVHRc0AvwU4QqjFUDFV1Azww4AjanBT3RE1LY4K+GBBEDUthoqpYqnYKkwFZoAVRdS0OCpSBK6eWgwVU8VSgaGxJcgQ3ANyZEiLqWKp2CpMRR0CbkQ40qXFUZEikC4thoqpYqmoGeDOj+OCqYWrCBVHRYrABdPdYFwwtZgqlgpEQEIcWVEEyhW4EmoxVODgcPKlLiICpUWowCFgBrjegQhc77TAIm4I2cb4LRVbhalwFaHiqEgR46diqNAZDDUdvAMe9w1x4CTfNzyBh/AUxrkREFuFqcC5AW9ESYujotzrEwWto81DeAov4S1swi4cwkdYfLf4bvHd4rvFd4vvFt8tvlt8t/hu8TXxNfE18TXxxQUNfpEJXNC0cBW12PjdJXBB06LOIfyKEwijFkNFnUP43SUQRi1qBvixJRBGLWoGhokijFocFXX4mCceq355CE/hJbyF4YBTDZGCX1QCkWL4zxApLZaKraKOBHfhAt/BWoSKoyJFIHnw60kgeVpMFUvFVmEqMAMcDzKpxVGRFAeZhJv7B5nUYqqoGeBO/0Em4U75QSa1qBngXvRBJrWoGeAa5SCTrkAmtRgqpoqlYqswFa4iVOgMhs5g6gymzmDqDKbOYOoMps5g6gymzmDqDKbOYOkMls5g6QyWzmDpDJbOYOkMls5g6QyWzmDrDLbOYOsMts5g6wy2zgBXSdWiuA6uklocFSmiUg3FWF26j6fwEt7CJuzCIXzIiC385HEQTvgt4yCcWuAw7r8JFUdFisCVUouhYqqAD6ordFtCFwUR1WKomCpqW/BF4SCiWpgKV6EnxtEZHD0xUk+M1BMj9cRIPTFSTwxE1J1o6omRemKknhgpa5CIqOo9X4mIalEzwE84iYhqsVWYCqzBHTpUHBUpAhHVYqiYKpYKzMAhTEVw6xOphJ9eEql0BVKpxVAxuY05l4qtwlS4ilBxVMjWp6ZSaiqlplJqKqWmUmoqpaZSaiolsgednYnsaTFV4EixbsgeNGQmsqeFqwgVR0WKwDe0FkPFVAEfnHy4dmoRKo4K+ODkw7VTi6FiqsAVBw77XjtdYSpcRag4KlJE/FQMFdXDgwnUvaBmF/7yFHcU0RbdnGREVqIKEFktpopqH1rgLWzCWGKUDfKqxVFR7qiN+n2/eQhP4SW8hU3YhUP4CD/fjTbo5iE8hZfwFjZhFw7hIyy+Q3yH+A7xRS7lFVuFqUC7kkGECqz2gUgRCKkWdTH+A0/hJbyFTdiF4ZAlKmrQq7uri/p7XiTEVmEqXEWUWBBHRYqoEHpiqMAMNsRSsVVUT9D9Jy4cwtUTNMFJvi/EAg/hKbyEt7AJu3AIi6+Jr+OgscuOg3aIqWKp2CpMhasIFUdFioifCp1BYAY4C2Kp2CowA5zC4SpCRc1g4DSqS6wWlVdPLBXV4IPdrXvTzUc4yZU9zUN4Ci/hOo6B07Quk55wFaHiqEiKarSmGCpqJSuedzVaU2wVmMGEcBWhos6lO3KS0R15eQhP4SUMb4MwFa4C3gfiqEgRE0fvEEPFVIGjT4itwlTUDBBH1Yj9/n/qkYdYiHri4cX6xxPriPRpESqOihSB9GlR0584MKRPi6Viq8AMMMntKkJFzWDhwOoSqEVdAj1RM7gbVZdATywVW0XNAMFSfdcTHaa7uqu/p86WQOS0GCqmCvgEBHxwpIicjYkicjZmgMhpcVSkCETO3TlEToupYqmoGaBuB1JmY6JImY3TCymzMVGkjMEUKdNiqJgqloqtwlTUDAxzqwujJ/RkzZ+KoWKq0KJILQqEkuGwEUotQkUdNi4WBkIJYiKUWgwVU8VSsVWYClcRKo4KncHADA7EUDFVLBVbhamoGdRfb++JaGpxVKQIRFP9gf2eiKYWU0XNwDFrRFM1T++JaGqBGQREqMAMMFGE1hXrp2KomCqWiq3CVLiKUKEzWDqDrTPYOoOtM9g6g60z2DqDrTPYOoOtM9g6A9MZmM7AdAamMzCdgekMTGdgOgPTGZjOwHUGrjNwnYHrDFxn4DoD1xm4zsB1Bq4zCJ1B6AxCZxA6AyRf3QbeExdbLVxFqPguEQLnKx7LCMZTGS8P4Sm8hLewCbtwHWA1pO+JWJtX1GHUPes9EWstTIWrCBVHRVIshFfd9N7rJ9uyfrIo6xcqjooUgYiqG+V7IaJaTBVLhZwYa+gMhqsIFUeFnBhr/lQMmduNqCuWiq3CZG6IqBahQmegEbU0opZG1NKIWhpRSyNqLTk119JdWLoLS3cBEXXntnUXtu6CRtTSiFoaUUsjamlELY2opRG1tp4HN6Ku0F0w3QXT8wAR1UJ3QSNqaUQtjailEbU0opZG1NKIWhpRy/U8cN0F111w3QXXXUBE1b3AvRBRLbALBjFVLBVbBdYAc0NEtQgVR0WKwJVai6FiqsAMcAi4UmtRSfUDHwkKRNXB/w+uzVoMFVOFbnbqZqdudmrJpZbcDbEr5IRHh/jdRXSIPzFVLBVbhalwFaFCTjf0gY+6f7/RB/7EUlE+dct+ow98HMwa8dYiVBwVKQLx1mKomCqWCnwJ/UGEiqNCbiWg2/uJoQI+BrFUbBU4UodwFaECRxoQKQIh1mKomCqWiq3CVLiKUKEz2DoD0xmYzsB0BqYzMJ2B6QxMZ2A6A9MZIMQOTjGEWGLhEWItpoqlYqswFa4iVBwVKSJ0BtWigG9neGZu8xKu3zJx4tW992YXrt8yUR51gdWc5LrAah7CU3gJb2ETdmHxPeKLzMorsH6YKZKpHga80Rj+RKg4FGj/HnVDf6PJe+C2NJq8n3AVoeKoSBG4vMLtZDR5PzFVLBVbhalwFaECMzCIFIH8aTFUfDPAH2NsNHk/UX91iPWoG+XNLhzCRzhroNoaNHvj9g86uvv/o7JiVjv0Rg/2E1NF/dXZAm9hE3bhED7CScZfu10ewlNYfE18TXxNfE18TXxNfF18XXxdfF18XXxdfF18XXxdfF18Q3xDfPEM7QNewlvYhF04yAdbiUEPNhl1VVcmE7fUq/WawlWEiqMiReRPxVAxVSwVmAEmmqbCVYSKoyIpqimbYqiYKpaKrcJUuIpQcVR8W4nP3vus3ctDeAov4S0Mh6pFdGBPXB+gA3vifj06sJ9YKrYKU+EqQkUdCW7eowO7xe3ABg/hKbyE4XEFRqqzzO/tHfAQnsK4kgVvYRPGDT5wCB/hJONi4/IQnsJLeAubsPia+Dr26ArsBGbq2AmcH24qXEWIqMuCibsTaJWeE3tU32CeMBWuIlQcFbUbE1uDNGgxVEwVS8VWYSpcBY4HZzByokWKQE60wAxwpiAnWuAQcH6gzCHQKv3ENwDu/qNTunkJb2ETdmE41Aai4Xni15N6Su68H5Lofn7CVLiKUHFUpAiUOX5XCZR5i28GG7OpKm/ewiZcHvi1pfqcv5dxQXwj2eUlvIW/kXApWY3Oj0P4c7BrkOQq7+YhPIWX8BY2YRcOYfHd4ltlPPHbORqXJ34eQuPyXDg/qmKfOCpShGM07DhKdmGPULItQsVRkSJQzC1qN/D7UvUhUywVW4WpcBWh4qjADHA+oMxbDBVTBWaAswBl3gIzqFpEK/LEBSRakZ+YKpaKrcJUuIpQcVQkBVqRn/hmgHsG6ERuXsKfPW4ioQ252YU/b/xAgh7k5iTXF4TmITyFl/AWNmEXFt8hvkiAfQXWDzPFx3m10m80ET8RKo4IpAAqHA3Bt5TREPyEqwgVR0WKwLcD/IiGhuAnpoqlYqswFa4iVGAGAyJF2E/FUIEZ4EyxpQIzwPmBxGjhKkJFzcCxokiMK/Dx32KomCqWiq3CVLiKUKEzqJTB12o0EzeP/1vb2+1Is+NmuvfSxz4I/ZCU5lYGg4HH49kw0LAHPfYGNga+952pN6R4q75OJitD5YO2nrVWMSmJYuiHEqn8/PmObh8eZpYrlZ+/jT2I8QbwKhuVG5X7VR6uZZYTlTOVC5Urlel3G/0uJgiKCsCnYBWE2OE8LjFUxA4vEAZlgLTR64gDPkcY4oAXVAZhUAZjQG90QCdIB0NiyAyFoTIIAzQQgDE0hk6A2QQ2lxEUvGD8DnaaEcabsYuOMN4FiSEzFIbKIAzKYAyNgTUYvsTQusOVzHKm8vPnsZxFcO8sC5Wfv41zP0T2znKjcr/Kw4PMcqJypnKhcqWyUJl+V+h34R9w8ICg3VkbeIFTbXiBCcpgBJhRYN+/Y96A3fCOecMEYVAGY2gMozews40A3QWJITMUhsogDMqA+sC+sTyY0Akw15gADWAp8AsToAHaGn5hgjAoA9oALYq5xoS+QA7MNSYkhsxQGCqDMCiDMTw0KGMrRkbY7iyPzHmznJ5lQTlTuVC5PssFZaGyUtmo3Kjcr3I+qJyonKlcqEy/m+l3MQsZsfhywKeMT5MgXhffIEG87oLKIAxDWkdzYK7RUW/MNSYUhsogDMowemPsBMuBucaEToC5xoTEkBkKQ2WABmgdzDUmGENjgAawFPiSCWNlO3aCBQG3C4RBGYyhMfQB6J/hZRaMlfWBXhiTigXQAIpaZYAG6CxTBmiAhrfGAA10QDsYoAEasWUGaIAGaZUBGsD4mjIMDRKqPfzPgqFBQrWH/1kwNEio9vA/C4YGCdUe/mfB0CCh2sP/LIAGqHZvDNBgVBvBuguggQEyw1OD4Q0FsbqzLFRWKhuVG5Xx26P5RqDuBYlh/PbYUpIRq3tBZRAGZTCGxtAJxixmQWJgDTJrkPE7GQBpozPG28jPRMSAxJAZCkNl4PoUrk/h+hSuT+H6VK5P5fpUrk/l+lRu0coaVNagdqq2ZKq2cH2E6yPCoAzGwPURro9yfZTro1wf5foo10e5Psr1UW5RZQ2UNYAvOqsNj3NW27g+xvWBx5nQCRpbSOP6NK5P4/o0rk/j+jSuT+P6NK5P4/p0btHOGnTWAH7lrDa8x1ntTvVBVO2CxJAZCkNlwO8IQBnGJKKh3KjcrzImL2cZv6EASDLAUxL85QiOXeV+lcd0BJ5zRMaucqbyczoCjzzCYldZqKxUNio3KverjMzBZzlROVOZfrfQ754+AdXHyB8buoK41jI2aAVxrQsKQ2UY0gqaQyAN9ZbEkBkKQ2UQhtEbBV2DkT+hMXQCjPwJiSEzFAZogNbByJ+gDMYADWApGPknYH4y9lUFMaoLMkNhqAzCoAzG0Bg6QWMNnt6i5LOcqVyo/LSO0waenmKVlcpPqzyN5ukmVrlf5aeTWOVE5UzlQuVKZaGyUpl+t1+/W+A1xi0KKfANY1dYEM5axis1gnDWBcbQCDCLGDciBKGpZezjCkJTFyiDMTSGToC5QoXWmCtMyAyFoTIIgzIYAzSogE6A+cWExAANOqAwDA0ErYP5xYShgZwChgaCdnvOL06zG5GpszzSEs9yonKmcqFypbJQWalsVKbfrfS78EbjrRRBOOqCzFAYKoMwKIMxNIZOAG8k6CB4owmZoTBUBiGA/1BYOfzHhMogDMpgDENrRafCf5yA+YGihzE/mNAY8DewcswPJiSGZy+fY2EM/lmuVH72ckWbjcE/y0blZy+fI3QkIkZ5RIGucqJypnKhcqWyUFmpbFRuVKbfxVpjbLkKIjzL2BcVRHiWsa0piPBc0Bg6AXzB2P0UvNpbRpSrII5zgTE0hk6AET9h9IZBa4z4CYWhMgiDMhhDY4AGY1qAOM4FiSEzQAMFVAZogBbFiqKdf2MMjaETYPRPSAyZoTBUBmFgDZ6j/xwsI4xzlftVHinQMVJGDOcqZyo/zRLDcQRwrrJQWalsVG5U7ld5JEOf5UTlTGX6XaPfhX9oAMwisP7GA7+loaOx5phQGCoDpGGAwD9gUxGRlwsyQ2GoDMIweqNj6GDHYkJj6Bfgsd4FiSEzFAZooABhUAZjgAYJ0Akw+tEgiK+cgDnChMQA3TKA2gBP5S4wBmhQAJ0AfmEC2qACqBcQZbmgMrAGhTUorAH8woROUA+GxMAaVP5RDHjsh+JB3AWdAAMe25mCAT8hMxSG8TvYtMRTuQuUwRigwfBMeBC3Yp8SD+IuKAwjJAabliMQ8wJlMIbG0AnGEmMBNICFWGYoDJVBGJTBGBpBg2iYS4MANHxTBmNoDJ2gHwyoArqkZ4bCUBmEQRmMoTFAg9GNCMRckBgyQ2GoDHJ1MAIxFxhDI8DW5YgSlxFlOVt0hFleIAzKANHD+BCBeTYiIjAXZIbxO9hHRgTmAmEYv4NNZURgLgGNgboREZgLWIPCGpTCUBmEQRlYg8I/WmmupOcM4oTKIAyo3Ak0V0II5oLEMKqQTigMlQGNiP4RZQHG0BhYA2UNlDXAKmFCYagMwsAaKP8oPAV28/Hs7YLCgMoZQBiUwRiGhWAXHrGcE8Y0YkFigAYwZTiUDEuEQ5lgDON3sNmIiM0JcCgTEkNmKAyVARrAQuBQJhhDY+gXIORzQWLIDBBdARAwGh6P2y5IDJmhMFQGVMEAymAMjaETwKFMSAyZARo0QGUQBmUwhsbQrw42OJQJiSEzwEYVYNSipTF0gnowQHQHcCNWYVCG8TvYD0PI54JOMBxKxfboeN52CRDuRuFuFNZAWANhDcQYGgMbkrIhKWug/KPwFPUEY2gMnQBTD2yCIjb0XMMjNnSBMIwqYIsYsaELGgMaEf2D1ccpAKuPCZmBNWisQWMNmjIYQ2OgfTvEky7gH4WnKGgQeIoJxoDKYcjAUwAQKLogMQwLGSG+glDRBZVBGKBBB4zfwbYo4kIXJIbxOyMoVxAauqAyCIMyGENjgAbDQvAy7YLEkBkKQ2UQBiWAp8BGJh6WrbBRxJEuEAZlMIbGgCqgS+A2JiSGzFAYKoMwKAM0QDfCoUzoBHAoExJDZijUwXAoE4RBGWCjw64RIDpbFGuZCYWhMkA0jE+5EbFiOQFuY8L4HYEGmIdMKAzjdwRWZdyNxt1o3I3GGhhr0FgDzEMmZAY2pMaG1FiDxj8KTwEvhhdmF2SGwoDKwZSxgwHPh3dkF/QL8I5sxTY83pFdkBnQiOffVBYgDMpgDI2BNUgHQ2LIDIWBNUj8o/AUODxAYOiCxIDKGaAwVAZhGBaCfXO8FrugMXQCOJTxMrogmLSOiGZBMOkCYRi/M2KCBcGkCxpDJ4BDmZAYMgM0yIDKIAzKYAyNoRPAoUyAaHQJJhiKhodzmNAJMMGYkBgyA6qALoHbmCAMymAMjaETwKFMgAboRjiUCYWhMgiDMhh1MBzKhE4AhzIBNqoAoRbFWmaCMTQGiIbxdW5ErFgmVAbcrYIGmIdMMIbxO9hwRxApBCiCSBckhsxQGCqDMCiDMTQG1iDxj2LqMRbsipdd61i56oGpxwRjaAydAA5lQmJAjIkBCkNlEAZlMIbG0AnKFQOkiCStI55cEUm6QBiUATVF68ChTOgEcCgTEkNmKAyoKRqkCoMyGENj6ATYQ5mQGDKDUIMI1xR+Z0Jj6ATKNVWuqXJNlWsKvzNBGJSBa6pcU+WaGtfUuKbGNcXKaAK3tXFbnxFfaBDjmsK7TEgMmYFr2rimjWvauKaNraqxVTW2qs417VzTzjXtXNPONe1c085W1bmtKUpMz0hSNAgiSc+aIpJ0QWUQBqopokkXNAaqKeJJFySGzEA1nfGkJwiDMhgD1zSRVc140hMSA2K0UTncsJugDMaAmuqAckWjayqZoTCgRQ0gDMqAFm2AxgI6Ae7eTWANKmtQWQOKh9dE8fCaKB5e0xkPfwJrIPyjWAyN42NFcOkCYRiVG8e6iuDSBY2hE8AJNdgonNCEzFAYhgYNfYopTkNnYYozoRNgitNQH0xxJmSGwlAZhEEZoAEsBFOcCZ0ATmhCYsgMhaEyQDTMBZuyDQ2PKc6EwlAZhEEZRhU6ugRTnAn9AkSaLkgMmaEwVIahwTiAVUSaLjCGxtAJ4F0mpKuD8X7rgsJQGVDtA9CvFsXDrAsSQ2ZA5QqAGhHPry5oDKgCNMDKaEJiQCMKgLoRz68uEAbWoLAGhTXAFOcETHEmJIbMwBpU/lF4irMRcXPmBDkYEgMqp4Dr1poiMnWBMcAODNAJ4DYmoBHRP7iLewrQwlAZWANlDZQ10MbQCc77eSckBtbA+EfhKToaEZ5iQicYnkIO/M3wFAsyQ2GoAzAwxnRlgTIYQxsAU+74HVhizwyFAb8DG+3CoAzG0Bj6BeU4GKCBAjJDYagMwqAMxtAIEkQ3AAR0gDIYQ2PoBPlgGFUYp76KiNQFhaEyCIMyGENjGBqMA1hFROqCxJAZCkNlkKuDEZG6wBgaAR4BGQfxildQZ4viuY8JwqAMqNwwPgSXzkaUxJAZUAVoIJVBGNCIsCrhbhTuRuFuVNZAWQNlDbQwVAY2JGVDUtZA+UfhKRRmiTu+EyqDMKByJ+A2+HCDeKp0QWKAHZxQGCoDGhH905QFGENjYA06a9BZg/OG/wmFoTIIA2vQ6UfxPKmMw27F86QLCsOo3DiRVjxPukAZjGFYCNZMI0J1wZh6LEgMQwOsMRC8KuNgVBG8usAY8DsC6ARwKBMSQ2YoDJUBGihAGYyhMXQCOJQJiSEzQHQDQAAaHs5hQmLIDIWhMowqFHQJ3MYEY2gMnQAOZUJiyAxDg4JuhEOZIAzKYAyNoVMHw6FMSAyZAdU+AEYtqo2hE9jBgMrB+Iwb0YRBGVAFaGCNoRNgHlJgVY27sXE3Nu7Gxho01qCxBpiHTGgMbEidDamzBp1/FJ5C0Au48z+hMfQLEMEq47BOEaeKt24UcaoLhAF2YABjaAxoxNE/eG90CsArIRMyA2uQWIPEGuCVkAnG0Bg6QWYNMv8oPMU47FaEwC4whlG5cSKtCIGdAE8xITEMC6loa0w9JlQGYRgaVOgGhzIORhWBrgsSA35HAIWhMgiDMhhDY4AGsBA4lAmJITMUhsogDEoAT1FhLphgVDQ8nMMEYVAGY2gMowqCLoHbmJAYMkNhqAzCoAxDg3NkwaFM6ARwKBMSQ2Yo1MFwKBOEQRlQ7eFHEQI7WxRrmQmFoTKgcjC+zo2IFQsAga4LUIUKyAyFAY0oAGEBymAMjYE1SKwB5iETMkNhqAysQeIfPV8nbIDEkBkKAyqngOGRyimtMXQCuI1xuqwIdF2QGdCI+B28FzIFCIMysAaFNSisAfZUJySGzFAYWIPKPwpPIQB4igmJYVRunEgrQmAXVAZhGBYyTpcVIbALGkMngEMZV2cUga6isEQ4lAnCgN+BjcKhTGgMnQAOZUJiyAzQABYChzJBGJTBGBpDJ4BDmQDRMBdMMBQND+cwoRNggjEhMWSGUQVDl8BtTBAGZTCGxtAvQKDrgqEBDm0R6LqgMFQGYVAGuzrY4FAmdAI4lAmo9gGQq0URArvAGBoDKjeMD4GuZyMi0HVBZUAVoAHmIROMAY0oAOpGBLouSAysQWENCmuAecgEZTCGxsAaVP5RTD1wZnQ+eYojn/PN0wnG0Bg6ARzKhMQAX4XexmtEEyqDMCiDMTSGToAVCw6qEPW6oDIIA2qKBoFDmdAYOgEcyoTEkBkKQ2XAeRbKjcr9KsNnYEcWwbALMkNhqAzCoAzG0Bg6QWcNOmvQWYPOGnTWoLMGnTXorEFnDTppcD6uilUnYmYXZIbCAA0yYDR0PqU1hk4A14KTOsTMLsgMqGkFVBYgDMrAGiTWILEGmNJMSAyZoTCwBpl/FE4H536ImV2QGFA5AxSGyiAM6MYGMIbG0AmwLMKhDGJmpaOz4IEmCMP4HZzHIWZ2QWPoBPBAExJDZoAGsBBMaSYIgzIYQ2PoBJjSTIBomAtcCw7NEDO7oBPAtUxIDJkBVUCXwLVMEAZlMIbG0AngdyZAA3Qj/M6EwlAZhEEZjDoYfmdCJ4DfmQAbVYBQi8KhTDCGxgDRw/gQM3s2ImJmF1SG5+8oTg0QM7vAGNqABKBuRMzsgsTAGiTWILEGmNJMUAZjaAysQeYfHZ5CcZyGmFnFcRpiZhcYQ2PoBMOhLEgMw1fheON8mnVCZRAGZTCGxtAJxuJHjxMKQ2UQBtQUDVKNoTF0AjkYEkNmKAyVAb+jgMbQCfRgGN7/1BrHxBMKQ2UQBmUwhsbQCXDEc1oIjngmVAaZaWB0xM+uslG5Ublf5ZHmaZYTlTOVC5Urlel3G/1uo99t9LuNfrfT73b63U6/2+l3O/1up9/t9LudfrfT7/b1uzYCbVc5UTlTuVC5LiOw4/RAJyiDMTSGToDn4cchpiHidsEw3XH/1w68ED+hMgiDMhhDY+gEY0qzIDGwBhkaJEBlGI0PpUcCqVk2KrerDFc0DosN0baa0LRPh4MUeTaCbVfZqPyUNOZ2NiJtZ/k5eVnlZzc2/MDTB61yoXKlslBZqWxUblTuV3lkm5pl+l2h3xX0EZSDe0nofriXcWBqiKBdkBgyA6R1wJCW0UfDVUwYU5QFiSEzFIbRGxlajynKAmUwhsbQCdrBkBhQH9hDKwyVQRigAaygGQM0EEAn6AdDYsgMhaEyCIMyGANrgDyYo0HxFOssJyo/fx7jB9Gzs1yp/PztcbRvCJ2dZaNyo3K/ysOtzHKicqZyoXKlMv1uot+F1xintYa3VHUcGhreUtWM/wy+YYIwKMOQVlDVMSHRsT1giH1dUBmEQRmMYfTGOHU0xL5OGCucBYkhMxSGyiAM0AA9iqnKhMbQCTBVGYegD0gMEGCAxtAJ4CQKGh5OYsII/Ub34D2Cs1ypLFTGb6A74CAqlEQMa0G5ULlSGVfuUFYqG5VxCxrlfpURu3qWE5UzlQuVK5WFykplozL9bqPfxaCvsDkM7bM2GNqn2hjaExpDvwBBqjpO3QyhqDrujhpCURcYQ2PoBJgITEBvdEBmKAyVQRiUwRgaAzQYBoiI1QWJITMMDcY9UMsY7BOGBuPUzRDLusAYGkMnwIplQmLIDIWhMrAGcBBQDf7hLDcq4/s7ynAOZzlRGUtBlAuVK5WFykplo3Kjcr/K53YIyonK9LtCvyto2QJA+6Fr4BsEFgnfMCEzFAZIawBIw+9gAjEhMWSGwlAZRm+crYgJxARjaAydABOICYkhM0ADDB1MICYIgzJAA1gKJhATxnrrHOOUhMoyJaGyTEmoLFMSKsuUhMoyJaGyQkmoDPGpCzJDYagMoz4NZaWyUXlUpqPcrzIczFkebWkoZyoXKlcqC5WVykblRuV+leFWzjL9bqbfxeWZegLaD5rioBcOBqGpCxJDZkCISwZcgSxWKAmVlXowJIbMUBgQSiMAYVAGY2gMneBMQnVCYoAGCVAYKoMwQANYypmE6gRoAPvAUcwJSAwxITEgxBItSkmorFASKiuUhMoKJaGyQkmoHtAYOgEC3yckBtYAiahQUSSiOstC5efPd3Q7ElGd5Ubl5293yLwSUVm5ElFZuRJRWbkSUVm5ElFZuRJRWbkSURlCW2e5UZl+t9PvnsGrqMAZogpTg08Z56g241VP6BdU+JQJV9CvVUpCZZWSUFk9GkMnSAdDYkBvdEBhqAzCoAzG0Bg6AU5Yxlm/IV51QWYoDEODcaXaEK+6YPzOOMC2SkmorFISKquUhMoqJaGySkmorFISKquUhMoQorogMWQG1gCJqNC6SER1lpXKz58fR6CG8NRZ7lf5SkRl9UpEZfVKRGX1SkRl9UpEZfVKRGX1SkRl9UpEZQhKneV+lZV+V+l3z/RU6JozCRVqAy9wqg0vcAK8wITEgBsv6E5KQmWVklBZtU7QDobEkBlwnacAKoMwKIMxNIZOgND1CagP7Buh6xMKQ2WABrCUMwnVCdAAbX0moTqhXyBnEqoT0AYNkBkKQ2UQBmUwhsbQCeBLJrAGSERVUS5UrlSWmaDKBImozrJRuc2kUSZXIiqTKxGVyZWIyuRKRPUoFypXKguVlcpGZfrdTL+LWcg4QDU5k1AlAK7JZoAxNIZOcF7HRXPQpVsTunRrQpduTejSrcmZhApAN3BNKAmVCSWhMqEkVCaUhMrkTEJ1gjIYQ2OABmidMwnVCYkhM0ADWAp8yQTM2dEg2L2Y0AmwbpmQGDLDmOviC4LA1AVYt2DonOuWE6ABKneuW06ABlD0XLecAA1gFOe65QTMtg9AZcB8G7aDdcsEzLhhIVi3TMCcG42Ijc8JmHWj2tgDmQANUG1sfE6ABqg2dkcmQANUG7sjE6DBqDYiWxdAgw7IDEMDuHdEti7AWicBlGHMsQzlRuV+lYfzmeVE5Uxl/HYGVAZhwG8LwBgaQyfAomdCYsgMhaEyCANrkFkD7JjAyyPAVRsqh30ROFwEuC5QBmNoDFyfyvWpXJ/K9alcn8r1qVyfyvWpXJ/KLVpZA2ENcJJ7Vhv7IWe1hesjXB/slJyAnZIJiYHro1wf5foo10e5Psr1Ua6Pcn2M62PcosYaGGsAX3RWGx7nrHbj+jSuDzzOhMLAFtK4Po3r07g+jevTuD6d69O5Pp3r07k+nVu0swadNYBfQbXtzNdtAKqPHZVBGJTBGBoDfmc4JoSxLnhOInD8NkJaV7lQuVJ5/AaWeHi4VTERGA+34g0VG+Gsq1yo/JSEs60Ry7rKSuXndCSfMhuV+1UeiahmOVE5U7lQuVJZqKxUpt8t9LvwCZi5IGBVMXNBwKpi4oGA1QXG0AhwMAI3jeBTxRwAwacLlMEYGkMnwKrlQNdg2TIhMxSGyiAMymAM0ABGi5F/Akb+hMQADdCiVhigAfrehEEZjKExdIJ2MCSGzFAYWAMkooLSSER1lo3KT+vAodWIV53lkYhqlp9WifOvEay6yoXKlcpCZaWyUblRua/yCFJd5UTlTGW0bAWg/RSA9htqIw51QWLIDJDWAUMajn8RUzph+IcFiSEzFIbRG4ihwDusC5TBGBpDJygHQ2JAfRqgMFQGYYAGBWAM0ACtUzoBknjjpB8PuRoCHMZDrkh8ZSMmdZUrlYXKSmWjcqNyv8rPecUqJyrT7wr9LnZP4PUQiLpAGYyhMXQCeKMJiSEzFAZogA6CN5qgDMbQGDoB/AdO9RF7uqAxdAL4jwmJAVqjU+E/Tuj4G/RwTwyZYfwNDsvxEOsCYXj2Mna3R0zpKjcqP3sZxz3jedZVTlR+9jL23Eec6SpXKguVlcpG5UblfpVHNstZTlSm3030u2OtYYiKQKCojbvYhjdYDZEHiBpdkBkKA6QpANJQb4z4CYkhMxSGyoDe6ABlMIbG0Akw4ickhswADdA62DGdIAzKMDRALAOiRhcMDXDmj6hRw6k2okYXZIbCUBmEQRmMoTF0AmUNRiIqrP9HOOkqFyo/zRI7ASOWdJWVyk+zxA5DRyKqs9yvMhJRneVE5UzlQuVKZaGyUpl+1+h34R9wgNkxixh3ZA1vsVo9/zNlMIZGAM+BEy+8uGo46MOLqwuUwRgaQ1/Q8OKqjUu2DS+uLsgMhaEyCIMyGAM0OACdAPOKCYkBGgigMIzIStQg9aucDyonKkOSAQpDZRAGZTCGxtAJ4GEmJAbWoLAGhTUorEFhDQprUFiDwhpU1qCyBpU1gIcZ34yGp1dtxC80PL26QBmMoTF0AniYCYkhMxQG1uDpYdLYF23jTdZVNio/DaDDtJ7eZZafzmWVnwbQYQBP37LKhcqVykJlpbJRuVG5X2U7qEy/a/S7WMEobBvzjNM8Mc9QVA3zjAmJITNAGsYDvIWiO1snwAxkQmLIDIUBZ2UNIAzKYAyNoV+AaNAFiQEaVEBhqAzCAA06wBiGBuN70BAWOgEeZkJiyAyFoTIIgzIYA2uA810ojePds5yojIAHlAuVK5Vx8RRlpbJRuVG5X2WEjpzlROVM5ULlSmX63UK/C28ztt8bAkjNUBv4FIPa5znvCcKgDJA2nFKCfzAYB/zDhMogDMpgDDg5PgCdADOQCYkhMxSGyiAM0EABxtAYOoFBA1iKJQZogOaFx5igDDgiR8PDl0xATdG88CUTEgN+B+pgzTKhMgiDMhhDY+gE8D8TEgNr0FmDzhp01qCzBp016KxBJw3w4OqCxJAZCkNlEAZoYABjaAydAP5nQmJ4forGVLjl06+c/8IYGgONGESv2tjJbYhRPa0fMaoLhAE16ABjaAzjd8ZubkOM6hSAec2EzMAaFNagsAZFGYyhMXSCyhpU/lE4l7HT3BCGusAYhmhMHxCJOgETlgmJYfwOphOIRl1QGYQBGqBP4XY6TAduZ0JiwO+gT+F2JlQGYVAGY2gM0ABNBbczITFkhsJQGYRBCYanaQfMZfiTdqDhhz9ZIAzKYAyNoQ9Al/SDITFkhsJQGYRBGaABurE3hn4B4lkXJIbMUK4ORjzrAmFQBvTccPEIVz1bFPGqCwpDZUDlBECNiODUCflgwO9Ag5wZCgN+xwDCApTBGFiDzBoU1qAkhsxQGCoDa1D4R+EpMDFGhOuCzFAYILoBMKtEtWtjoJk14ljb2OhuiGNdkBlGFRL654xCOwUIgzKwBsIaCGugB0NiyAyFgTVQ/tHhKVpCIw5PsSAxjMqNve2GANUFlUEYhoUkDIwxdVnQGDoBHEpC/8ChJCgKhzJBGPA7sFE4lAmNoRPAoUxIDJkBGsBC4FAmCIMyGENj6BcgmHXBED1uJjbEr7axA94Qv7qgE4z5xYLEkBlGFTCNR/zqAmFQBmNoDJ0ADmUCNKiAzFAYKoMwKINdHYzI1gWdAA5lAnouA4RatCiDMTQGVG4YH4JZZyPWwlAZ8DvQoCqDMeB3DMDdKNyNwt0orIGwBsIaiDAoAxuSsCEJa6D8o/AUcoIwKIMxQDRMGRMM7DNWTDAmFAZUoQOEQRlGFQr6xxoLoP1MRMEuYA0aa9BYg1YZhEEZjIE16Pyj8BQFDQJPMUEYRuUKhgw8xYTG0C9AeGsb5xwN4a0LMkNhgAYCwO8ooDF0AjiUcejREMS6IDMUhsogDMoADRqgMXQCOJQJiSEzFIbKMESPE5CGV1XbuALZEK+6oDBUBmFQhlGFii6B25jQCcY8ZEFiyAyFoTJAA3QjHMoEY2gMnQAOZUKiDoZDmVAYKgN6LgM6tageDIkhM6ByMD7lRlRjaAz4HWiAeciExIDfgVUZd6NxNxp3o7EGxhoYa4B5yAmYh0xgQ2psSI01aPyj8BRni2Jv5AS4jQmJAaJhyucZMGqKHZAJxoAqdEC/AFGpC0YVcMKCqNRTAKJSF1QGYVAGY2gMnSAdDImBNUj8o/AU+LAg6HRBJ4CnGDfVGoJOF2SGwjAsBCdTCDpdoAzGAA2GKeO91YbjE7y3uqAw4HdQHziUCcpgDI2hE8ChTIAGDZAZCkNlEAZlMIZGAE+BQwu8qtoUDQ/nMMEYGkMngNuYMKqA4wxEoC4oDJVBGJTBGBoDNEA3wqFMSAyZoTBUBqEOhkOZYAyNAD4E8wOEo84WxVpmgjAoAyoH4+vciFixTMgM+B1ogHnIBGHA78CqOndj527s1I14b3VBYsgMhaEyCIMyGAP/6Bll1gGFoTIIA0Q3wBV/1oziz5pR/FnDe6sNh0p4b3VBZRhVsPNvlAUYQ2NgDQprUFiDkhkKQ2UQBtag8I/CU+BUyuApJhSGUblxeaIhfHWBMhjDsBAc/+C91QmYekxIDNBAAPgdBSiDMeB3DNAJ4FAmJIbMUBgqAzSAhcChTDCGxtAJ4FAmJIbMMETjyAhxqQ0nPohLXZAYMkNhqAyjCg1dArcxwRgaQyeAQ5mQGDIDNEA3wqFMEAZlMIbG0K8OxluqCxJDZkDPZYBdLYqw1QWdAGuZCaicAKgREba6QBnwO9AA85AJnQDzEJzrIKB1CsiZoTCwBpk1yKwB5iETGgMZEgJaF7AGhX8UN2FwPIBI1QWNoRNg6oFzJjySisjy1mplEAZUoQOMoTGMKuCcCY+kTgFnPPwJmYE1ENZAWAOKlG+NIuVbo0j51ihSviE2dQH/KDwFTpMQdLrAGEblcICEoNMJ8BQTEsOwEBwg4fnUBZVBGKABTBkOBacICFRdkBjwO+hTOJQJlUEYlMEYGgM0QFPBoUxIDJmhMFQGYdALRkzr4xDoAOCdggSoDMKgDMbQGMZNOhwG4ZHUBYkhMxSGyiAMygANKqAxdIJ8MCSGzFCuDsZbqguEQRnQc8OPIhB2tmjJDIWhMqByAuBGLJ2gHgz4HWhQM0NhwO8YgLuxcjdW7sbKGlTWQFgDSQyZgQ1J2JCENRD+UYVomKVCdAdkhsJQGYRBGYwBvur80U5gB0NiyAyFoTIIA26FoRfwYghmkB1PhkxIDJlh1BTHRIh5XSAMymAMjaETnPfsYBTnPbsTMkNhqAzCoAzG0BZ0RMOiQTqiYVHTjmjYBZVBGK6adkTDLmgMnQB+Z0JiyAyFFE2VQRiUwRi4pqkT5IMhMVRqkMw1zcpgDI2Ba1q4poVrWrimpTBUBmHgmhauaeGaFq5p5ZpWrmnNDNzWldv6vMWLBqlc09oJ5GBIDFxT4ZoK11S4psJWJWxVwlYlXFPlmirXVLmmyjVVrqmyVSm3tXJb40WTMUPpeH51QWYoDM/fQXL4fpzJJwTQGDoB3lI0/CgeU5yQGcpfZnL4jkdWlwBhUAbWoLEGjTXAWycTEkNmKAysQecfRYbw8TpAR8DsgsQwKjfm8R0BswsqgzDoX2bW946A2QWNoRMgQ/hY9vVEecB7ojzgHWGxC/A7AjCGxtAJznThJySGzAANFFAZhEEZjKExdAIkEp8A0Q0AAWh4ygPeE+UB74nygPdEecB7ojzgHbGxyODeERu7QBiUwRgaQycY3mXB0KCjG8904ScUhsogDMpg1MFIJD6hEyCR+ARU+wAItagqgzE0BlQOxmfciHiVdUJlQBWgAR5mnWAMaERYlXE3Nu7Gxt3YWIPGGjTWAC+0TlAGNqTGhtRYg84/Ck9xNuL5KtIJymAMqNww5Xy+fZQAmaEwwA4MIAzKgEZsgMYCOsH59tEJrEFiDRJrgHfUJgiDMhgDa5D5R+EpRj6NjhDYBcLwFI2s7x0hsAsaQydAppqRaqAjBHZBZigMdUAB4HcqoDF0gjMpuAASQ2YoDJVBGJQBGsBC8DDrhE5wJhI/ITFkhsJQGSAa5kJ5wHumPOA9Ux7wnikPeM+UB7xnygPeEeiKDO4dga4LOgEy1UxIDJmhMFSGoUFCN57pwk8whsbQCZCpZkKiDkammgmFoTKg2gegU4siBc2ExJAZUDkYX+dGRD6aCY0BVRgaINB1QWJAIwqAuhGBrguEQRmMoTF0AmSqmZAYMgNrkPhHzxcXFdAJzhcXT0gMqNwJwyON07GOQNcFxgA7OKETwG1MQCM2QCYBuIUzoTKwBoU1KKwBXlSb0AnwSuOExMAaVP5ReIqERoSnmNAJ4ClGvFhHCOyCzFAYhoWMe/gdIbALlMEYhgYjvLAXygPeC+UB7wh0XYDfgY3CoUxQBmNoDJ3gTBd+AjSAhcChTCgMlUEYlMEYGsGZIRzmQnnAe6E84L1QHvBeKA94L5QHvBfKA94R6IoM7h2BrgsKQ2UQBmUwhsYwNBgRRL2e6cJPSAyZoTBUBrk6GC+9LjCGRgAfMuI6O0JgzxZFCOwCYVAGVG4YHwJdz0ZEoOuCzIAqQAOk6ZwgDGhEARgLaAzUjQh0XcAaFNYA85AJlUEYlIE1KPyj59vQ6IXzbegTKoMwoHIKGB5J0IjnC9AnJAbYgQEKQ2VAI6J/zhegTwHG0BhYA2UNlDXAq4wTCkNlEAbWQPlH4SkKGhGeYkJhGJUb8WIdIbALlMEYhoVUtDWmHidg6jEhMQwNKnSjPOC9Uh7wjkDXBfgd2CgcyglwKBMSQ2YoDJUBGsBC4FAmGENj6BfImUj8hMSQGSC6ASBgNLxQHvAulAe8C+UB70J5wLtQHvCOQFdkcO8IdF1gDI2hE8ChTEgMmWFogJElZ7rwE4RBGYyhMfSrgwUOZUJiyAyo9gEwalGsZSZ0AqxlJqByBcCNiBXLBGVAFaAB5iETOsGZLlwA3I3C3SjcjcIaCGsgrAHmIRMaAxuSsiEpa6D8o5R3op8vu05oDJ3AsHuMnqO8E10o70Q/32+dgD1itDVehZ/QGLBLjUbEa4qnALymOCEzsAaNNWiswZl34gRjaAydoLMGnX+0YwMcHdyVwRhQOQP0CxACuyAxYAu+AQpDZRAGaNAB43cwwThfYJ2QGMbvYBKMR1gXVAZhUAZjaAzQYFgI4mEXJIbMUBgqgzAoAU5sMK9CoGvHjBiBrguEQRmMoTGgCugSHBtPSAyZoTBUBmFQBmiAbsSJzYROgBObCYkhMxTqYJzYTBAGZYCNji8TQmBni+LYeEJhqAwQDeNTbkTtBHAbE8bvFGgw5iELCsP4HUzdEei6BHA3GnejsQbGGjTWAMfGEzIDG1JjQ2qsQeMfhafA5/18d3VCZigMqBxM+cx2BaM4s12d0C9AoGvH3B+BrgsyAxqxAioLEAZlMIbGwBpQhqxuZ4asEzJDYWANEv8oPAUWHAiBXZAYUDn8DTzFhMogDMNCMCdHCOyCxtAJ4FAwCUaga8cEA4GuC4Rh/A4mwQaHMqExdAI4lAmJITNAgwyoDMKgDMbQGDoBHMoEiIa54AQXM2IEui7oBIg2mZAYMgOqgC6B25ggDMpgDI2hE8ChTIAG6EY4lAmFoTIIgzIYdTAcyoROAIcyATaqAKEWRYDJBGNoDBAN4+vciL0wVIbxOwINMA+ZYAzjdzB1R6DrKQCBrgsSQ2YoDJVBGJTBGBoDa5D4RzH1wKoAIbAdE3SEwC4whsbQCeBQJiQG+KoDUBgqgzAogzE0hk6APdWOcqFypfKY6+PACMGwC4yhMXQCrGomJIbMUBgqA2tQWYPKGlTWoLIGwhoIayCsgbAGwhogTLacoAzG0BjQ1WPwnJGx+JjiodYFlQEmBWOD05lgDDApBXQSgBC3CYmBNTDWwFgDLIsmKIMxNAbWoPGPYnoyrmB1hMkuUAZUDvYGpzOhEyAl1oQxXhR2DHc0oTBUhqGBon/gdBSKwukAzpjZCfidAsgMhaEyCIMyGAM0qIBOgGXRhMSQGQpDZRAGiB7mcgbD4twCwbALKoMwKIMxoAod0AkwV5mQGDJDYagMwjA0GLeHOh6PXdAYOgFmMRMSQ6YOxixmQmUQBtjo+ACfYbJni2K9MyEzFIYhetwe6mdk7NmImMVM6ASYxRg0wCxmQmYYv2OwKuVuVO5G5W5U1kBZA2UNMIuZkBjYkIwNyVgD4x+Fp8BGAMJkFySGzIDKwZTP/N7oxjO/9wmNAXYwvCWCYRckBjQi+ufM7w0BZ37vE4SBNeisQWcNsCx6Qj7waOyCxJAZCoMwwMgN0AnOFDYnoHIdkBkKQ2UYFtLwO5jFTDCGxjA0eH4bHwCH8oyEe0JhqAz4nQJQBmNoDJ0ADmVCYoAGFVAYKoMwKIMxNIZOAE/xDH57AgSg4eEcJjSGTgC3MSExoAroEriNCZVBGJTBGBpDJ4BD6ehGOJQJmaEwVAZhUOpgOJQJjaETwIc8Y0yfUKlFsd6ZoAzGMER3GF/jRsQSZ0JhQBWgAeYhE5Rh/E6HVTXuxsbd2LkbO2vQWYPOGmAeMkEY2JA6G1InDRDlugD9UwGonACEQRmMoTF0AjiUCfDKBZAZCkNlEAZlMIZGMBY/qSsgMxSGyoCantDGv0HrDLcxYbiNBbD4EzJDYUCLNoCwAGUwBtagsAaVNaiJITMUhsrAGlT+UTiU3gGJITOUZ/rBIwEqgzAogw3IgMbQCZ4O5YI0AH2q+B3YqAqDMuB3YG/aGDqBHQyJITMUBmgACzFhUAZjaAydoB0MiQGiYS4NAtDwrRP0gyExZIbCMKqQ0CUjsc0CZTCGxtAvGE+7XpAYhgYpAwpDZRAGZTCGdnXwCHldkA6GxIBqHwC9WjQjmeeExtAJkM8TDiVnasSMzJ0ThAFVgAZI3jmhMaARh1WNwNYloCSGzMAaFNagsAZFGYyhMZAhjZDXC/hHK/pHAcpgDI0BlRsOZcSyXpAYMsPwVWdnjRnKAmFQBmNoDJ1gzFAWwBLRwXAoE4RBGVBTNAgcyoROAIcyIT2fnRf8KN6gn1AYKoMwKIMxNAK4jXxCZigMlUEYlGHUJ2MEw4dkDED4kIyxAB8yQRggDUYOHzJhtFuGxcOHAAp8yATURwGZoTBUBmFQBmOABgboBPAhExJDZigMo+dKBdjVbgUOZQK1aIFDyQ2QGDJDYagMqGkHKIMxNIahQYEGcDUTEsPQoBRAYagMQ4Oz2nA1E4xhaFAOADRAB8PVFHRJhQZoUfidCYUBv4M2gN+Z0Bg6AfxOQRtgugJTLpiuTBAGZWgEZyYLqHOmsjihMAyjODvrzGZxgjIYQ2PoBGdKixMSQ2YYVahoa8xDJhhDYxhNVdH1mIdMSAyZATWFHbTKIAzKYAyNoRP0gyExjN850LxdGFBT9A9czYTG0C+ocDW1ABJDZigMlUEYRk0xWRjxrxc0hk6QDobEkBkKQ2UQBtS0AjoBXM2ExICaCqAwVAZhQE1PMIbG0AnKwZAYMkNhQJ8qwBgaQyeAQ5mQGB6/0yD46U5msV5FuYp6Fe0qPn61ncL6Kj5dyyymq5ivYrmKqJEBoDf6DuucCYkB7ZMAhaEyCIMyGENj6ATwLxMSA2tgrIGxBsYaGGtgrIGxBsYanP6lAwpDZRCG0aKY/oxA2QsaQyfAQmlCYsgMhWFoIFAUk5wJymAM0ADOBp4HIPA8ExJDvrpeTs9zQmUQBmUwhsZA9ibpYEBNC6AyCANqWgGoqQAaQyeA55mAmiogMxSGygANoCgmOXoAjKExdAJMciYkhsxQGCqDMLAGT5+EXeoRdDuLfRWf3gj7kiPcdhbzVXz6BggbnugsylXUq2hXsV3FvorDE53FdBXzVbx+Ta5fw06MQmP4IUWHww8pOlwzQ2GoDJCGzsMiSA2QGDJDYagMwoC27wBjaAydALOZCYkhMxQGaACbhbeZoAzGMDQwtCi8zQnwNob+hrcxNBW8zYTCUBmEQRmMoTH0CxTeZkJieGiArb4RajuL9So+fhv7lCPIdhbtKj5+FXukI/D2LD69yyymq5ivYrmK9SrKVdSraFfx+rV0/Ro8iQkArQX14S9wGKDwFxMaQyeAV8DYUIx9jGbF2J9gDI2hE2A+MmG0PU6VFAucCYWhMgiDMhhDY0B9hjUrlj4TEkNmgAawCyyKJkADtChmMBOMoTF0AviUCYkhMwwNcPSj8CkThEEZjKExdAL4oQnPuQ2mHCP2dpULlSuVhcpKZfwCAN4E5zwKbzLhKaphp3yE0F6gDMbQGDrBWBstSAyZAS0Gc4DPwGmOwmdMaAz9AoPPmJAYMgNqKoDKIAzKAA0U0Bg6AWYoExJDZigM0MAA0KABlMEYGkMnwNxlQrr61HJmKAyVQRiUwRgaQydgX2SYoUyoDMKA3+kA8kXGvshOX3TC83fOTdERdntBZZAB598oCzCGxsAaCGsgrAF80YTCUBmEgTUQ/tHhZBJOjUZA7gWFAZWDKaswKIMxtAEw5eFkJgwnsyAxQAPYqOF3YKOmDMaA34HxWSdoB0NiyAyFoTJAA1hIUwZjaAydoB8MiSEzDNE4ARphtw8YDT/Cbi9IDJmhMFSGUQUcn4yw2wuMoTF0gnQwJIbMAA0EUBmEQRmMoTH0q4NHdO4FiSEzoOcKwK4WHWG3F3SCcjCgcgrgRizCoAz4HWhQGkMnqPidBuBurNyNlbuxsgaVNaisQTWGxsCGJGxIwhoI/yg8BRYlTYyhMXQChegOoBVK08ogDKMKOD5pcBsTGsOoAo4BGq+RGq+RGq+RGq+RGq+RGq+R2rlGOsEYGkMnaKxB4x+Fp8Cud4OnmGAMqByGDDzFCfAUExLDsBCc84yQ2gsqgzBAA/QPHAq22jscyoTEgN9pgMJQGYRBGYyhMUCDYSEdDmVCYsgMhaEyCIMSwFPgZGaE1D4gAyqDMCiDMTSGUQUc03S4jQmJITMUhsogDMoADQTQGDoBHMqExJAZCnUwHMoEYVAG9Nzwox2e4mxRyQyFoTKgcgrgRpROALcxAb8DDTAPmVAY8DuwKuVuVO5G5W5U1kBZA2MNMA+ZkBnYkIwNyVgD4x/F1APHaB1TDxwhdUw9JhSGymAEcA44T+pwDhMgDT8KFzBOWdKBgT4OL9KBgT4hM0ADAVQGYdD1O+nAQJ//pjF0Agz0CWMF1iBgnNksKAyV4WqDdGB+MKqdDswPTsgHw5D2jCR+AupzAupjAGUwhsbQCTDqJyQGtGgDFIbKAA06YGggqBxGvaAKGPWCNihjTWv4nXowJIbRbqc6GNsCO8DYFvQ2JgsTGkMnwGRhQmLIDKOmgg6GC5ggDNAAvSDQAIrCOQhaB85B0Do6anq22zhFXpAZxi5BgehxlrPAGMbvKJoXLuAEuABFU8EFTMgMo6aKasMFTBCGUVPFj8IfTGgMnQCeYgI0QBvAU0woDJVBGJTBGBoBfIjB+MZZ8Uhz94TxN4bWGbseC/oFCd5l7NWmBO8yYWhtBVAYKsPQeuyupgTvMsEYGkMngHeZkBiggQAKQ2UQBmUwhna1TsLqA94lYfUxoTBUBvzOKUAZjKExjFFf0KLjRHhBYsgMhaEyCIMyoEXHYEqYU0xIDJkBNe2AyiAMyjBGY4bt1MbQCeRgSAyZoTBUhtGiY38nIVZ2QSfA1KPhbzD1mJAZRk3xMUIU7YJR0wZTxtRjgjFAA5gl/M4J8DsTEkNmKAyVARrARuF3JhhDY+gE8DsTRlsf6GDswx6oAvZhD3Qj9mEnGENj6ATYh52QGEafHmjrXhgqgzBAA7RBN4bG0C8YwbYXJIbMUBgqw/N3bOwRJ4TUphGmkBBSOwEeaUJiyAyFoTKgTw2gDMbQGPrQDYo+Z0IXJIbMUBgqgzAogxFgJtQaIDFkBtS0AyqDMIyajjOHhMjbBaOm4+AgIfJ2AnzVhKHB2AlOCMNdUBgqgzAogzFAA3Q95kgnYI40ITFkhsKAtkbrCFuVsFUJW5WyVSlblbJVKVuVslUpW5WyVSlblbJVKVuVsVUZW5WxVRlblbFVGVuVsVXZaVX/+Z//8Je//ts//eO//8u//et///e//fM//+W//N/1D/7PX/7Lf/2/f/nf//i3f/7Xf//Lf/nX//jrX//hL//vP/71P8Z/9H/+9z/+6/j///6Pf3v824fd/PO//s/H/38I/F//8td/fpb+8x+uvz5e/2nC49/jz59dVZaIx3fyi5D0WsjITTNEPBb8l4CWvgjIjhbjIgCUeMxoX4rwKpLGo+qQ8ZiEHy8rUl8Lqc912xBRSQtrX/5eXv99eU6Jx9+Xni8FtIZrUXKZIh5zm/66O+y1ELyZPmQ8BqyRCImKeFRkNmZ5HF6SiK9t0R0RRVZbyCXAalSApmmYj3P2JeCxlPxqlo5dPqZjy7bloflLGdlrieeG4tkSVl7K8Bpz5KGFiMf+58vGTI5l4p1O9GkpZBY1f5Uhd3vErUi/JBztdUUcGaJl9smjeMlQ+yqied36PL48u1XySxGObZnNTm3ssTSHJYyc2ZCg6aWE7FhnPpbbfC7Ql4xvPZod4xy5UqFEt9dKFKdLx0YRuvTRmJd5W/qsP+x1f3hWYcf0N49ifyXiORRfe73n+uP0ejW9FGG3+7Td79N+t0+L8xF55r6Z3+PHMcTVp8XiFRmbz2dFJL2qSHGMc2R5gGUdLwX4rqLrMopUXvVoqfe9tyej5jwrUh/Tz5der6j7JcpriFBrPFYyX2V4zdFmj+ghJKHFDaOkZRjF5KVhFMc8+0j8AhlCejymCV9nWY4ej8n1GiWWyWH8oE9sDvbHnM1e9kn1Jp0jVzz65HGidsnI3+aLjvt8bNG0y/dVoW9i/jrZqvW+dVS5ax1+XfTQpYZKf10Xb/I5tkRPx0GTnccg+iqj3baPft8F+u3R6zV97Dxl+tYekrwPrB3rA2vcHt9keJ7UrK32aJe1P+ZjX2UUb8SsD33NZKd/yPC8aV4GUh7bLq9liDeRLdObPnZhymsZ6i5a18j94pFb3ECCrlDafVco/a6p+x3bZ2PUQm7se4OqZ6Ra2vpM1tfGofl+x2q53bFuc/S1UHpMS1/bqMqG5tANzWH3m8OdhK1hn5s5ajg2Kkebyz5J9Hn6Y8h6eoxX587Z4PFaD3OsVHXpoZZeu0HXqT8mhFPI46iDZ9jfHLI5UjSvUasl62sZ3hRmhIzCUBON/B/JsGsa1GiW/ocM9ZbC6ytnj/+7WjV/2xdwDNXq+kCZZHktw/Gm5Rq35MUe++RfJXi+NPVryNEi8ruM5kxNRwoVmHo5PpPQ10Qsyet6eNZVyuzVxzbcawttxVs71VUR1Q9lmF2LcsufyWjXwr4dr2X4Y9aOtsbsY+vmtSa3l0+uHpbWRt5jllteTwhb9zaqm5S1Ud3sePHN77cXUK7nuPbsaycdvtek5/ueo5f7nqPXu56jy33P0fWu53AlhDyHb6HtOs2xLq/HW+93R4pnXTIiKc8ZQ66fjfrHzGXNflrtr5fW477Gy64t19qJt70fh8PfhJS7483Xo67jjMes7niph7tjYcvSn9mdXu5YjLskLxUZaazOfdIvXv27EPPcx9pXq+2LkBoX8jhtXEOm8lHXH0L6/b2TlI67Fv+mWdsyEc3pw74ZL1efQry+Sd4K6Girb9KXXZz8E03aNV/P4mgi3mlmX9/t+sVev2mS1Du1Wr6klGafCQm3iX/OETW1/qumhkd2zr5pH7oB3AE896WqvRbinT+NxLfLI+XeX3pGT5MRC3t2sDdysnc+Ou50n9uOX2Zmxzchjr2artqYfdnL/YGQpuu4oOmXNdl3IbbB1LwznKCpuSO40ow3OYPPO3Z47ITU62ROHSHJ/fYtX2K0YZe+t4h7JBX8jrvuaB2MPUr24eAra+ewPPbvXgspt4/zfT3qmsE/9ryKo4e7S3XtqJTCBp9+IGSkqkHPHO1whHiburY2u54JcF4uJpJ3ODVeZz9l0G5qPX6ih1160BnIn3q4vtXWqDl41+0PTbwYg7Q8WuYd+z9GjXs89Tg5pfW3yqtx451PIa396QSkOpqoayX9shJzGtbuL1uTd0QVXbeOiy/3Fq7juszdlWvyzqhiS1dfRGjt6n/CZW0VPbPYvP5wekdUaWTtOi2EPljfY1G8I6pybY0cryMwkri7/2kFo2SrdLz07eMrnk88RipHjLvn1c6XJ0yua835ikmpyfHPsmOZpfeXWa4baStE8/mO7Gs34h1VPY536rXBSl7xqD8QYquL1cQT4m1djWeQz+rQjLPKtw+wd1zVLyffn4Etr4V4xwC6RvBjr1dfOzTvwEpkHf6LNPpm/WCyqCts6DFbcyaL3onVw5SvMFrp1LDf/JG5m6yFTC2/1sQ7s6o5XcFDHBP8RxxUvu/UvEOFoFOzusGpmWxxau7o02v0Pc4FX48+u30k4A+b6GTCO7gKTya8c6fgZKKlDZOJlm9PJlwRscmE61hLlmvXiL8T3/aOmxdTJSveRYR9Yvx7hZvc0OMxjX/9vfKOrh57gWspYN1Z17S2wVLbDkvt9y2177DUft9S+31LdadnNa0DCunOytc7wJKabVkqtccfn5mu9z8z3W5/Znrb8JnxzrB+8pnx3MjVOeXL1tU3N5KPdH9qlb3zo+DUSv3wvbV1laky3+eJ+aju1IoO449ijhi5742yt30V9UbZO4WKeaN8tPveKHsHWTFv5IsIeSPfVqP94t2ZCveLd4wV7Bf30lS0X7wt8GC/uCJiXwl3HpFXTFD5so74No/IyfWsV0xi4SC8P/qlb7CQfGywEO8CVdBCvAOssIV4d6iCFuKKCM543UFX1uEVRyN/XxHl7B+2rnMJPkT7JsG9ybWiNh6fKVqYyXc1vFjAw66ld9eXQvwGSWvWbMqTke8N4m1HPNblaxphjTX5dpfK24WXY0XDUOTHnyLy/Y2i4SbubhRl7+pNeDZT5O5sxm+R4Aovu3eqQis8vz2i/rBsWFflentdleuGdVWut9dVvojYTMa1j+jUvcoGY/dOrYLGXndMl3ecWeX7Z1Z5x5lVvn9mle+fWflGFl1SyZ4lleywEdmxpJL7SyrZsaSS+0squb+k8r7+bR188wWcP77+7t2q4AZg9i5Xhe3D20MI24d7vypmH+71qqh9uMdVMftwRQTtw5tiarlirLpjId5hFfInwhEl0uRPIWmDmdmGWwHZNlwLyHb7XkC2DRcDst2+GeCL2LA+VKGpTHm9HPJOqqqu1V3lJxn+mFR5J1WprnjAVJVXqsc3IZ6t9nXt9bE2ombt3zZEmns5YF0Tf8ysaUOkfn8po7gn1msDXzna69t+tf+RWOHWz7ewXg/fFrxa7W7vtA0HmrltuA+Y2+0LgbltuBGY++0rgb6I2FfCHXnHOuGphzhrd++2VXjkedetwiPPvXEVHXldN4w898uZ0zWFN2fo9R07q33Dzmo5NuysluP2zmo5NuysluP2zqovIjb0/K/EdYe+0q2c77Zajg3xVeW4HV/l6xE2sg3bVSXd3q4qacN2VUm3t6t8ETEj8x1i0MjShu2qkm5vV/l6RI0stR1Gdnu7quQN21Ul396u8kUEPZnn1+nmWKbb+N8/3SVv2PAu7lWraOe6p1XBzrUdndvud26770Hqhs4tG87/S9lw/l/K7fP/Ujac/5dy+/zfF7Fh5H45/1encz0jO+o6iDyM3z39wTqky3q/9Tjqyx2A4p1UtRVo1ujxvj8+dd5Jlaz7CNI5Ruxbc9QdZlrvm2ndYab1vplW+V0fFDXT+ttmOrLbnv1Cbfp9uVzkvpnKfTOVHWYq981Udpip3DdTuW+mnnXI9faWlPL6bLjIhoDqIjtWUnp/JaU7VlJ6fyWl+Vc7t6brUbTiDX3dsYJR3dG5dr9z247O7fc79/Zhqv8ktKx4HdWXj3x7L9dc789Xvsr8x2vO7mWqY73x8MzSeAn5dlXVF8KxAyU7QtwHGkJv4Rf/BcDIY/iuiNjL6cXuP51e7P7b6e41quCD+PFeMadXoubBeVl+ZGNpvSD6WI6/vlM9LsS+rk0sjUZp7puqwZfY3eqIrkdr1K2Oe/9/nbU9imTw3y3NFdLyCi5ttTtC+v3B6x0tBQdvP24PXu8eVHTweodTwcHrLj+igzfcK87gdc2jr0Bq6/w+/R8N4t4MC2W0KN7BVLRv++2+rd6pVKxvq3cmFX7S3RUSfPa7ekdK8RQI3moq9sa974PWm8rW+oeOrKV+ORB7fUG9eudSSer1OBMdf35/jMh37tfL3Y9h8XpSVY/7LrWm2y7VFREbdjXdd6k13XapNW1wqfFe+XQ+1NfDEA9Xo6/NI9kG82j3zeO2V67uqVTQPLwTpaB5eBeowuYR7pWPzeNaJx9H+2y6XK9bNg/n7diYdyoVzHBW8wY7zfftNN+307LBTst9Oy077DTft9M31nF3B+Nx7LIk8FWwP3IfeQmpNK/bglqL89n3bk/1tAKXeUb2/av/pj3sao/2YZvGssdVNydVPa74C7ob94eMdH/UuodSsVHriQiOWvdIKjhqq9wetVU3jNpwrzij1rWO6yXjzNuwP5Iha9MwS3mZzq6KG0i63mOVrv1DGettLFeGP1pCS9Mq5baleyKClu7mo4olOqzua3+RTIe+FsHx5p1HBcebuCl317aFJurWP8ZbXIh+KKSuK3FaaXn8hxDNt/vFrcuVcii1T+uSl4npY+R/KmQNF839064p6/1U5ceL/2xV76vf1o5BZ0v7Yw/FFRLdzXGFpLUx3R8d9aGQvOb8nY9hfiYkuq/k3ZwK7yvZ7VQVvh62jvq6UdqxP/UIC+mfCrkyy1uXz4Skx3z5mqcezRHjd/E6veyVlnU/NLbrheos+qmQdWHwIcQZgPEv+OtVanOvlF0HKc4OhDv7D6X4rd7xVHjR7goZlyrOoIHcHCHePOB6MTRbdWqzYeXf7q/82/2Vf9+w8u/3V/59x8q/bVj5+9ahl2du9SMZZbwjelam26cyjtsyyjW1KvT5/pkMvfJ+tNcy3FRVwfWQLyO2Hmp+IoVlZFXbfRkf2ljJ6yNVanvZt+K+8KdKWe6cUecqYrIM5PGZeK2I3u7cNzI2dK6lqy6vB664JyDHCgVLX+7n/6xRr5uX7bWViXdlKvZApyT3OeorFUu310sRV4+69g4rmcefzeF+s1c0SC18/vntmy3eVaXgvp94N6aC32xJdveb7YqIfbMl3T/rl3z7rF/cl/2C3+x4r5jTK3J738+XEdv3kyy33dgbSw/t2Um+b6X5vpXmfnvPTtxzqcjekK9FcKx4x1LBseI+6hfcjvGFBJeUvpDgCtkXEtwY8oUEN4betElsY+hNm8Q2hsRNSRXcGBL3ab/QxpCvR3Bj6AdC+qdCYhtDrpD4xtAbO4nt6fzAOb+e2rnv+4W2Y9wZVa3XrCyVD7dS6pXypDpbKSLuG0GxmGPxbk5FY4796vSV/EzSkZ3q1B3VkV+uzmNmv3bcnof9r6tjv2lpUtfcXaSro4Z702etZSiJYv52iUv0diZ1X4sVScErmT+1yF5F1jSzZs68EBeRjlauJ6SaHJ8J6WvZ/ihzeMqPhFxJyBOH6v2kUdcbFLV7XWu/KuKxau/XF6Kll1XxhUR7xnb0jN3vGX/kKi1FWn89cs1NVB/L5ip2O4Ta16OvSzapf3kkuP9ESKX9kPKhEFv5w1PntcAfQtqGz4x3iSr6mXGrE008Kt6jB0ntWEt4tfQqvfQ7IaHspeK+8RfMXirNz00Zyl4qbcPFVGkbLqZKu30xVdqGi6nSbl9M9UWELqb6FhJMTCl9Q2JKX0gwMaX0DYkppW9ITCl9w8Np0m8/nOY3azDjoLhnTaGMg357BB2Auml+gg5AvSf+Yg5Aj3LfAah3YBVzAL6ImAPoGzIO6nE7H4XriKIZB9U7roq+BK3+PaqgpaYdlpruW2raYanpvqWmX7bUYGYMdc+rgm5ZvXtQUbe8IamdekdW8QwMmjc8nqZ5w3M/mm8/96N5w3M/mm8/9+OLCBm8b6vhfmk7+uX2c5RaNjxHqeX2c5S+iPtz5mhSO3Uf+Qs+vaxlw6pKy4ZVlRa7byFth4X0+xZyf1XVNyS10+pnCptW9jqpnXqP/EWT2ml1l1SxpHZ+gwST2ql3rSqa1E6rew0xktROa7u/yFQvIVV0kanecVN4NuO+9ReazfgtEl1EeLeiYosIvz2i/lA2vPGrcvuNX5UNb/yq3H7j1xcRm8m49hGduuuGfNSqt/NR+3pEjWxHQiq9n5BKdySk0vsJqfR+QirfyKJLKtuzpLIdNmI7llR2f0llO5ZUdn9JZfeXVN7XP5bUTt0H/6J7TLYhZ4q2DTlTtN3OmaJtQ84UbbdzpvgigvbhTTGDSe3UjXcPJrVT75gqbGat7TCzDW/9ar/91q/2DW/9ar/91q8vYsP6MJjUTr1jqmhSO+1utHkstZa6L/4FU2upm4sqmFpL3Uf/gqm1/I9ELKmdeSdV0e0dOzbkpLRjQ05KO27npLRjQ05KO27npPRFxL4S7sgLJrUz/3G52Mgz76wqOvLMTUcVHHnmvvsXHXn+PcBYUjtLG3ZWbUcqKEsbdlYt3d5ZtbRhZ9XS7Z1VX0Rw6LlfiVi+MXPPqoI7CZbL3Z0EX4+oke1ISWX3U1LZjpRUdj8lld1PSfXGIQaNrGzYrrJye7vKdqTGsrJhu8rK7e0qKxu2q6zc3q7yRQQ9mefXg3nPrG7Y8La6IVbF6u1YFasbYlWs3o5V8UUEPcixo3NtR+e2HZ17+/zfZMP5v8nt839fxIaRG8wWZt7VqmC2MH8dEkxqZ+LmQIlkCzNx09tEsoWZ7DBTuW+musNM9b6ZavpdHxQ1U/1tMw0mtTO9b6Z630x1h5nqfTO1HWZq983UNnhT71QnmNTObENyX7MdKym7v5KyHSspu7+SsvarnRtNamdtxwqmbThMtXb7MNXahsNUa7cPU30RsVMMN+2AraPyaoWuVP7kAmG9ru3VRx+9FGJ+7qPYBUJzj6h23FN/NGZa7Wreg4yukKtzSq0fCrkMXuXoHwopa/w+jqxeZy6zLjt6R3+7d2QF3akmrzrNDxFZh8TS06ubme+ErPvIjzJFEX4V0rz0VKrrBu/jyOP1owjNO6mq+Xr34ks087d3Edrhvq22pmf5SC8f8GuHmwol8sRbc7NT5XXZLWerLw8hmndQ9ZiiXnGmjzLZmv5ETKrX/erHELCXYlyTfeztrUcrSk1OH3u75rEXXtuGFFXtfoqqdj9FVduQoqrdT1HVdqSoahtSVL2xjtALr66M4Auv72Qct2XEHvBsOZppQj5r0+BLs29khF6abe4pVewx0jcyQq/4+XWp60mE8vjivNZDf1uP0Iu3cRkfjrngi7fNu1IVffH2jbEHDeT45Y6JvVbbvFOq6Gu1bxQJvVbbvGOq4FTGO2GKvlbr6hF7rfbtRFVpolpfTVTrsWG26wmJvTblT1NtHcs8iq8N1Tulis6Dar09D/JEBOdBXrBrdB7kxsrF5kFu3H50HhTuFc8nu4uY9c1Ovb+eO/jHS0FX6K1igqFUvpBr0+xRTJ8JScf1flB111OeJlKuNyL180UZPWnW6Tjjp4uyK+rusUATR4xXpdKvdkn6YbtUW88B1y8v4Lb4ojnm4V2zf7iB43ID7aOh89hDWCabnK+33l//a93w0dQNTep27Xpp8tHL5UOTT8f1AN/jkOTjfYgkNCuyj0dOygdNrl6PHOteNPLKL083q74/E+M/i7YOJJ/Por16ULC5qZWCb6u5QoKPX7rHCdEn69wDhSNdW2/l0+fZgsFqzdzz1bKOJZRmRt+719uKoNjdTM+8/ux5Nlv3sx8bX6/PR1o7flnIY4V2XHbWPhRiaw/+scmSHSHuLYA18Kp+JqKvl+J4Av8jEemgnVUVR4i3qKl6PdTc6Yil/6BN+/VCY8+OnbkXga638x72+OGzd8kSvWqQeLf5+0Pc3U/WOA82vrwp3H4gYk0YlU3kDxHuY3PHdb5Cs9/vLdK8T0SiM7RHmd9a/6NFog+b2eu4gvbm6GrlvX7u4deXurx5H+3Kni0cvvIDEXrt0yjPon8iIuKf37x8FXqjwRVxmeqjWD8TEaqI+xxR8EPjCwl+I7q/UNsgJPqh8YUEPzTdM7LYh8YVEfvQuCKiH5ruHTUFPzR+mwY/NPHnVRxX1lPZ4sr8V1pCrswVEXNlvoiQB/BfAgm5MldEzJX5ImIV0Q2uzBUS9ULefaYtQsKuzBUSdWX+zaqQK/NEBF1Zlg2uzLsUFXVlbpuGXZk7B6FX+C81vt3v7N6FpnrdzqqcDfyPV83cBziCC95e7nsh9+2M6OBtO8Zd0V8WEh68rpDo4C399uD1RAQHb+kbBq93tSo6eN023TF4+8oI2OX1syaj2V4OmXRdaMxHejl4/XcRooO33l4N+U8aBAevLyQ67uT4ZSHhwSsbdqu63N6tckUEB69s2K3qcn+3ym/T6OB183j36xiut/x6+Lr5jY6VtbF+ScMlP3mVKDp83QtSsW9vTxu+va6Q6MjT+stCwsNXd+wB6P09AL2/B6A79gBswx6A1l8evo8zofUccOqvn0bp7mWLtl56qb2U11/ftOGsqLtv+cW+vmnDWZEvJDry7LeFhIevKyQ6fN37VrHh64kIDl/3pDc6fP2knrHh67ZpdPi676yVddSbivFZ0fGtNl5qwBW9VvmihuW4CFmBCRwl9TMRK2xF+BHun4gYSX5wTMTpoj4VIR+K0Cvh1Idtoast9NO2sFUR+7QtWMSHbcGpUT9sC1ttYZ+2RVsVaZ+2BYv4sC3a8hnNPtVivZnf2oda9OPKBX7cF/GpFiu9Y3dcjv8mYzAS0RcSvNn18KfelFD79XkUV4q3mar2d9zw93cE/OoEAwhdIdHoTF+TYHTmm7fQImcpvojQWcobEaE5pfuIWXRO6QoJTgfTkX5dSnRW+UZKcFr5mLMdd+eVvozYxNKXEZ1ZPv67cntq+aZhg3NL/xGw4ILsUR+9PXrcB7yio8cVErb73H9bSnz0uFLCo6fk+6PHkxEdPSXvGD3eW4Dh0eM2bHhl5r7mdd0YzZ3q07+rUtxLLFfyicTpmv5oFNdQ6HoSPwls34R43mAkc8KSRMqHItY9mMc+7qci1pMtx0st3jyQtoJe5OAFxfcW9W5JVVmX+SpHNd4Q0l8JCb8ZV47DsTLvzCrVK+97Lc2pTvNWzuv2maZkjhDPVB9Gvu7jJDnaFjH8JMePNlf61SzeU9oS29bo6eWsPh1S7q4M/Afoot9QPXZ8/UR/W0r8Gyq64xsq/f43VPr9b6j0Hd9QvR8X8KZhw99Qbzf/KH/fV38LUHxW1vGR9XpVP78cxA8Z7jNB6/JW5l2Tr/e//LfkwtNpvR2j7L8DF3UFtmUZaem3pcRdgSsl7ArcXg66Ak9G1BVY3eEKzDa4Ardhg67gTaOsKUrPHzfsepDmcYh4v3McGf7YKStZ6GMopg+F5Cu7Rjm8Vt1wkOULSalcVzhr+1CVlFbvpNTkUyk0Zyv9Y13kupQq9HrgT6Xo9XhA6x/X6Bo+JXs16um+X+rpvl/qaYdf6r9utmUtaVMR+7RRgn7JlRH0S8HOcWW4c9BgXVwZwboE58Kej3WXKlEf6y+agj42HRuM1RUS9rFvpAR9rC8l6mN9KVEf+0ZK0Me+qVHQx6Z038e6MoI+1pUR9rEp/brZRn2s3ygxv+TLiPmlaOe4vs3dKw/6WFdG0McG9+w9H+seqUR9rH+4E/WxeYex5i0+Nm/xsXmLj81bfGze4mPzFh9bNvjYssHHli0+tvy62YZ9bNngY8sGH1s2+Fj3ND/oY10ZQR8bjCrwfGzesVeQd+wVpLrDWOsWH1u3+Ni6xcfWLT62bvGxdYuPlQ0+Vjb4WNniY+XXzTbsY2WDj5UNPlbSfb/kBsWt29KPc4jXaUrvv9fgRhkGH8R7IyT2YKJ/MyHUtb6IUM9G70d4HeveXIl+cPw7NNEPjrYNI9cTEv/g+FKiHxxXSviD40oJf3B8KdEPjl+j6AfH5P4Hx+T+B8c2vInxkPLrZhv+4LiNEvzguDKCH5xg53iuzb25GXOwroiYgw3eHzUvd1m672Df3DGOOti2w1LbFgfbtjjYtsXBti0Otm1xsG2Lg+0bHGzf4GD7Fgfbf91sww62b3CwfYOD7fcdrPuyRczBuiJiDjb4voY3g3VfPonOYP03WIIONh8bLNUVEnawb6QEHawvJepgfSlRB/tGStDBvqlR0MHmdN/BujKCDtaVEXawOf262UYdrN8oMQfry4g52GjneK6t3I6u8EXEHGy5HVvhvwsXncH6L9RFHWzeYal5i4PNWxxs3uJg8xYHm7c42LzFwZYNDrZscLBli4Mtv262YQdbNjjYssHBlvsONt+uii8i5mDz7Yr4r+ZGHaz/fm/UwdYdllq3ONi6xcHWLQ62bnGwdYuDrVscrGxwsLLBwcoWByu/brZhBysbHKxscLCywS/lu4d+b0Tcf6R95C2CiC93Kn8i4nouVtpLEdVNs7zyipXC91S/vXmXsrfNH8hb5ec0iH3yjvu74sf9XfGyIV77TfaN6CfPNgQMuELinzzbEefiSwl/8mxHnMsbKdFPnu2Ic8n3HyT0ZUQ/eTueJHxI+XWzDX/y7gdDvJER/OTdD4d4kxMo9MnzRdxPsRT75PkiIp+8N5m85qDjanzP5PUmCdd1+fhRpndRvmeLSdk9SGrrwejUEwX+2PGtPt6MKOe+7JQ8WpXyXZX76QldEaF3znwRoXfO5H5F9NjwUpMvJHopvPy+lPDVcl9K9Gp5OfT258qVEfxcuTLCn6vxkb77ufIbNvrKRPamAdGHGUq6n3HJC+QPj55cd9h9kt+WEh89rpTw6PG+wtHR48mIjh5PRnz0eDYbHj1uw4aTt/QNH9HiWW1w9HhBzcHEa66IWOI1uZ8/Qja8z+ILCQ/gHZkofSlxN1COHW6glPtuoJT7bqCUHW6g6AY3UHakgbEtH1HvcDo4emzHR9S2fERr/m0p8dFT847RU+8fErgyoqOn7jgkKDvOtvyGjT61602Go2kcHnsy7qQgksfBlxFL5PBGRiiTgy8jlsohLkM+lRFK5vBGRiibgy8jls4hLuPT9ogldHgjI5TRwZcRS+kQl/Fpe8SSOryREcrq4MuIpXWIy/hYj1BiB0vuZzOW2MEXEk3sUPyXBYOJHYp5D2rGnm91qxNM7OAKiSZ28DWJJnYot5Nk+yJiiR3K7S0bKxuSZNuOFLmptPTbUuKzzbbjLc3S7r+l6cqIzjbbjrc0S9vwlqbfsOHEDrZjrdaP26NHdjxKLVv2KHr5bSnx0dO3HBf0DccFfcNxQd9yXNB3HBf0DccFjyn2ayHhxA7VyzUdTexQ/XOlWGKH6j3RFkvs4IsIJXZ4IyKS2EE3JHao7oWtYGKHHwh5mdjhjZUFEztU9yXAYGKH6s34ookdavJMNZzY4SdiXid2eLPdEkzsoPcTO1QvT1NwZWA7vqG24xta869LCX9DfSnRb2jN908LXBnBb6grI/wNrXnDaYHfsDsSO9TxKh40SVpeHxpWL09TMLFD9Q4/gokd2o6jj7phMdo2HH34QsKDuMhvS4m7grIjfqCW+/EDroyoKyg74gfGacBtV1A2xA9I8xZebTVKOSpN/f5QxX2frS2HkhqFW9dvCWXTjnyHtd7Od6hpRxRd2rGgrbX/tpT4OK478h1WuZ/v0JURHceyI99hlQ35Dv2GjX7S3Qu64dEjt9MbaWkbRo8rJGz3mn5bSnz06I4t2ar3t2RdGdHRozu2ZKtu2JL1G3bHV7CUdSBSCl0z+P4VdIU8NlhWdQ7NzqfUO/PaI0WbrG2lZleF9Ccy+jqv0p7tQxnX9laX1zL0fuopX0bsOkt04LjX7Da87vnGwwav2dV2bBh8npDwNbs3UoLX7Hwp0Wt2vpToNbs3UoLX7N7UKHjNrnoHX9FvRrP73wxPRvyb0X/dbKPX7PxGCfqlZvf9UrBzXBlyPy2KLyNYl+DU3r0yuCEtyps1YNDHyrHBWF0hYR/7RkrQx/pSoj7WlxL1sW+kBH3smxoFfawc932sHPd9rCsj7GMl/brZRn2s3H9g4Y2MmF+SY4OPdbcfgz7WlRH0scFtUO+NT3eXOvrGp79fHvWxeYex5i0+Nm/xsXmLj81bfGze4mPzFh+bN/jYvMHH5i0+tvy62YZ9bN7gY/MGH5s3+Nhc7vvYXO772OCps5umekcKVdvxJI/UHcZat/jYusXH1i0+tm7xsXWLj61bfGzd4GPrBh9bt/hY+XWzDfvYusHH1g0+tt73sX5UaqwuvoxYXaLRsZ6PlR0+Vrb4WN1hrLrFx+oWH6tbfKxu8bG6xcfqFh+rG3ysbvCxusXH2q+bbdjH6gYfqxt8rG7wse3+mZcvI+hj2+0zL/96VdTHlh2vKcuOMy/ZcuYlW868ZMuZl2w585ItZ16y5cxLNpx5yYYzL9ly5iX918027GM3nHnJhjMvuX/m9eb6aSiFarn9mrJ/nzeYQvWNkFgK1TcvgwS/OfX+S9nRF0q8M0DbsD/95imb4DdHjw3vwrpCwt+cN1KC3xxfSvSb40uJfnPeSAl+c97UKPjN0XT/OWNXRvCb48oIf3M0/brZRr85fqPE/JIvI+aXop3j+rZyf3/alxH0seX2/rT/xF3Ux/qP7UV9bN5hrHmLj81bfGze4mPzFh+bt/jYvMXHlg0+tmzwsWWLjy2/brZhH1s2+NiywceWdN8vpbvz+jciIvP6N4/VBj19uh/tEX0012vRvGM2nbfMpuuGO7SukLin96VEPb0rJezpXSlhT+9LiXp6v0ZRTy/3r36r3L/67cqIe3r5dbMNe/r7eabfyAh6+vuZpt88px/0sceGk8jj9kmkn3Uh6mOPHVHLbubCsLHqFh+rW3ysbvGxusXH6hYfq1t8rG3wsbbBx9oWH2u/brZhH2sbfKxt8LF228e+yUoTmU2/ERGZTbd2u0F9EaH29EXEmrNtuADoCwm7+bbh+W1XSNzNtx2pZX0pYTffdqSWfSMl6ubbjtSy7ms/UTff778a78qIu/n+62YbdvP9/oGZLyPo5vvtA7M3wUD9emr5+VDxEvMTIY8/7JcQapNvtbHDNZPeDlLlMyk1PY0IZpKTvaxO3tEmeUub9C1t0m+3iRcN27tcD4xzGkNtPxFyGWxv2RHivmt6rLfDHmX6avxITOyhBF9E6J2ENyIizyRU75XzaM+8ERLrmWptR8+4YmI944sI9cwbEaGeES9vZ7kSYRQauuXbK3e+kLweNX0IsZdCijcTz3U9c5Jrumbi+u2pWPOeMUy1X1MbeiPoTyFegNZ607SVS4/HNPAHMtrKU9A0eTK8B7aOlUY8J+qb+l2Id5er6XSrrZujiHfwUdJaZ5VHs77s3x/0jb3sG99IyvpKfMl18CMZktcjUFLKaxvxnrSSfq0bu/ZPhayX6TwhxZtyxoy1Hm5ejpUwt7cvEVr2AyG5LO+c5VMh1yqp85vEPxOS9MpV0uTT6qznuR41y44Qb01uV/5DU+eLFRfSPxXSr6l8dz56fpvUq01EX7bJGzffrhwhtCj/Y+B42bk409BLv+hmXLBu61Hxzo7xD+cq7kvC9Mh6dbyApA3fLPfpwuA3y5MR/WZJ3fDN8l4ujH6zvFOt+Dcr3Dfm9Y37LPJ6Az89Vm2OkH77W/FOk7Xdkg9eZH0X4j1qV1YP18PrHd2QbsjXpKb1QDM9FP137ORwDfa4DLZ91q45pTUtSc2Zu3rb++F29XY5urRlarQu+dPq3UO2ULu6/rWlFfXdUisv/av/1YouG30hwWWjm00jvGzEW5q/LSf4hKIvI/aE4hsZoScU3QMYu85w2ksP6y0switH6xu+wt49luhX2JMR/Qq3vOEr7J0oRb/C3hW9+Fc43Df2mY3EFo6uiOi60dvcD68bfSGhucD9PQ5vYyG6anRlBJdqrozgSs3LLR1dqMVl9A9lxJZppe/4xLitGlyJu7WJWki/v63gythRl6il9vuW6j2CHrXUuIz+oYyYpcqWvXi/VWO7Ev4MIrYp0fwcEZFNCS/k/li2/pjR8EPf7bsaXva4vL50pfBs6CcyyooQeKzI7LWMevdAz2uP0q/T9IOa9O+0h7vtfD2RL4lGf6rfpTjfy6IrC3tRvgr7TUrR2y1i3kHLyjieKW7jW3u4EtbsklPY/SHBDRJcUUJJ+E37b0EOroyarwldLi9lpOZmvuq56VrtPrPfvTgAc9MkriXmY3OEIjZyict4NMNB1aH5VJbv9dH7I9eVERy5ud210+omirrufBulpfh+MHnX0l0JIUt3EwcFLd2VEbZ0zxOGLd29zXisFVCmfGY5p7gMudKvizgy3NFituKbpFHkyp+jxXspNjpaXBnB0eK+PxgbLfEWSeVli4h/SNuvpXalvvlURrsvg7YP/5DhpYhLa+XwMFWa07Uel5G1LhlqH8pYgQ256PFahjeLuXIOlWfY22cyrtlHLnZfBuU++i7DzZhyrFMzPTiz6TcZ3uZytG9dGcG+9WXE+lbFmxUqzQrTBhnyoYx1wvQo2mcy7NqqM8mfyWjrMOVxmvFhe5gtv250lvK5jPZhXY5pH+Wx7vtQxkpZVlr9sG9bbZeM/qkeyz6aftq3K0nYo9g/HHN2zUG8vvWfbFt724W+lT+UcVwy6n0ZuXzqg67LErl9qEe52kP6fT08X5g3+PW8wa/nDX49bfDraYNfTxv8etrg19MGv+4FMDw2+OahxdH1o/mHlD7b41F05kHu/HTNYQqfTOc/Vh9N7p+wteYu1lfw7WMQq6eKd5QjNqWYdNp8+L5L1tyVULtWQnzc930HtHkBq1egy8M55tdCuvv45FGvC1d8F+fPCrltK1fWRDOvbV0p/eqh/tpY3OWdpmUrjwM2d8Hb68395TeKLBFPRZqniLp7/2vXPnXq5W8D2X1dJq387DW9VsSTIVd+duEe/i7DO+MWvZySNv1MxhVU9TzdfSnD75pa1v1ArfVjKWsUP8rdaZPbm8zt9iaz50keW/x0p6gfLyNcuvv0QVqn3I9DO/tMRl7TzZ5z+2iLuay7eI8yTZ1/1LdGQRAm6bWU1L1TquC2mS8jtm3WvSOmDdtmX1skf96u7ZJSPhx5du2MPuNSD693dEPv6Ibeab/bO19axI6Pe8dISnoppfe7Hs2VEDtM8Gry2NddUcAtOb75MVu4fbTiy3i4xetrY0ob+T+TYiuW6VHW9KmUy9Mbb9b8wNZavqYkrThjOB1eUHKra/n5KPf2mZjHAnTFifFtuMepy4dCUv5QiKzQ1yzUPz8S8qhCXpP6L+ul70I2HJ+7QiTJtBTJjV3BT4SUFYQjJdtrId07Ro/6aVdG0E+X27em3zTIWg9LTeI0SHVPBlZIoh7SPSnem+Vri1Fpx/X7uu+NItddVF6Y/7A619Mhj0VT+ljKOvxVDhr7sZS2pPTimL23+1LXTrRUT4g374t9R30RoQ+pW5XosbwvJHou370bU9Fz+eTN1+qxYujr16GTv6tS73skV0bQI4ne90jeBNaubTHLPPjKD4Totf9jubwW0sU1k2DwWPdSCIW/ft5lYU1r5NAE5+8okrdUp+yojvsey/LTiY+j07dQkocq7qHUshRyai39QI/xes055/uybvsupG/wA24g6/UUWf9y6PDdRftCVrN2O/rHQsoSwkdb34W4uQmPutw0R7OWenwT4l5kWZ+c/JD3Wogfh74+5r1x5MOP2qRdDdtp6/QPId3kt6V8uW7IISXfW8WXcgWmPLazD09K83fqro26/KmUa5/9YVT1Uyl1XVl6uDdxpDTvVmnwES+/cYuuZXppTuPK/XtPSe/P2fT+nE12zNlky5zNfV4t6qu9I5Doxf/unnQFrxz27mUdiF05dGUErxyOF8fuHoh274greOWwew/Oha8cxvvGGXqukQTv/fd+/65f8mRkXT76UaRJwffb9q4Qu2J/H9b/mZDwvX9XEynXbR31hPiv1l0Tv0eZvqL6EzGp1uv7Vzlm5YdiUr3EVOdeuNsypV/Nm/TD5o0mbPOeeQk+zeANn+jLDK6M2MMM+Ui3H7x4yHB3CmIPM/iaRFvV7d1YTr835noUen2SJ+Y/s/p0tUpK9vEYTNf9m/TF5+tPpjnPjACY5nDY+s9mSmu/j/zSHyLeTIWXHo+F68cT6rpuezymTWnHtNyT4q+c1lS4N4rT+L7meaz1bu9vvZER2t96yNDflRHcI/MbdVnJo33Va9Tbxwe+jMcQXl8uPV7b6xspuo5lkpb+qZQm1xmrfKxLX9dx8nGkD6VEty7e6HJFfT2f/HCkuPctg4v0N1KCi/Q3UoKL9IeUfnuR/q5xr9CPltLHzRJz2O+aJeawf9BFnsPO+e5O88Oo5f5O80OKbthpzt4T87ImxaaJTwSPuJCW6nrP6uljPxMiq4+bfDmT+N7Hcj+Cy1dkveze5Evo5B+K5PufZMn3P6dy+6WB5D7Xq+ttn8aZRP7s3nZ7q80VEdtq86oS3mpzhQS32vKhx4atNqm3t9oemuTbW20PIeXuVpsvI7bVlg+9f/fgIUTvbrU9ZNj9rbYf9I2z1eYaSWyrLY/7q3e32rzj7/BWmyskutUmumGrzdUkutUmtmWrzRUT32p7Iya61Sa6YavNFRLdahO5vSn05tXe0FabKyO61ebdpYhutbW6Y6vN0yTaqrphq8031/BWmy8mvNX2Rkx0q82d5sS22vyZUmirLZX76xzv2Cu+zvHOvcLrHP/uwLoIXB5+m+aw+QdCbAWjlf7lqtp3Ie3+Fz3djtn3RcQm025NopNpvzmCk2k/Oj0cY+Qea1LIfrLX3esmmL9yi6Ve+V22/hMhlbx0+VDIeAV3TvvspZDsRkCHx3A62oYx7D4XpXZl5FJLrzvZOyWytc3w+Oz0z5q2XtV5zB69pk15R9OmLQGH3hvtul5XzKrqmL4nRNaXK6vVl0Jy2vEk4UPKjjsV6u7eX6+AP8rpVR655AU7xWfm7vOXVa87wXSz6ftzjznl5K2drm62+nol6O6ARrcLUr6/XeDKCG4XuJt90e2ClO9vF7ibSuHtgnjfmNc3rpWsDdBszmLFFVKSXS+ddftYyHFfiMkVMa+O0ZcS3P6QDxu2UET2YwL5qRC9NpabI8Q7Cgm+tP5OSOyldb86dX3TCx/K/KlJ/3VNrhH4OIbbIOTTAfg4O7AlpDlm7793cL0fbdlzS77dRw2l/Hb3WLqGseeVqrvbZrTQF89Xu6r06/Uzz1Jqv72bk/yURcHdHFeT4G7Om5lS0WumJC/Pu5IUX0olKe0jKcETLy+bavRYxd9jjs6T5HYqCl9GdJ4k99NtZjcCLDpP0g3pNn/QN17qsnz/WCVpvX+s4r31Ez5WcYVEj1U8IfHMZXXDsYrJlmOVN4u36HmIW6XoeYgrJHoeYvd37i3fPw9xZQTPQ8YbRXe/oGY7vqCm91u1bjgP8c01fB7iiwmfh7wREz0PebPtd12W1NdPqTwNyZVSGkmRj6QE5xZVdmyFuuH/6cpVWV6HDbuTYdO1zDDLTphs8l4jE70eT1AOK/12cOZtHPJlS7qD+nwRPC7EVpDsY5vreCkkjwcHf1fKY+11XLbWPpVidoW39uxJ8SL81gN8xgc9P5JBWSKlfSjjcX6zjiP44cq/I6W5+6Ch0Fa/Yft1jtCzY29eZI601SjSaB/m4XbjQh7nTFerWOLr5OWPBI23zwPt9rOEbmUeRq/r2Jnmst9bJOfDsxNNV5y6Jk7B9b1J1L3OkGVtk33JjyTflfFPv9ZLGc+9+/paGe9BXJEl5VG0Vz7SFXE9gCB8qP8jERFPnb1zVpHjqgh/Mn4g4jLWR7F+JiJUES8BV/ST4wuJfixy0t+WEv7k+FKin5zsxRYEPzmujOAnx5UR/uRk70wl+snxGzb4yRlhKvd9WpYdPi17b8PEfJovIuTT3ogIuQJvLh30aa6ImE/zRYQqsmManbdMo3Opvy0l7tNK3eHTPEOL+jRPRtSnuU8yhX2am5cr6tP8xGtRn+ZlLdBr/5P0EPteG29Tq6w94frlsXP5NvF0LzBEV8O53p9j+flGgsNYt0wqavttKfFh7EoJD2MvwUV0GHsyosPYkxEfxlI3DGO3YXcM476uiH155f+PYSzuE7brMV3JdLX4j2HsJaWID2O5vamV3Xwf0WHsCgkPQM2/LSU+jHXHplbW+5tarozoMNYdm1pZN2xq+Q0bHcbeLa/cr7O3Tjfq/xzIXiaieqxsV4/js/x6IHtHRPGBbOX2QA4/BegNZFdIeAia/raU+EC2LVsFtmGrwDZsFdiWrYK2Y6vA9JcHckmrYUvqyRnI3o5hbStlTn14htcD2XuBKD6Q2+2FfvHTBsQGsi8kPAT78dtS4gPZlRIeyN5dr+hA9mREB7J75yw8kL2n0cID2W3Y6EBunpCyjotT4UQxx/FdFfdFmFWdzqnn8g9kyApQ4IipH8pYISzCCcV+JEPXA+hf8iB8LEM+lbHaQz9uD13toR+3x/UgvH3cHizj0/bgFHyftseVv8c+bo+26tI+bg+W8Wl7tOVCmn2sh02P2NqnevSVird/3B4s42M91nXE7vkg7955NEjRF5LTWuNkJ0jxMVtw32Tr11dTPCnZ24e9bnXxy2Ol/6A6wdhCV0g0cNPXJBi4WdyMO6HTGF9E6DTmjYjQbNN7jjQ823SFROeJJffflhKebfpSorPN4p2EBmebrozgbNOVEZ5tFi97SXS26TdscLZZct2wViul3R493nXI8OhxhYTtvqbflhIfPa6U8OjxImqjo8eTER09bmRvePR4Yazh0VPTjrWae2/vummaO9Wnf1fFfcIwrRckHrs4fEftuxDXUOgGE6cJ/x7h4b0/qOu5E+UnU34kYt2RUcpe+UMRc+DY8VIL3x8dK25GDl5X/NGi3paArEt/lUMkbwjpL4X4VramWaUch2dlbr6Q652SWtrr6rhPeh/repomfjHlDyGeqfK7K0mOtkVMSq8b191uuVLqVh4337ZbXGdCuxw9vZ7VF+9kKbYycN1r+Btad0TyFG2/LSX+DdUdgQTF7gcSuDKi31DbEUhQbEMggd+w4YMLb4fwKH/fV3+PcSxeNHtZDxJXenX9jz3TYu6bRetSV+Z9k68Xw4q0HdNpzycFp9O6YzGqWybC/h7ODilxV+BKCbsCN+Qk6Ao8GVFX0HSHK2gbHo/3GzYcU+Q2ypqi9Pxxw663bLrJ/c5xZPhjp6y38h5DMX0oJK/j2Ic8r1V3nG25QtKVA/ox8WofqpLS6p3EOaB/KIXmbKV/rItcl1WF3nT7qRS9Hhagu/g/rdE1fEp2alSP+0eyroygX3JlhP1SPX7dbMta0qYi9mmjxPySLyPml6Kd4/o2dw4a9LGujKCPDc6FPR/rLlWiPtZfNAV9bE0bjNUVEvaxb6QEfawvJepjfSlRH/tGStDHvqlR1MfmDT42b/CxeYuPzb9utmEfmzf42LzBx+YNPtbdKw/6WFdG0McG9+w9H+seqUR9rH+4E/WxZYexli0+tmzxsWWLjy1bfGzZ4mPLFh9bN/jYusHH1i0+tv662YZ9bN3gY+sGH1s3+Fj3ND/oY10ZQR8bjCrwfGzasVeQduwVVNlhrLLFx8oWHytbfKxs8bGyxcfKFh+rG3ysbvCxusXH6q+bbdjH6gYfqxt8rN72sW+C4tY1a+E8gD+Kqwu9+OCeHwQfynsjJPaW4pv7CrG+9WXE+jZ6b8Lt27zhm+NfsIl+c9qGtwlcIfFvji8l+s2JxhT43xxXSvib40uJfnP8GkW/Oe3+kxqujOg3p+14UqP2Xzfb8DfHbZTgN8eVEfzmBDvH9W3u5c6gj3VlBH1s8JKpJ8O9Axz0sW9uIwd9rBwbjNUVEvaxb6QEfawvJepjfSlRH/tGStDHvqlR0MfKcd/HujKCPtaVEfaxkn7dbKM+1m+UmF/yZcT8UrRzXN/mvoQR9LGujKCPDb7I4clwH0yJ+lj/6Zaoj807jDVv8bF5i4/NW3xs3uJj8xYfm7f42LzBx+YNPjZv8bHl18027GPzBh+bN/jYvMHHyv04C19G0MfK7TgL/225qI/1X7mL+tgd7xi6QuI+tm7xsXWLj61bfGzd4mPrFh9bN/jYusHH1i0+Vn7dbMM+tm7wsXWDj60bfGy5XxdfRtDHlvt1cZ/hjfpY/0HgqI/VHcaqW3ysbvGxusXH6hYfq1t8rG7xsbrBx+oGH6tbfKz9utmGfaxu8LG6wcfqfb/kP1MeOQN8I+L+q+/S1qvRX65Y/kTE9distJcisndBLK0EZKXwtdXvr+OJt+W/1KCHq+t3LdKGHfK0YYc83d8hTxsiuN+k9oh+9dqGEAJXSPyr13ZEvvhSwl+9tiPy5Y2U6Fev7Yh8kQ0PF8qGhwtly8OF0n/dbMNfvQ3REbIhOkLuR0e8STgU+ur5Iu7nbwp99d6IiHz13iQKm4OOq/E9Udi7HF/XfeRHmZ5K+SMFjbqnSm09NJ16olgg+3rRO7mnDjn3Zajk0qp8T9pw3E+DqLefPvNFhJ4+eyMiVJG24ba5LyR6T1yT/LaU8G1zX0r0trmmdvt75coIfq9cGeHvleZ0/3vlN2z0trnnk8JvNaj3gFo0x167P3p8IWG73/KAmislPnpcKeHR451uRUePJyM6ejwZ8dFTyobR4zZs+K2GsuMjWu4nQSty9yPqi4hlcyv300DVDR/RvOXtQq35t6XE3UDdkT9G6/38Ma6MqBuoO/LHaN2QP8Zv2KgbkC0fUUm3R4/s+IjKlo+o1N+WEh89siMXosr9gwJXRnT0yI6DAt1xvuU3bHT0uFtA0VwPqu6kIJTrwZURzPXgy4jlenBlBHM9hGXIpzJiuR58GbFcD66MYK6HsIxP2yOY68GXEcv14MoI5noIy/i0PYK5HnwZsVwP6t82DOV6CMv4WI9Yrofu5joL5npwhURzPaj/2GAw14M2743NWK4HtzrRXA/uG1jRXA+uJtFcD+l25m1fRCzXQ7q96HTTeMRfq9+RE0x7+W0p8dlm3/G8pvb7z2u6MqKzzb7jeU3tG57X9Bs2muvBS9kbXquZf64VGj1lxzvVWzLO2yG/LSU8enwp0dFjx/3jAldGcPS4MsKjx9KG4wK/YcNrNcfewrkezItVieZ6MP9cKZbrwbyvYCzXgy8ilOvhjYhIroe6IdeDuVe3grkefiDkda4H38qCuR7MfRwwmOvBvJOtaK4Hy56phnM9/ESMk+vB324J5nqQ+7kezEvdFMz1IDu+oVt2Kq3k35YS/4aWHacFVu6fFrgyot/QsuO0wMqG0wK/YXfkeqipLA+ZtLw+NDTvjCuY68G8w49grgfdcfRh9Xb8gJ9rJZzrYcfRh1X7bSlxV1B3xA+Y3I8fcGVEXYHsiB8w2RA/4Dds0BUk7yA0t9Uo5ag09ftDFffJtrYcSmoUb12/7jumtiNni8ntFIip74ii6zsCAEx/XUp8HOuOFIim91MgujKi41h3pEA03ZAC0W/Y6Cc99R2jx25nPMo53x89vpCw3Vv5bSnx0WM7tmTN7m/JujKio8d2bMmabdiS9Rt2x1fwscbXtdynewbfv4KukHpcAQCHZudT6p157ZGiTda2UrOrQvoTGX2dV2nP9qGMa3ury2sZdj8blS8jdp8lOnDcu3obXvt842GD9+ys5w2DzxMSvmf3Rkrwnp0vJXrPzpcSvWf3Rkrwnt2bGgXv2Zl38BX9ZvR+/5vhyQh/M9rx62YbvWfnN0rQL/X793+jnePK0PuZUnwZwboEp/aODH/lFfSxb9aAQR/b0gZjdYWEfewbKUEf60uJ+lhfStTHvpES9LFvahT0sS3d97Et3fexroy4j82/brZRH9s2vLHQNryx0Da8seBvPwZ9rCsj6GOD26BuVtV238e+2S+P+tiyw1jLFh9btvjYssXHli0+tmzxsWWLjy0bfGzZ4GPLFh9bf91swz62bPCxZYOPLRt8bLn/orIvI+hjg6fOno+VHVlVZcebPE12GKts8bGyxcfKFh8rW3ysbPGxssXHygYfKxt8rGzxsfrrZhv2sbLBx8oGHysbfKwblRr0sa6MoI8NRsd6Prbs8LFli4+1HcZqW3ysbfGxtsXH2hYfa1t8rG3xsbbBx9oGH2tbfGz7dbMN+9gNGYvahoxFbUPGIv/eTKwuvoxYXaL3d9zM1RteVH5z0SvqY3ecebUtZ15ty5lX23Lm1bacebUtZ15ty5lX23Dm1TacebUtZ179+HWzDfvYDWdebcOZV7t/5vXm+mkoq2q6/6Kye583mlXVFxLMquq/DBL85sj917KjL5S4b49u2J9+85RN8JvT04aHYV0h4W/OGynBb44vJfrN8aVEvzlvpAS/OW9qFPzm9Hz/PWNXRvCb48qIf3Pyr5tt9JvjN0rML/kyYn4p2jmub6v396d9GUEfW2/vT/tP3EV9bN0RZ9HLDmMtW3xs2eJjyxYfW7b42LLFx5YtPrZu8LF1g4+tW3xs/XWzDfvYusHH1g0+tt73sf4ToKE3430RoXm9/1ht0NOX+9Ee0Udz3Vf4d8ymjy2zadlwh9YVEvf0vpSop3elhD29KyXs6X0pUU/v1yjq6fX+1e8eTGssn+oR9/T662Yb9vQbck73DTmn+4ac0/5z+kEfm+6fREaf9feiltuOqOW2ZTZtO4zVtvhY2+JjbYuPtS0+1rb4WNviY9sGH9s2+Ni2xce2XzfbsI9tG3xs2+Bj220f+yYrTWQ2/UZEaDad+v0W9WXEWtSXEWvRHRlm044Ms+U47r/A7QuJevp3UmKe/o2UoKd/IyXo6d9JiXn6dzWKefqHlNsPx/syYp7elxH19OVIv262QU//plFCfumNjJBfCneO55e8Ky4q66l1ehLqe345X0QoRV3y+jaqxXFbC+/E/XEu2KZ7/TJ2c/6BEO3rJQzt5UMh7XL0/ZDPhDy+EOu1yyM71elenGM5Vg7DcrTyoZTYywRvZIReJngnI/Iygd83tl49ej6a/mEHfxFSPxWSLyHlddc8ph7OwCmP2eTs4JLqiyZ5I6Osr14pzV7LyL8ro6ZVl5rTh927nofMxg+//Kxn1uOsz1vcnwohTT4W0tY0/Bkj/qmQNZNwhfTbH5p+/zvTDy+yMaf1ycyOD/FlrLeOHsX+Qkazu23RbqeFbW6+mLQefTJ6sSllictoKw2dtJI+lLG+l4+ifihDLj0osfvPZFxL3iYf6tGXdcnD0j5tj37JeN0v5uW+kOuBTaHwss9ltM9k6JooV6VMHj+TsZKbVHNszH1AS9dnwSy9fiatHF6EWpVlqY+K0Y6Gtp9oEnqw7aHJ7ezHXrR69L02V0bwobVyaP5tKdHn2t5ICT7X9pBye4PVlxFddu84xHpIub/B+qZhg8+1eaHM8UFs6f4gfqNJcBBbuTuIvW3J6CDusmP4mf62lPggdqWEB/H9+1q+jOgg3nFf67E2zxsGsduwwUHsfc3lWDLkyK9nWY/qeJE6eSWukMxzxvZdiJf8wlbLqtEO9jchfm10zRl5b+Tv1KbtqE3/3dqklWPlUfxs1iglzS0JKdk+k3HlenkUN8jQ9KGMtnqXs4H8TMZKM/gQ92mbroOJR1E/lFEuGbU6lnr/ruUbGcF97/t3Ld3PXvA4zv/8Bk/j0nH/UXhfSPg07o2U4GmcLyV6GudLiZ7GvZESPI17U6PgaZx7QBGcUbgygjMKV0Z4RpHSr5tt9DTOb5SYV/JlxLxStHNcz3Y/Tu+NjKCHvR+n5+4OBD2sv0sR9bB5h6nmLR42b/GweYuHzVs8bN7iYfMWD1s2eNiywcOWLR62/LrZhj1s2eBhywYPe/9Wg5d1o5itw05rtP3T+ocy2mcy2jH7pXAu9Z/JWBtIpVE2y5/JqO2S0T/VY+XmbJS74Gcy1qbNo+jo4e0k59Uvjw9H/UxGOfL11SqfyjguGfW+jPyhHrlfX8/cPtSjXO0h/b4e+trWRe73rcj9vn0jI9S3YRn5Qz2CfevrEevbsB5O37pp63JdM8UsHMbyLR9g0vthLL6MWAhK0vy7MmJhLG6blvWpzMUOr029fdbllJW+Ud+2FF016hUHw3OYv6OG3d8gTd45VnCD1K2N5GWojw3Gl7XxZayNySz6ukVSK66UulyIyPGhlGBQni8jFpT3RkYkKM972CAWUONKCAXUlNtBPeV2UI93WbB3WbPs3tLL001fxjXL7i2/lJGan4D+WPEjjzKtdX8mJ2qjroygjfoyIjbqLl7yCjDqmQKMSrEfyChX+JrYaxn9vo34MoI2Yn2Pjbhygjbiy4jZyBsZL23kvz3gH//pX/723//6b//0j//+L//2r//n8Xf/+RT1t3/5x//x138+8X/9x7/+E/3bf////vf8N//jb//y17/+y//z3//33/7tn/75f/7H3/75Ken57/5ynP/zX/Nj7Vz/4fG/uf63f/hLwT/J8vwnRR7/JOE/en5Mn/87/lHCf/Xo68f/1vTf/vOp6v8P",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "InvoiceRegistry",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "ContractInstanceRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "updated_class_ids",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "private_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minter",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "upgrade_authority",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000c"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "asset",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000e"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "InvoiceRegistry"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "private_invoices",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "partial_notes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "token_addresses",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "amounts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "title_hashes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "payment_status",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::_mark_paid_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::_mark_paid_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "title_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::_store_payment_info_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::_store_payment_info_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "title_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "metadata",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::create_invoice_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::create_invoice_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::get_invoice_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "metadata",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::invoice_note::InvoiceNote"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::get_invoice_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::get_payment_info_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "partial_note",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "title_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "types::invoice_note::PaymentInfo"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::get_payment_info_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::is_paid_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::is_paid_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "invoice_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::pay_invoice_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::pay_invoice_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "InvoiceRegistry::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "InvoiceRegistry::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "InvoiceRegistry::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}
